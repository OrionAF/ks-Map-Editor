<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>

/* --- BASE & LAYOUT --- */
:root {
	--toolbar-height: 55px;
	--toolbar-bg: rgba(25, 28, 32, 0.75);
	--panel-bg: rgba(35, 38, 43, 0.9);
	--text-color: #e0e0e0;
	--highlight-color: #2a9fd6;
	--border-color: #444;
}

body {
	margin: 0;
	background: #111;
	overflow: hidden;
	user-select: none;
	-webkit-user-select: none;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
	color: var(--text-color);
}

canvas#map {
	display: block;
	cursor: grab;
}

canvas#map:active {
	cursor: grabbing;
}

#versionDisplay {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 5px);
	left: 10px;
	color: rgba(255, 255, 255, 0.4);
	font-size: 11px;
	user-select: none;
	z-index: 5;
}

#centerTile {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 5px);
	left: 50%;
	transform: translateX(-50%);
	background: rgba(0, 0, 0, 0.5);
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 13px;
	user-select: none;
	z-index: 5;
}

#minimapContainer {
	position: absolute;
	top: 10px;
	right: 10px;
	z-index: 900;
	width: 352px;
	background-color: var(--panel-bg);
	border: 1px solid var(--border-color);
	border-radius: 6px;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	display: none;
	/* Controlled by JS */
}

#minimapContainer.visible {
	display: block;
}

#minimapCanvas {
	width: 350px;
	height: 300px;
	display: block;
	border-radius: 0 0 6px 6px;
}

/* --- NEW BOTTOM TOOLBAR --- */
#bottomToolbar {
	position: fixed;
	bottom: 0;
	left: 0;
	width: 100%;
	height: var(--toolbar-height);
	background: var(--toolbar-bg);
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
	border-top: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	box-sizing: border-box;
	z-index: 1000;
}

.toolbar-group {
	display: flex;
	align-items: center;
	gap: 5px;
}

.toolbar-group.center {
	flex-grow: 1;
	justify-content: center;
	min-width: 200px;
	padding: 0 10px;
}

#bottomToolbar button {
	background: none;
	border: none;
	color: var(--text-color);
	font-size: 24px;
	padding: 8px;
	border-radius: 8px;
	cursor: pointer;
	transition: background-color 0.2s;
	line-height: 1;
}

#bottomToolbar button:hover {
	background-color: rgba(255, 255, 255, 0.1);
}

#bottomToolbar button.active {
	background-color: var(--highlight-color);
	color: white;
}

#bottomToolbar #zoomLevel {
	font-size: 14px;
	min-width: 90px;
	text-align: center;
	user-select: none;
}

#zoomSlider {
	flex-grow: 1;
	-webkit-appearance: none;
	appearance: none;
	width: 100%;
	height: 5px;
	background: rgba(255, 255, 255, 0.2);
	border-radius: 5px;
	outline: none;
	margin: 0 10px;
}

#zoomSlider::-webkit-slider-thumb {
	-webkit-appearance: none;
	appearance: none;
	width: 18px;
	height: 18px;
	background: #f1f1f1;
	border-radius: 50%;
	cursor: pointer;
}

#zoomSlider::-moz-range-thumb {
	width: 18px;
	height: 18px;
	background: #f1f1f1;
	border-radius: 50%;
	cursor: pointer;
	border: none;
}

/* --- TOOLBAR PANELS --- */
.toolbar-panel {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 10px);
	background: var(--panel-bg);
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
	border: 1px solid var(--border-color);
	border-radius: 8px;
	box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
	padding: 15px;
	z-index: 999;
	display: none;
	/* Toggled by JS */
	opacity: 0;
	transform: translateY(10px);
	transition: opacity 0.2s ease-out, transform 0.2s ease-out;
	width: 320px;
	box-sizing: border-box;
}

.toolbar-panel.open {
	display: block;
	opacity: 1;
	transform: translateY(0);
}

.toolbar-panel h4 {
	margin: 0 0 10px 0;
	font-size: 13px;
	color: #aaa;
	text-transform: uppercase;
	font-weight: 600;
	border-bottom: 1px solid var(--border-color);
	padding-bottom: 8px;
}

.panel-section {
	margin-bottom: 15px;
}

.panel-section:last-child {
	margin-bottom: 0;
}

.bookmarks-list {
	max-height: 250px;
	overflow-y: auto;
	margin-right: -5px;
	padding-right: 5px;
}

.bookmark-item {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 8px 5px;
	font-size: 14px;
	border-bottom: 1px solid #3a3a3a;
}

.bookmark-item:last-child {
	border-bottom: none;
}

.bookmark-item>span {
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	flex-grow: 1;
	padding-right: 10px;
}

.bookmark-item .controls button {
	padding: 2px 6px;
	font-size: 12px;
	margin-left: 5px;
	cursor: pointer;
}

.bookmark-item .unpin-btn {
	color: #fdd;
	background: #5a3838;
}

#pinnedBookmarksPanel {
	left: 10px;
}

#navPanel {
	left: 65px;
}

/* Navigation Panel (Go To & Available Landmarks) */
#navPanel .tab-buttons {
	display: flex;
	margin-bottom: 15px;
	border-radius: 6px;
	overflow: hidden;
	border: 1px solid var(--border-color);
}

#navPanel .tab-button {
	flex: 1;
	padding: 8px;
	background: rgba(0, 0, 0, 0.2);
	border: none;
	color: var(--text-color);
	cursor: pointer;
	font-size: 14px;
}

#navPanel .tab-button.active {
	background: var(--highlight-color);
}

#navPanel .tab-content {
	display: none;
}

#navPanel .tab-content.active {
	display: block;
}

#navPanel #goToContent div {
	display: flex;
	gap: 10px;
	align-items: center;
}

#navPanel input[type="number"] {
	width: 60px;
	padding: 5px;
}

#navPanel button {
	padding: 6px 12px;
}

/* Settings Panel */
#settingsPanel {
	right: 10px;
}

#settingsPanel label {
	font-size: 14px;
	user-select: none;
	vertical-align: middle;
}

#settingsPanel>.panel-section>div {
	margin-bottom: 8px;
}

#settingsPanel .info-buttons {
	display: flex;
	gap: 10px;
	margin-top: 10px;
}

#settingsPanel .info-buttons button {
	flex: 1;
	cursor: pointer;
}

/* Zoom Presets Panel */
#zoomPresetsPanel {
	right: 65px;
	width: 120px;
	padding: 5px;
}

#zoomPresetsPanel .preset-list {
	display: flex;
	flex-direction: column;
	gap: 4px;
}

#zoomPresetsPanel button {
	width: 100%;
	text-align: center;
	padding: 8px;
	font-size: 14px;
	cursor: pointer;
}

/* --- MODAL STYLES --- */
.modal-overlay {
	display: none;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(0, 0, 0, 0.7);
	z-index: 1001;
}

.modal {
	display: none;
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	width: 90%;
	max-width: 500px;
	background: #2c2c2c;
	color: #eee;
	border-radius: 8px;
	z-index: 1002;
	box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
}

.modal-header {
	padding: 15px;
	border-bottom: 1px solid #444;
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.modal-header h3 {
	margin: 0;
}

.modal-header .close-btn {
	background: none;
	border: none;
	color: #ccc;
	font-size: 24px;
	cursor: pointer;
}

.modal-body {
	padding: 15px;
	max-height: 60vh;
	overflow-y: auto;
}

.modal-body ul {
	padding-left: 20px;
	margin: 0;
}

.modal-body li {
	margin-bottom: 8px;
}

/* NEW: Styles for collapsible changelog */
.modal-body details {
    border-bottom: 1px solid #4a4a4a;
    margin-bottom: 5px;
}
.modal-body details:last-of-type {
    border-bottom: none;
}
.modal-body summary {
    cursor: pointer;
    list-style: none; /* Remove default marker */
    padding: 10px 0;
    font-weight: bold;
    font-size: 1.1em;
    position: relative;
}
.modal-body summary::-webkit-details-marker {
    display: none; /* Hide for Safari */
}
.modal-body summary:before {
    content: '▶';
    position: absolute;
    left: -15px;
    font-size: 0.8em;
    transition: transform 0.2s;
    transform: rotate(0deg);
}
.modal-body details[open] > summary:before {
    transform: rotate(90deg);
}
.modal-body details > :not(summary) {
    padding-bottom: 10px;
    padding-left: 5px;
}


.modal-footer {
	padding: 10px 15px;
	border-top: 1px solid #444;
	background: #333;
	border-radius: 0 0 8px 8px;
}

.modal-footer label {
	user-select: none;
	font-size: 14px;
}

/* --- RESPONSIVE STYLES --- */
@media (max-width: 768px) {
	.toolbar-group.center {
		padding: 0 5px;
	}

	.toolbar-panel {
		width: calc(100vw - 20px);
		max-width: 400px;
	}

	#pinnedBookmarksPanel,
	#navPanel,
	#settingsPanel,
	#zoomPresetsPanel {
		left: 10px;
		right: 10px;
		width: auto;
	}
}

@media (max-width: 480px) {
	:root {
		--toolbar-height: 50px;
	}

	#bottomToolbar {
		padding: 0 5px;
	}

	.toolbar-group {
		gap: 0;
	}

	.toolbar-group.center {
		min-width: 0;
		flex: 1;
	}

	#bottomToolbar button {
		font-size: 20px;
		padding: 6px;
	}

	#zoomLevel {
		display: none;
	}

	#statsPanel,
	#centerTile,
	#versionDisplay {
		display: none;
	}
}

</style>
</head>
<body>
  <!-- TOP UI ELEMENTS -->
  <div id="statsPanel">
    <div id="statsFPS">FPS: –</div>
    <div id="statsTiles">Tiles: –</div>
  </div>

  <div id="minimapContainer">
      <canvas id="minimapCanvas"></canvas>
  </div>
  
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>
  
  <!-- MAIN CANVAS -->
  <canvas id="map"></canvas>

  <!-- NEW BOTTOM TOOLBAR & PANELS -->
  <div id="bottomToolbar">
    <div class="toolbar-group left">
      <button id="pinnedBookmarksToggleBtn" title="Pinned Landmarks">📌</button>
      <button id="navPanelToggleBtn" title="Navigation">🧭</button>
    </div>
    
    <div class="toolbar-group center">
      <button id="zoomDecBtn" title="Zoom Out">-</button>
      <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
      <button id="zoomIncBtn" title="Zoom In">+</button>
      <div id="zoomLevel">Zoom: 100%</div>
    </div>
    
    <div class="toolbar-group right">
      <button id="zoomPresetsToggleBtn" title="Zoom Presets">🎯</button>
      <button id="minimapToggleBtn" title="Toggle Minimap">🗺️</button>
      <button id="settingsToggleBtn" title="Settings">⚙️</button>
    </div>
  </div>

  <div id="pinnedBookmarksPanel" class="toolbar-panel">
      <h4>Pinned Landmarks</h4>
      <div id="pinnedBookmarksList" class="bookmarks-list"><!-- Populated by JS --></div>
  </div>

  <!-- Navigation Panel -->
  <div id="navPanel" class="toolbar-panel">
      <div class="tab-buttons">
          <button class="tab-button active" data-tab="goToContent">Go To</button>
          <button class="tab-button" data-tab="landmarksContent">Landmarks</button>
      </div>
      <div id="goToContent" class="tab-content active">
          <h4>Go To Coordinates</h4>
          <div>
            X: <input id="inpX" type="number" min="0" max="1199" value="0">
            Y: <input id="inpY" type="number" min="0" max="1199" value="0">
            <button id="btnGo">Go</button>
        </div>
      </div>
      <div id="landmarksContent" class="tab-content">
          <h4>Available Landmarks</h4>
          <div id="addBookmarksList" class="bookmarks-list"><!-- Populated by JS --></div>
      </div>
  </div>

  <!-- Settings Panel -->
  <div id="settingsPanel" class="toolbar-panel">
    <div class="panel-section">
      <h4>Display</h4>
      <div><input type="checkbox" id="gridlinesToggle"><label for="gridlinesToggle"> Show Gridlines</label></div>
      <div><input type="checkbox" id="coordsToggle"><label for="coordsToggle"> Show Coords >80%</label></div>
      <div><input type="checkbox" id="allianceRssToggle"><label for="allianceRssToggle"> Show Alliance RSS</label></div>
      <div><input type="checkbox" id="allianceRssAlwaysVisibleToggle"><label for="allianceRssAlwaysVisibleToggle"> Always Show RSS</label></div>
    </div>
    <div class="panel-section">
      <h4>Performance</h4>
      <label for="tileDetailSelect">Merge tiles at zoom:</label>
      <select id="tileDetailSelect">
        <option value="19">20% (Ultra)</option>
        <option value="39">40% (Super)</option>
        <option value="49">50% (High)</option>
        <option value="59">60% (Medium)</option>
        <option value="69">70% (Low)</option>
        <option value="79">80% (Very Low)</option>
      </select>
    </div>
    <div class="panel-section info-buttons">
        <button id="infoBtn">Controls</button>
        <button id="patchNotesBtn">Patch Notes</button>
    </div>
  </div>

  <!-- Zoom Presets Panel -->
  <div id="zoomPresetsPanel" class="toolbar-panel">
      <div id="zoomPresetsList" class="preset-list">
        <!-- Dynamically populated -->
      </div>
  </div>

  <!-- MODALS (unchanged structure, but triggered from new buttons) -->
  <div id="modalOverlay" class="modal-overlay"></div>
  <div id="patchNotesModal" class="modal">
    <div class="modal-header"><h3>What's New?!</h3><button id="closePatchNotesBtn" class="close-btn">×</button></div>
    <div class="modal-body" id="patchNotesBody"></div>
    <div class="modal-footer"><input type="checkbox" id="hidePatchNotesCheckbox"><label for="hidePatchNotesCheckbox"> Do not show this again.</label></div>
  </div>
  <div id="controlsModal" class="modal">
      <div class="modal-header"><h3>Controls</h3><button id="closeControlsBtn" class="close-btn">×</button></div>
      <div class="modal-body">
          <ul>
            <li><strong>Pan</strong>: Drag with mouse / One-finger drag on touch</li>
            <li><strong>Zoom</strong>: Mouse wheel, +/- buttons, or the slider</li>
            <li><strong>Pinch-to-Zoom</strong>: Use two fingers on touch devices</li>
            <li><strong>Quick Zoom</strong>: Double-click to zoom in</li>
            <li><strong>Keyboard Pan</strong>: Use Arrow Keys</li>
            <li><strong>Select</strong>: Click or tap on any tile</li>
          </ul>
      </div>
  </div>

  <script>
    // Unchanged config and state objects...
    const KingshotPlanner = {
      // --- TWEAKABLE SETTINGS ---
      config: {
        CURRENT_VERSION: '6.1.1.0',
        N: 1200,
        tileW: 10,
        tileH: 10,
        strokeW: 0.3,
        borderColor: '#000',
        textColor: '#fff',
        maxPct: 250,
        selectionColor: '#ff0',
        pingColor: '#fff',
        pingDuration: 500,
        baseScale: 5,
        biomeColors: {
          fertile: 'rgb(109, 159, 62)',
          plains: 'rgb(158, 180, 103)',
          badlands: 'rgb(191, 208, 152)'
        },
        biomeRegions: {
          fertile: { x1: 480, y1: 480, x2: 719, y2: 719 },
          plains: { x1: 320, y1: 320, x2: 879, y2: 879 },
          badlands: { x1: 0, y1: 0, x2: 1199, y2: 1199 }
        },
        ALLIANCE_RSS_STYLES: {
          wood: { displayName: 'Wood', fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
          food: { displayName: 'Food', fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
          stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
          iron: { displayName: 'Iron', fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
        },
        minimap: {
          width: 350,
          height: 300,
          padding: 5,
          bgColor: 'rgba(40,40,40,0.8)',
          viewportFillColor: 'rgba(255, 255, 255, 0.2)',
          viewportBorderColor: 'rgba(255, 255, 255, 0.85)',
          kingCastleColor: 'rgba(255,215,0,0.9)',
          fortressColor: 'rgba(178,34,34,1)',
          sanctuaryColor: 'rgba(65,105,225,1)',
          zoomFactorMin: 1.0, 
          zoomFactorMax: 12.0,
          mainMapZoomThresholdForMinimapZoom: 0.03
        }
      },
      state: {
        baseMap: { unoccupiableTiles: [], defaultBuildings: [] },
        patchNotes: '',
        allBuildings: [],
        buildingMap: new Map(),
        chunkLevels: [],
        userBuildings: [],
        cam: { x: 0, y: 0, scale: 1 },
        lastFrame: 0,
        tileCount: 0,
        lastFPS: 0,
        lastTiles: 0,
        selection: null,
        minFitScale: 0.1,
        isInitialLoad: true,
        touchStartTime: 0,
        dragging: false,
        lastX: 0,
        lastY: 0,
        clickStartX: 0,
        clickStartY: 0,
        touchMode: null,
        startDist: 0,
        startScale: 1,
        pinchCenter: null,
        startCamX: 0,
        startCamY: 0,
        statsUpdateTime: 0,
        currentTileDetailThreshold: 50,
        isMinimapDragging: false,
        minimapClickStartPos: { x: 0, y: 0 },
        minimapCam: { x: 0, y: 0, scale: 0.1 },
        animationId: null,
        pinnedBookmarks: [],
        openPanel: null,
      },
      dom: {}, // Will be populated in init()

      // --- CORE INITIALIZATION ---
      init() {
        // --- DOM REFERENCES (Updated for new UI) ---
        this.dom = {
          canvas: document.getElementById('map'),
          ctx: null,
          inpX: document.getElementById('inpX'),
          inpY: document.getElementById('inpY'),
          btnGo: document.getElementById('btnGo'),
          zoomLevelEl: document.getElementById('zoomLevel'),
          zoomDecBtn: document.getElementById('zoomDecBtn'),
          zoomIncBtn: document.getElementById('zoomIncBtn'),
          zoomSlider: document.getElementById('zoomSlider'),
          zoomPresetsToggleBtn: document.getElementById('zoomPresetsToggleBtn'),
          zoomPresetsPanel: document.getElementById('zoomPresetsPanel'),
          zoomPresetsList: document.getElementById('zoomPresetsList'),
          centerTileEl: document.getElementById('centerTile'),
          statsPanel: document.getElementById('statsPanel'),
          statsFPSEl: document.getElementById('statsFPS'),
          statsTilesEl: document.getElementById('statsTiles'),
          coordsToggle: document.getElementById('coordsToggle'),
          versionDisplay: document.getElementById('versionDisplay'),
          modalOverlay: document.getElementById('modalOverlay'),
          patchNotesBtn: document.getElementById('patchNotesBtn'),
          patchNotesModal: document.getElementById('patchNotesModal'),
          patchNotesBody: document.getElementById('patchNotesBody'),
          closePatchNotesBtn: document.getElementById('closePatchNotesBtn'),
          hidePatchNotesCheckbox: document.getElementById('hidePatchNotesCheckbox'),
          infoBtn: document.getElementById('infoBtn'),
          controlsModal: document.getElementById('controlsModal'),
          closeControlsBtn: document.getElementById('closeControlsBtn'),
          tileDetailSelect: document.getElementById('tileDetailSelect'),
          gridlinesToggle: document.getElementById('gridlinesToggle'),
          allianceRssToggle: document.getElementById('allianceRssToggle'),
          allianceRssAlwaysVisibleToggle: document.getElementById('allianceRssAlwaysVisibleToggle'),
          settingsToggleBtn: document.getElementById('settingsToggleBtn'),
          settingsPanel: document.getElementById('settingsPanel'),
          minimapContainer: document.getElementById('minimapContainer'),
          minimapToggleBtn: document.getElementById('minimapToggleBtn'),
          minimapCanvas: document.getElementById('minimapCanvas'),
          pinnedBookmarksToggleBtn: document.getElementById('pinnedBookmarksToggleBtn'),
          pinnedBookmarksPanel: document.getElementById('pinnedBookmarksPanel'),
          pinnedBookmarksList: document.getElementById('pinnedBookmarksList'),
          navPanelToggleBtn: document.getElementById('navPanelToggleBtn'),
          navPanel: document.getElementById('navPanel'),
          addBookmarksList: document.getElementById('addBookmarksList'),
        };

        this.dom.ctx = this.dom.canvas.getContext('2d');

        if (this.dom.minimapCanvas) {
          const dpr = window.devicePixelRatio || 1;
          this.dom.minimapCanvas.width = this.config.minimap.width * dpr;
          this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
          this.dom.minimapCtx = this.dom.minimapCanvas.getContext('2d');
        }

        this.state.lastFrame = performance.now();
        Promise.all([
          fetch('baseMap.json').then(r => r.ok ? r.json() : { unoccupiableTiles: [], defaultBuildings: [] }),
          fetch('CHANGELOG.md').then(r => r.ok ? r.text() : '')
        ])
        .then(([baseMapData, changelogText]) => {
          Object.assign(this.state.baseMap, baseMapData);
          this.state.patchNotes = changelogText;
          this.preProcessBuildings();
          this.preCalculateChunks();
          this.initializeUI();
          this.resize();
          requestAnimationFrame(this.mainLoop.bind(this));
        })
        .catch(e => console.error("Error during initialization:", e));
      },

      initializeUI() {
        // --- PANEL TOGGLING LOGIC ---
        const panelMap = {
            'settings': { btn: this.dom.settingsToggleBtn, panel: this.dom.settingsPanel },
            'nav': { btn: this.dom.navPanelToggleBtn, panel: this.dom.navPanel },
            'zoomPresets': { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel },
            'pinnedBookmarks': { btn: this.dom.pinnedBookmarksToggleBtn, panel: this.dom.pinnedBookmarksPanel }
        };
        
        const togglePanel = (panelName) => {
            if (this.state.openPanel === panelName) { // Close currently open panel
                panelMap[panelName].panel.classList.remove('open');
                panelMap[panelName].btn.classList.remove('active');
                this.state.openPanel = null;
            } else { // Open a new panel
                // Close any other open panel first
                if (this.state.openPanel && panelMap[this.state.openPanel]) {
                    panelMap[this.state.openPanel].panel.classList.remove('open');
                    panelMap[this.state.openPanel].btn.classList.remove('active');
                }
                // Open the new one
                panelMap[panelName].panel.classList.add('open');
                panelMap[panelName].btn.classList.add('active');
                this.state.openPanel = panelName;
            }
        };

        // Close panels when clicking outside
        document.addEventListener('click', (e) => {
            if (!this.state.openPanel) return;
            const current = panelMap[this.state.openPanel];
            if (!current.panel.contains(e.target) && !current.btn.contains(e.target)) { togglePanel(this.state.openPanel); }
        });

        // Attach toggle events
        Object.keys(panelMap).forEach(key => 
            panelMap[key].btn.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                togglePanel(key); 
          }));

        // Nav Panel Tab logic
        this.dom.navPanel.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const tabId = e.target.dataset.tab;
                this.dom.navPanel.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                this.dom.navPanel.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                e.target.classList.add('active');
                document.getElementById(tabId).classList.add('active');
            });
        });
        
        // Modals
        if (this.dom.infoBtn) this.dom.infoBtn.addEventListener('click', this.showControlsModal.bind(this));
        if (this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
        [this.dom.closeControlsBtn, this.dom.closePatchNotesBtn, this.dom.modalOverlay].forEach(el => {
            if (el) el.addEventListener('click', () => { this.hidePatchNotes(); this.hideControlsModal(); });
        });
        const lastSeenVersion = localStorage.getItem('lastSeenVersion');
        if (lastSeenVersion !== this.config.CURRENT_VERSION) { this.showPatchNotes(); }
        
        // LocalStorage Settings
        const settingsToPersist = {
            'mapTileDetail': { el: this.dom.tileDetailSelect, default: '49', prop: 'value' },
            'mapAlwaysShowRss': { el: this.dom.allianceRssAlwaysVisibleToggle, default: 'false', prop: 'checked' },
            'mapShowGridlines': { el: this.dom.gridlinesToggle, default: 'true', prop: 'checked' },
            'mapShowAllianceRss': { el: this.dom.allianceRssToggle, default: 'true', prop: 'checked' },
            'mapShowCoords': { el: this.dom.coordsToggle, default: 'true', prop: 'checked' },
        };
        Object.entries(settingsToPersist).forEach(([key, conf]) => {
            if (conf.el) {
                const saved = localStorage.getItem(key) ?? conf.default;
                conf.el[conf.prop] = conf.prop === 'checked' ? (saved === 'true') : saved;
                conf.el.addEventListener('change', () => {
                    localStorage.setItem(key, String(conf.el[conf.prop]));
                    if(key === 'mapTileDetail') this.state.currentTileDetailThreshold = parseInt(conf.el.value, 10);
                });
                if(key === 'mapTileDetail') this.state.currentTileDetailThreshold = parseInt(conf.el.value, 10);
            }
        });
        
        // Bookmarks & Version Display
        this.loadPinnedBookmarks();
        this.renderAllBookmarkUI();
        if (this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
        
        // Go To
        if (this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
        if (this.dom.inpX && this.dom.inpY) [this.dom.inpX, this.dom.inpY].forEach(i => i.addEventListener('keydown', e => { if (e.key === 'Enter') this.doSearch(); }));
        
        // Zoom Controls
        if (this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-5));
        if (this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+5));
        if (this.dom.zoomSlider) this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));

        // Zoom Presets
        this.renderZoomPresets();

        // Minimap
        if (this.dom.minimapToggleBtn && this.dom.minimapContainer) {
          this.dom.minimapToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.dom.minimapContainer.classList.toggle('visible');
            this.dom.minimapToggleBtn.classList.toggle('active', this.dom.minimapContainer.classList.contains('visible'));
          });
          // Set minimap initial state based on screen size
          const isDesktop = window.innerWidth > 768;
          this.dom.minimapContainer.classList.toggle('visible', isDesktop);
          this.dom.minimapToggleBtn.classList.toggle('active', isDesktop);
        }
        
        // Global Event Listeners
        window.addEventListener('resize', this.resize.bind(this));
        window.addEventListener('mousemove', this.handleMouseMove.bind(this));
        window.addEventListener('mouseup', () => { this.state.dragging = false; });
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
        this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
        this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
        this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
        this.dom.canvas.addEventListener('contextmenu', e => e.preventDefault());
        this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
        this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        if (this.dom.minimapCanvas) {
          this.dom.minimapCanvas.addEventListener('mousedown', this.handleMinimapMouseDown.bind(this));
          this.dom.minimapCanvas.addEventListener('mousemove', this.handleMinimapMouseMove.bind(this));
          this.dom.minimapCanvas.addEventListener('mouseleave', this.handleMinimapMouseUp.bind(this));
          window.addEventListener('mouseup', this.handleMinimapMouseUp.bind(this));
        }
      },

      renderZoomPresets() {
        if (!this.dom.zoomPresetsList) return;
        this.dom.zoomPresetsList.innerHTML = '';
        ['Fit', '5%', '10%', '20%', '40%', '60%', '80%', '100%'].forEach(p => {
            const btn = document.createElement('button'); btn.textContent = p;
            btn.onclick = () => {
                if (p === 'Fit') { this.zoomToFit(); } 
                else {
                    const zoomVal = parseInt(p, 10);
                    const targetScale = (zoomVal / 100) * this.config.baseScale;
                    this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 200);
                }
                if (this.state.openPanel) {
                    const current = { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel };
                    current.panel.classList.remove('open'); 
                    current.btn.classList.remove('active');
                    this.state.openPanel = null;
                }
            };
            this.dom.zoomPresetsList.appendChild(btn);
        });
      },

      // --- BOOKMARK LOGIC (Updated to target new elements) ---
      loadPinnedBookmarks() { 
        if (localStorage.getItem('pinnedBookmarks')) { 
            try { 
                this.state.pinnedBookmarks = JSON.parse(localStorage.getItem('pinnedBookmarks')) || []; 
            } 
            catch(e) { 
                this.state.pinnedBookmarks = []; 
            } 
        } 
      },

      savePinnedBookmarks() {
        localStorage.setItem('pinnedBookmarks', JSON.stringify(this.state.pinnedBookmarks));
      },

      pinBookmark(bookmark) {
        if (!this.state.pinnedBookmarks.some(p => p.x === bookmark.x && p.y === bookmark.y)) {
          this.state.pinnedBookmarks.push({ 
            x: bookmark.x, 
            y: bookmark.y, 
            displayName: bookmark.displayName 
          });
          this.savePinnedBookmarks(); 
          this.renderAllBookmarkUI();
        }
      },

      unpinBookmark(x, y) {
        this.state.pinnedBookmarks = this.state.pinnedBookmarks.filter(p => !(p.x === x && p.y === y));
        this.savePinnedBookmarks(); 
        this.renderAllBookmarkUI();
      },

      renderAllBookmarkUI() {
        this.renderPinnedBookmarks(); 
        this.renderAddBookmarksList();
      },

      createBookmarkItem(b, isPinned) {
          const item = document.createElement('div');
          item.className = 'bookmark-item';
          const nameSpan = document.createElement('span');
          nameSpan.textContent = b.displayName;
          
          const controlsDiv = document.createElement('div');
          controlsDiv.className = 'controls';
          const goBtn = document.createElement('button');
          goBtn.textContent = 'Go';
          goBtn.onclick = () => this.goToBookmark(b.x, b.y);

          if (isPinned) {
              const unpinBtn = document.createElement('button');
              unpinBtn.textContent = 'Unpin';
              unpinBtn.className = 'unpin-btn';
              unpinBtn.onclick = () => this.unpinBookmark(b.x, b.y);
              controlsDiv.append(goBtn, unpinBtn);
          } else {
              const pinBtn = document.createElement('button');
              pinBtn.textContent = 'Pin';
              pinBtn.onclick = () => this.pinBookmark(b);
              controlsDiv.append(goBtn, pinBtn);
          }
          item.append(nameSpan, controlsDiv);
          return item;
      },
      renderPinnedBookmarks() {
        if (!this.dom.pinnedBookmarksList) return;
        this.dom.pinnedBookmarksList.innerHTML = '';
        this.state.pinnedBookmarks.forEach(p => this.dom.pinnedBookmarksList.appendChild(this.createBookmarkItem(p, true)));
      },

      renderAddBookmarksList() {
        if (!this.dom.addBookmarksList || !this.state.baseMap.defaultBuildings) return;
          this.dom.addBookmarksList.innerHTML = '';
          const allLandmarks = this.state.baseMap.defaultBuildings.filter(b => b.displayName && (b.displayName.includes("King's Castle") || b.displayName.includes("Fortress") || b.displayName.includes("Sanctuary")));
          const unpinned = allLandmarks.filter(landmark => !this.state.pinnedBookmarks.some(p => p.x === landmark.x && p.y === landmark.y));
            
          const getSortOrder = (name) => {
            if (name.includes("King's Castle")) return 0;
            if (name.includes("Fortress")) return 1;
            if (name.includes("Sanctuary")) return 2;
            return 3;
          };
          unpinned.sort((a, b) => {
            const orderA = getSortOrder(a.displayName);
            const orderB = getSortOrder(b.displayName);
            if (orderA !== orderB) return orderA - orderB;
            return a.displayName.localeCompare(b.displayName, undefined, { numeric: true });
          });
          unpinned.forEach(b => this.dom.addBookmarksList.appendChild(this.createBookmarkItem(b, false)));
      },
        goToBookmark(x, y) {
            if (this.state.openPanel) {
                const panelMap = { 'nav': this.dom.navPanel, 'pinnedBookmarks': this.dom.pinnedBookmarksPanel };
                const btnMap = { 'nav': this.dom.navPanelToggleBtn, 'pinnedBookmarks': this.dom.pinnedBookmarksToggleBtn };
                if (panelMap[this.state.openPanel]) {
                    panelMap[this.state.openPanel].classList.remove('open');
                    btnMap[this.state.openPanel].classList.remove('active');
                    this.state.openPanel = null;
                }
            }
            if (x >= 0 && y >= 0) {
                this.state.selection = this.getBuildingAt(x, y) || { x, y };
                if (this.state.selection) this.state.selection.pingStart = performance.now();
                const targetScale = this.config.baseScale;
                const [screenX, screenY] = this.worldToScreen(x, y);
                this.animatePanZoom(targetScale, this.dom.canvas.width / 2 - screenX * targetScale, this.dom.canvas.height / 2 - screenY * targetScale);
            }
        },

      showPatchNotes() {
        if (!this.dom.modalOverlay || !this.dom.patchNotesModal) return;

        // Render the raw markdown
        if (typeof marked !== 'undefined') { marked.setOptions({ gfm: true, breaks: true, sanitize: false }); } 
        let text = this.state.patchNotes || '';
        const idx = text.indexOf('## ['); 
        if (idx !== -1) { text = text.substring(idx); } 
        this.dom.patchNotesBody.innerHTML = marked.parse(text || 'No changelog available.');
        
        // Post-process the rendered HTML to create collapsible sections
        const headers = this.dom.patchNotesBody.querySelectorAll('h2');
        headers.forEach((header, index) => {
            const details = document.createElement('details');
            if (index === 0) {
                details.open = true; // Open the first (latest) version by default
            }

            const summary = document.createElement('summary');
            summary.innerHTML = header.innerHTML;
            details.appendChild(summary);

            let sibling = header.nextElementSibling;
            while(sibling && sibling.tagName !== 'H2') {
                const nextSibling = sibling.nextElementSibling;
                details.appendChild(sibling); // Move the sibling into the details element
                sibling = nextSibling;
            }
            
            header.parentNode.replaceChild(details, header);
        });

        this.dom.modalOverlay.style.display = 'block'; 
        this.dom.patchNotesModal.style.display = 'block'; 
      },

      hidePatchNotes() { 
        if (this.dom.modalOverlay && this.dom.patchNotesModal) { 
            if (this.dom.hidePatchNotesCheckbox && this.dom.hidePatchNotesCheckbox.checked) { 
                localStorage.setItem('lastSeenVersion', this.config.CURRENT_VERSION); 
            } 
            this.dom.modalOverlay.style.display = 'none'; 
            this.dom.patchNotesModal.style.display = 'none'; 
        } 
      },

      showControlsModal() { 
        if (this.dom.modalOverlay && this.dom.controlsModal) { 
            this.dom.modalOverlay.style.display = 'block'; 
            this.dom.controlsModal.style.display = 'block'; 
        } 
      },

      hideControlsModal() { 
        if (this.dom.modalOverlay && this.dom.controlsModal) { 
            this.dom.modalOverlay.style.display = 'none'; 
            this.dom.controlsModal.style.display = 'none'; 
        } 
      },

      preProcessBuildings() {
        let buildings = [...(this.state.baseMap.defaultBuildings || []), ...(this.state.userBuildings || [])];
        if (this.state.baseMap.allianceRssBuildings) {
          const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
            const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
            return { x: rss.x, y: rss.y, w: 2, h: 2, displayName: style.displayName, fillColor: style.fillColor, borderColor: style.borderColor, displayCoordinates: false, isRss: true };
          });
          buildings = buildings.concat(formattedRssBuildings);
        }
        this.state.allBuildings = buildings;
        this.state.buildingMap.clear();
        for (const b of this.state.allBuildings) {
          if (typeof b.w === 'number' && typeof b.h === 'number') {
            for (let dx = 0; dx < b.w; dx++) {
              for (let dy = 0; dy < b.h; dy++) { this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b); }
            }
          }
        }
      },

      preCalculateChunks() {
        const numLevels = 4; this.state.chunkLevels = [];
        for (let level = 0; level < numLevels; level++) {
          const chunkSize = Math.pow(2, level + 1); const levelMap = new Map();
          for (let x = 0; x < this.config.N; x += chunkSize) {
            for (let y = 0; y < this.config.N; y += chunkSize) {
              const biome = this.getBiomeForTile(x, y); levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
            }
          }
          this.state.chunkLevels.push(levelMap);
        }
      },

      worldToScreen(x, y) { 
        return [(x - y) * (this.config.tileW / 2), -(x + y) * (this.config.tileH / 2)]; 
      },

      screenToWorld(sx, sy) {
        const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
        const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
        if (tileW_half === 0 || tileH_half === 0) { return [0, 0]; }
        const lx = (sx - this.state.cam.x) / scale; const ly = (sy - this.state.cam.y) / scale;
        const u = lx / tileW_half; const v = -ly / tileH_half;
        return [Math.round((u + v) / 2), Math.round((v - u) / 2)];
      },

      getBuildingAt(x, y) { 
        return this.state.buildingMap.get(`${x},${y}`) || null; 
      },

      getBiomeForTile(x, y) {
        const { fertile, plains } = this.config.biomeRegions;
        if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
        if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
        return 'badlands';
      },

      getChunkLevelForZoom(pct) {
        if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100;
        const detailThreshold = this.state.currentTileDetailThreshold;
        if (pct > detailThreshold) return -1; if (pct > detailThreshold / 2) return 0;
        if (pct > detailThreshold / 5) return 1; if (pct > detailThreshold / 10) return 2;
        return 3;
      },

      clampCamera() {
        const s = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const canvasW = this.dom.canvas.width; const canvasH = this.dom.canvas.height;
        const N = this.config.N; const tileW = this.config.tileW; const tileH = this.config.tileH;
        const mapScreenW = (N - 1) * tileW * s;
        if (mapScreenW > canvasW) {
            const minCamX = canvasW - mapScreenW / 2; const maxCamX = mapScreenW / 2;
            this.state.cam.x = Math.max(minCamX, Math.min(maxCamX, this.state.cam.x));
        } else { this.state.cam.x = canvasW / 2; }
        const mapScreenH = (N - 1) * tileH * s;
        if (mapScreenH > canvasH) {
            const topOfMapY = mapScreenH; const bottomOfMapY = canvasH;
            this.state.cam.y = Math.max(bottomOfMapY, Math.min(topOfMapY, this.state.cam.y));
        } else {
            this.state.cam.y = canvasH / 2 + mapScreenH / 2;
        }
        if (isNaN(this.state.cam.x)) this.state.cam.x = canvasW / 2;
        if (isNaN(this.state.cam.y)) this.state.cam.y = canvasH / 2;
      },

      changeZoomBy(delta) {
        let currentPct = Math.round((this.state.cam.scale / this.config.baseScale) * 100);
        if (isNaN(currentPct)) { currentPct = Math.round((this.state.minFitScale / this.config.baseScale) * 100); }
        const targetPct = currentPct + delta;
        let targetScale = (targetPct / 100) * this.config.baseScale;
        const minScale = this.state.minFitScale;
        const maxScale = (this.config.maxPct / 100) * this.config.baseScale;
        targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
        if (!isNaN(targetScale)) { this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 150); }
      },

      animateZoom(targetScale, anchorX, anchorY, duration = 150) {
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
        const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const startX = this.state.cam.x; const startY = this.state.cam.y;
        const start = performance.now();
        if (startScale === 0) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
        const wx = (anchorX - startX) / startScale; const wy = (anchorY - startY) / startScale;
        if (isNaN(wx) || isNaN(wy)) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
        const step = (now) => {
          const t = duration === 0 ? 1 : Math.min(1, (now - start) / duration);
          const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          this.state.cam.scale = startScale + (targetScale - startScale) * k;
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
          this.state.cam.x = anchorX - wx * this.state.cam.scale;
          this.state.cam.y = anchorY - wy * this.state.cam.scale;
          this.clampCamera();
          if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
          else { this.state.animationId = null; }
        };
        this.state.animationId = requestAnimationFrame(step);
      },

      animatePanZoom(targetScale, targetX, targetY, duration = 300) {
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
        const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const startX = this.state.cam.x; const startY = this.state.cam.y;
        const start = performance.now();
        const step = (now) => {
          const t = Math.min(1, (now - start) / duration);
          const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          this.state.cam.scale = startScale + (targetScale - startScale) * k;
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
          this.state.cam.x = startX + (targetX - startX) * k;
          this.state.cam.y = startY + (targetY - startY) * k;
          this.clampCamera();
          if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
          else { this.state.animationId = null; }
        };
        this.state.animationId = requestAnimationFrame(step);
      },

      zoomToFit() {
        const targetScale = this.state.minFitScale;
        const targetCamX = this.dom.canvas.width / 2;
        const targetCamY = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * targetScale;
        this.animatePanZoom(targetScale, targetCamX, targetCamY, 200);
      },

      handleMinimapMouseDown(e) { 
        this.state.isMinimapDragging = true; 
        this.state.minimapClickStartPos = { x: e.clientX, y: e.clientY }; 
        this.state.startCamX = this.state.cam.x; 
        this.state.startCamY = this.state.cam.y; 
      },

      handleMinimapMouseMove(e) {
        if (!this.state.isMinimapDragging) return; if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
        const rect = this.dom.minimapCanvas.getBoundingClientRect(); const minimapCam = this.state.minimapCam;
        const clickScreenX = (e.clientX - rect.left); const clickScreenY = (e.clientY - rect.top);
        const lx = (clickScreenX - minimapCam.x) / minimapCam.scale; const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
        const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
        const u = lx / tileW_half; const v = -ly / tileH_half; const world_x = (u + v) / 2; const world_y = (v - u) / 2;
        const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
        this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale; this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
        this.clampCamera();
      },

      handleMinimapMouseUp(e) {
        if (!this.state.isMinimapDragging) return;
        this.state.isMinimapDragging = false;
        
        // Check if the action was a click (not a long drag)
        const dist = Math.hypot(e.clientX - this.state.minimapClickStartPos.x, e.clientY - this.state.minimapClickStartPos.y);
        if (dist < 5) {
          // It's a click, so we calculate the final position and jump there.
          // This avoids the jitter caused by animating a move that already happened.
          const rect = this.dom.minimapCanvas.getBoundingClientRect(); 
          const minimapCam = this.state.minimapCam;
          const clickScreenX = (e.clientX - rect.left); 
          const clickScreenY = (e.clientY - rect.top);
          
          const lx = (clickScreenX - minimapCam.x) / minimapCam.scale; 
          const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
          
          const tileW_half = this.config.tileW / 2; 
          const tileH_half = this.config.tileH / 2;
          const u = lx / tileW_half; 
          const v = -ly / tileH_half; 
          const world_x = (u + v) / 2; 
          const world_y = (v - u) / 2;
          
          const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
          
          // Set camera position directly instead of animating
          this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale; 
          this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
          this.clampCamera();
        }
      },

      handleMouseDown(e) { 
        if (e.button === 0) { this.state.dragging = true; 
          this.state.lastX = e.clientX; 
          this.state.lastY = e.clientY; 
          this.state.clickStartX = e.clientX; 
          this.state.clickStartY = e.clientY; 
        } 
      },

      handleMouseMove(e) { 
        if (!this.state.dragging) return; 
        this.state.cam.x += e.clientX - this.state.lastX; 
        this.state.cam.y += e.clientY - this.state.lastY; 
        this.state.lastX = e.clientX; 
        this.state.lastY = e.clientY; 
        this.clampCamera(); 
      },

      handleCanvasClick(e) {
        const dist = Math.hypot(e.clientX - this.state.clickStartX, e.clientY - this.state.clickStartY);
        if (dist > 5) return; 
        const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
        if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
          const building = this.getBuildingAt(worldX, worldY); this.state.selection = building || { x: worldX, y: worldY };
          if (this.state.selection) this.state.selection.pingStart = performance.now();
          if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
          if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
        }
      },

      handleWheel(e) { 
        e.preventDefault(); 
        const factor = e.deltaY < 0 ? 1.2 : 0.8; 
        let targetScale = this.state.cam.scale * factor; 
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale)); 
        this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
      },

      handleDblClick(e) { 
        e.preventDefault(); 
        const factor = e.button === 2 ? 0.5 : 2.0; 
        let targetScale = this.state.cam.scale * factor; 
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale)); 
        this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
      },

      handleZoomSlider() {
        if (!this.dom.zoomSlider) return; const pct = Number(this.dom.zoomSlider.value);
        let targetScale = (pct / 100) * this.config.baseScale;
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
        this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 0);
      },

      handleKeyDown(e) {
        if (e.target && e.target.tagName === 'INPUT') return;
        switch (e.key) {
          case '+': case '=': this.changeZoomBy(+5); break;
          case '-':           this.changeZoomBy(-5); break;
          case 'ArrowUp':     this.state.cam.y += this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowDown':   this.state.cam.y -= this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowLeft':   this.state.cam.x += this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowRight':  this.state.cam.x -= this.config.tileW * 5; this.clampCamera(); break;
        }
      },

      handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
          this.state.touchMode = 'pan'; const t = e.touches[0]; this.state.lastX = t.clientX; this.state.lastY = t.clientY;
          this.state.clickStartX = t.clientX; this.state.clickStartY = t.clientY; this.state.touchStartTime = performance.now();
        } else if (e.touches.length === 2) {
          this.state.touchMode = 'pinch'; const [a, b] = e.touches;
          this.state.startDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          this.state.startScale = this.state.cam.scale; this.state.pinchCenter = { x: (a.clientX + b.clientX) / 2, y: (a.clientY + b.clientY) / 2 };
          this.state.startCamX = this.state.cam.x; this.state.startCamY = this.state.cam.y;
        }
      },

      handleTouchMove(e) {
        e.preventDefault(); if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
        if (this.state.touchMode === 'pan' && e.touches.length === 1) {
          const t = e.touches[0]; 
          this.state.cam.x += t.clientX - this.state.lastX; 
          this.state.cam.y += t.clientY - this.state.lastY;
          this.state.lastX = t.clientX; this.state.lastY = t.clientY; this.clampCamera();
        } else if (this.state.touchMode === 'pinch' && e.touches.length === 2) {
          const [a, b] = e.touches; const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          if (this.state.startDist === 0) return; let newScale = this.state.startScale * (dist / this.state.startDist);
          this.state.cam.scale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, newScale));
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.startScale;
          const safeStartScale = (this.state.startScale === 0 || isNaN(this.state.startScale)) ? this.state.minFitScale : this.state.startScale;
          const wx = (this.state.pinchCenter.x - this.state.startCamX) / safeStartScale; const wy = (this.state.pinchCenter.y - this.state.startCamY) / safeStartScale;
          if (isNaN(wx) || isNaN(wy)) { this.state.cam.x = this.state.startCamX; this.state.cam.y = this.state.startCamY; } 
          else { this.state.cam.x = this.state.pinchCenter.x - wx * this.state.cam.scale; this.state.cam.y = this.state.pinchCenter.y - wy * this.state.cam.scale; }
          this.clampCamera();
        }
      },

      handleTouchEnd(e) {
        if (this.state.touchMode === 'pan' && e.changedTouches.length === 1) {
          const t = e.changedTouches[0]; const dist = Math.hypot(t.clientX - this.state.clickStartX, t.clientY - this.state.clickStartY);
          const duration = performance.now() - this.state.touchStartTime;
          if (duration < 200 && dist < 10) {
            const [worldX, worldY] = this.screenToWorld(t.clientX, t.clientY);
            if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
              const building = this.getBuildingAt(worldX, worldY); this.state.selection = building || { x: worldX, y: worldY };
              if (this.state.selection) this.state.selection.pingStart = performance.now();
              if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
              if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
            }
          }
        }
        if (e.touches.length < 2) this.state.touchMode = null;
      },

      resize() {
        this.dom.canvas.width = window.innerWidth; this.dom.canvas.height = window.innerHeight;
        if (this.dom.minimapCanvas && this.config.minimap) {
          const dpr = window.devicePixelRatio || 1;
          this.dom.minimapCanvas.width = this.config.minimap.width * dpr; this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
        }
        const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
        const mapTotalHeight = (this.config.N - 1) * this.config.tileH;
        const scaleX = this.dom.canvas.width / mapTotalWidth;
        const scaleY = this.dom.canvas.height / mapTotalHeight;
        this.state.minFitScale = Math.max(0.1, Math.min(scaleX, scaleY) * 0.95);
        if (isNaN(this.state.minFitScale)) { this.state.minFitScale = 0.1; }
        if (this.state.isInitialLoad) {
          this.state.isInitialLoad = false; this.zoomToFit();
        } else {
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) { this.state.cam.scale = this.state.minFitScale; }
          this.clampCamera();
        }
      },

      doSearch() {
        if (!this.dom.inpX || !this.dom.inpY) return;
        this.goToBookmark(+this.dom.inpX.value, +this.dom.inpY.value);
      },

      drawIsometricMinimap(viewportCorners) {
        if (!this.dom.minimapCtx || !this.dom.minimapContainer.classList.contains('visible') || !this.config.minimap) return;
        const mmCtx = this.dom.minimapCtx; const { minimap, N, tileW, tileH, baseScale, maxPct } = this.config;
        const canvasWidth = this.dom.minimapCanvas.width; const canvasHeight = this.dom.minimapCanvas.height;
        mmCtx.save(); mmCtx.setTransform(1, 0, 0, 1, 0, 0); mmCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        mmCtx.fillStyle = minimap.bgColor; mmCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        const worldIsoWidth = N * tileW; const worldIsoHeight = N * tileH;
        const drawableWidth = canvasWidth - (minimap.padding * 2); const drawableHeight = canvasHeight - (minimap.padding * 2);
        const baseMinimapScale = Math.min(drawableWidth / worldIsoWidth, drawableHeight / worldIsoHeight);
        const mainMapCurrentScale = this.state.cam.scale; const mainMapMaxScale = (maxPct / 100) * baseScale;
        const zoomStartThresholdScale = minimap.mainMapZoomThresholdForMinimapZoom * baseScale;
        let zoomFactor; let normalizedZoom = 0;
        if (mainMapCurrentScale <= zoomStartThresholdScale) { zoomFactor = minimap.zoomFactorMin; } 
        else { normalizedZoom = Math.max(0, Math.min(1, (mainMapCurrentScale - zoomStartThresholdScale) / (mainMapMaxScale - zoomStartThresholdScale))); zoomFactor = minimap.zoomFactorMin + (minimap.zoomFactorMax - minimap.zoomFactorMin) * normalizedZoom; }
        const finalMinimapScale = baseMinimapScale * zoomFactor;
        const mapVisualCenterX_iso = 0; const mapVisualCenterY_iso = -((N - 1) * tileH / 2);
        const [mainViewCenterX, mainViewCenterY] = this.screenToWorld(this.dom.canvas.width / 2, this.dom.canvas.height / 2);
        const [viewportCenterX_iso, viewportCenterY_iso] = this.worldToScreen(mainViewCenterX, mainViewCenterY);
        const focalPointX = mapVisualCenterX_iso + (viewportCenterX_iso - mapVisualCenterX_iso) * normalizedZoom; const focalPointY = mapVisualCenterY_iso + (viewportCenterY_iso - mapVisualCenterY_iso) * normalizedZoom;
        const translateX = (canvasWidth / 2) - (focalPointX * finalMinimapScale); const translateY = (canvasHeight / 2) - (focalPointY * finalMinimapScale);
        this.state.minimapCam = { x: translateX, y: translateY, scale: finalMinimapScale };
        mmCtx.setTransform(finalMinimapScale, 0, 0, finalMinimapScale, translateX, translateY);
        const chunksToDraw = this.state.chunkLevels[3];
        chunksToDraw.forEach(chunk => { this.drawChunk(chunk, false, mmCtx); });
        (this.state.baseMap.defaultBuildings || []).forEach(b => {
            let buildingFillStyle = null;
            if (b.displayName === "King's Castle") buildingFillStyle = minimap.kingCastleColor;
            else if (b.displayName.startsWith("Fortress")) buildingFillStyle = minimap.fortressColor;
            else if (b.displayName.startsWith("Sanctuary")) buildingFillStyle = minimap.sanctuaryColor;
            if (buildingFillStyle) { const originalFill = b.fillColor; b.fillColor = buildingFillStyle; this.drawBuildingFootprint(b, null, false, mmCtx); b.fillColor = originalFill; }
        });
        if (viewportCorners) {
            const p1 = this.worldToScreen(viewportCorners.tl.x, viewportCorners.tl.y); const p2 = this.worldToScreen(viewportCorners.tr.x, viewportCorners.tr.y);
            const p3 = this.worldToScreen(viewportCorners.br.x, viewportCorners.br.y); const p4 = this.worldToScreen(viewportCorners.bl.x, viewportCorners.bl.y);
            mmCtx.fillStyle = minimap.viewportFillColor; mmCtx.strokeStyle = minimap.viewportBorderColor;
            mmCtx.lineWidth = 2 / finalMinimapScale; mmCtx.beginPath();
            mmCtx.moveTo(p1[0], p1[1]); mmCtx.lineTo(p2[0], p2[1]); mmCtx.lineTo(p3[0], p3[1]); mmCtx.lineTo(p4[0], p4[1]);
            mmCtx.closePath(); mmCtx.fill(); mmCtx.stroke();
        }
        mmCtx.restore();
      },

      drawTile(x, y, drawBorder = true) {
        this.state.tileCount++; const [sx, sy] = this.worldToScreen(x, y); const { config } = this; const ctx = this.dom.ctx;
        ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy);
        ctx.closePath(); ctx.fillStyle = config.biomeColors[this.getBiomeForTile(x, y)]; ctx.fill();
        if (drawBorder) ctx.stroke(); const building = this.getBuildingAt(x, y);
        if (building && building.hideCoordinates) return;
        const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const pct = Math.round((currentCamScale / config.baseScale) * 100);
        const showCoords = this.dom.coordsToggle ? this.dom.coordsToggle.checked : false;
        const showThreshold = showCoords ? 80 : 200;
        if (pct <= showThreshold) return;
        const text = `${x}, ${y}`; let optimalFontSize = Math.min(config.tileH * 0.8 * 0.5, (config.tileW * 0.8 / (text.length || 1)) * 1.8) * 0.7;
        if ((optimalFontSize * currentCamScale) < 5) return;
        ctx.fillStyle = config.textColor; ctx.font = `${optimalFontSize}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, sx, sy);
      },

      drawChunk(chunk, drawBorder = true, overrideCtx = null) {
        this.state.tileCount++; const ctx = overrideCtx || this.dom.ctx;
        const { x, y, size, biome } = chunk; const { config } = this;
        const currentCamScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
        const inflation = drawBorder || currentCamScale === 0 ? 0 : (1 / currentCamScale);
        const x0 = x; const y0 = y; const w = size; const h = size;
        const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
        const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
        const p_bottom = { x: sbx, y: sby + config.tileH / 2 + inflation }; const p_right = { x: srx + config.tileW / 2 + inflation, y: sry };
        const p_top = { x: stx, y: sty - config.tileH / 2 - inflation }; const p_left = { x: slx - config.tileW / 2 - inflation, y: sly };
        ctx.beginPath(); ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath();
        ctx.fillStyle = config.biomeColors[biome]; ctx.fill(); if (drawBorder) ctx.stroke();
      },

      drawBuildingFootprint(b, highlightStyle = null, drawBorder = true, overrideCtx = null) {
        const { config, state } = this; const ctx = overrideCtx || this.dom.ctx;
        const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
        const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
        const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
        const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
        const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
        const p_bottom = { x: sbx, y: sby + config.tileH / 2 }; const p_right = { x: srx + config.tileW / 2, y: sry };
        const p_top = { x: stx, y: sty - config.tileH / 2 }; const p_left = { x: slx - config.tileW / 2, y: sly };
        ctx.beginPath(); ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath();
        ctx.fillStyle = fill; ctx.fill();
        if(drawBorder) {
            ctx.strokeStyle = border; const currentScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
            ctx.lineWidth = (highlightStyle ? config.strokeW * 2 : config.strokeW) / (overrideCtx ? currentScale : 1); ctx.stroke();
        }
        if (overrideCtx || highlightStyle) return;
        const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
        if (currentCamScale > 0.4 && b.displayName) {
          const availableWidth = (p_right.x - p_left.x) * 0.8; const availableHeight = p_bottom.y - p_top.y;
          if (availableWidth < 10 || availableHeight < 10) return;
          const hasCoords = b.displayCoordinates; const heightFactor = hasCoords ? 0.5 : 1.0;
          const fontSizeBasedOnHeight = (availableHeight * heightFactor) * 0.9;
          ctx.font = `bold 100px sans-serif`; const textMetrics = ctx.measureText(b.displayName);
          const displayNameWidth = textMetrics.width || 1; const fontSizeBasedOnWidth = (availableWidth / displayNameWidth) * 100;
          const optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);
          if (optimalFontSize * currentCamScale < 7) return;
          const centerX = (p_left.x + p_right.x) / 2; const yOffset = hasCoords ? optimalFontSize * -0.45 : 0;
          const centerY = (p_top.y + p_bottom.y) / 2 + yOffset;
          ctx.fillStyle = config.textColor; ctx.font = `bold ${optimalFontSize}px sans-serif`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(b.displayName, centerX, centerY);
          if (b.displayCoordinates) {
            const coordFontSize = optimalFontSize * 0.7; ctx.font = `${coordFontSize}px sans-serif`;
            ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, centerY + optimalFontSize * 0.9);
          }
        }
      },

      mainLoop(now) {
        const { dom, state, config } = this; const ctx = dom.ctx;
        try {
          ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
          const [centerX, centerY] = this.screenToWorld(dom.canvas.width / 2, dom.canvas.height / 2);
          if (dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
          const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
          const pct = Math.round((currentCamScale / config.baseScale) * 100);
          if (dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
          if (dom.zoomSlider) {
              const minScalePct = Math.round((state.minFitScale / config.baseScale) * 100);
              const maxScalePct = Math.round((config.maxPct / 100 * config.baseScale / config.baseScale) * 100);
              dom.zoomSlider.min = minScalePct; dom.zoomSlider.max = maxScalePct;
              if (document.activeElement !== dom.zoomSlider) dom.zoomSlider.value = pct;
          }
          state.tileCount = 0; ctx.save();
          ctx.setTransform(currentCamScale, 0, 0, currentCamScale, state.cam.x, state.cam.y);
          ctx.strokeStyle = config.borderColor; ctx.lineWidth = config.strokeW;
          const [tl_x, tl_y] = this.screenToWorld(0, 0); const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
          const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height); const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
          const viewBounds = {
            minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2, maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
            minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2, maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
          };
          const viewportCorners = { tl: { x: tl_x, y: tl_y }, tr: { x: tr_x, y: tr_y }, bl: { x: bl_x, y: bl_y }, br: { x: br_x, y: br_y } };
          if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
            ctx.restore(); this.drawIsometricMinimap(null); requestAnimationFrame(this.mainLoop.bind(this)); return;
          }
          const chunkLevel = this.getChunkLevelForZoom(pct);
          const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
          const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
          const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;
          if (chunkLevel === -1) {
            const shouldDrawBorders = showGrid && pct > 50; const minSum = Math.floor(viewBounds.minX + viewBounds.minY); const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);
            for (let sum = minSum; sum <= maxSum; sum++) {
              const startXCoord = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY))); const endXCoord = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));
              for (let x = startXCoord; x <= endXCoord; x++) { const y = sum - x; if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue; if (!this.getBuildingAt(x, y)) this.drawTile(x, y, shouldDrawBorders); }
            }
            state.allBuildings.filter(b => (!b.isRss || showRss) && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)).forEach(b => this.drawBuildingFootprint(b, null, shouldDrawBorders));
            ctx.fillStyle = '#444';
            (state.baseMap.unoccupiableTiles || []).forEach(([x, y]) => { if (this.getBuildingAt(x, y)) return; if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return; const [sx, sy] = this.worldToScreen(x, y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.fill(); });
          } else {
            if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
              const chunksToDraw = state.chunkLevels[chunkLevel]; const chunkSize = Math.pow(2, chunkLevel + 1);
              const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize; const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
              const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize; const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
              for (let x = startChunkX; x <= endChunkX; x += chunkSize) { for (let y = startChunkY; y <= endChunkY; y += chunkSize) { const chunk = chunksToDraw.get(`${x},${y}`); if (chunk) this.drawChunk(chunk, false); } }
            }
            
            // Draw all non-RSS buildings (default and user-added) that are in view
            state.allBuildings.filter(b => !b.isRss && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)).forEach(b => this.drawBuildingFootprint(b, null, false));

            // Conditionally draw all RSS buildings that are in view
            if (showRss && alwaysShowRss) {
                // CORRECTED: b.h is used instead of h
                state.allBuildings.filter(b => b.isRss && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)).forEach(b => this.drawBuildingFootprint(b, null, false));
            }
            
            if (chunkLevel < 2) {
              ctx.fillStyle = '#444';
              (state.baseMap.unoccupiableTiles || []).forEach(([x, y]) => { if (this.getBuildingAt(x, y)) return; if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return; const [sx, sy] = this.worldToScreen(x, y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.fill(); });
            }
          }
          if (state.selection) {
            let highlightColor = config.selectionColor;
            if (state.selection.pingStart && now - state.selection.pingStart < config.pingDuration) { if (Math.floor((now - state.selection.pingStart) / 100) % 2 === 0) { highlightColor = config.pingColor; } }
            if (state.selection.w) { this.drawBuildingFootprint(state.selection, highlightColor, true); } 
            else { const [sx, sy] = this.worldToScreen(state.selection.x, state.selection.y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.strokeStyle = highlightColor; ctx.lineWidth = config.strokeW * 1.5; ctx.stroke(); }
          }
          ctx.restore();
          this.drawIsometricMinimap(viewportCorners);
          const dt = now - state.lastFrame; state.lastFrame = now;
          if (dt > 0) { state.lastFPS = Math.round(1000 / dt); }
          state.lastTiles = state.tileCount;
          if (now - state.statsUpdateTime > 500) {
            if (dom.statsFPSEl) dom.statsFPSEl.textContent = `FPS:   ${state.lastFPS}`;
            if (dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
            state.statsUpdateTime = now;
          }
        } catch (error) { console.error("Error in mainLoop:", error); }
        requestAnimationFrame(this.mainLoop.bind(this));
      }

    };
    KingshotPlanner.init();
  </script>
</body>
</html>