<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
<style>
    body {
      margin:0; background:#111; overflow:hidden;
      -webkit-user-select:none; user-select:none;
    }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }

    /* UI Container - MOVED to top-right */
    #searchBox {
      position:absolute; top:10px; right:10px; z-index:10;
      color:#fff; font-family:sans-serif;
      background:rgba(0,0,0,0.6); padding:8px; border-radius:4px;
      text-align: right;
      width: 210px; /* Give it a fixed width for better layout */
    }
    #searchBox input { width:60px; }
    #searchBox button {
      margin:2px 4px 2px 0;
      -webkit-user-select:none; user-select:none;
    }
    
    /* Center Tile Display - MOVED to bottom-center */
    #centerTile {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      color:#fff; font-family:sans-serif;
      font-size:14px;
      -webkit-user-select:none; user-select:none;
      z-index: 10;
    }

    /* Coords Toggle Label Style */
    label.coords-label {
        font-size: 13px;
        vertical-align: middle;
        user-select: none;
    }
    #searchBox > div { margin-top: 4px; text-align: left; }
    #searchBox > hr {
        border: none;
        border-top: 1px solid #444;
        margin: 8px 0;
    }
    #searchBox h4 {
        margin: 6px 0 2px;
        font-size: 13px;
        color: #aaa;
        text-transform: uppercase;
        text-align: left;
    }


    /* Info & Stats panels */
    #infoBtn, #statsBtn {
      margin-top:6px; -webkit-user-select:none; user-select:none;
    }
    #infoPanel, #statsPanel {
      max-height:0; overflow:hidden;
      transition:max-height 0.3s ease;
      margin-top:6px;
      background:rgba(58,55,55,0.85);
      padding:0 6px; border-radius:4px;
      font-size:13px; color:#ddd;
      text-align: left;
    }
    #infoPanel.open { max-height:160px; } /* Increased height for patch notes button */
    #statsPanel.open { max-height:120px; }
    #infoPanel h4 { margin:6px 0 4px; color:#fff; text-transform: none; }
    #infoPanel ul { padding-left:16px; margin:0 }
    #infoPanel li { margin-bottom:4px; }
    #statsPanel div { margin:4px 0; color:#fff; }


    /* --- STYLES for Vertical Zoom Controls (LEFT) --- */
    #zoomControlsContainer {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 15px 10px;
      border-radius: 4px;
      z-index: 10;
      color: #fff;
      font-family: sans-serif;
    }
    
    #zoomControlsContainer #presetButtons {
      display: flex;
      flex-direction: column;
      gap: 5px;
      order: 4;
    }

    #zoomControlsContainer button {
      -webkit-user-select:none; user-select:none;
      margin: 0;
      width: 60px;
    }

    #searchBox select {
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 2px;
      padding: 2px;
      vertical-align: middle;
      width: 100%; /* Make select boxes fill their container */
    }

    #zoomControlsContainer #zoomInc { order: 1; }
    #zoomControlsContainer #sliderWrapper { order: 2; position: relative; }
    #zoomControlsContainer #zoomDec { order: 3; }
    #zoomControlsContainer #zoomLevel { order: 5; font-size: 14px; margin-top: 5px; }


    #zoomSlider {
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr; 
      height: 65vh; 
      max-height: 500px;
      width: auto;
      margin: 0;
    }

    #floatingZoomLabel {
        position: absolute;
        display: none;
        left: 25px;
        background-color: #0b508f;
        color: white;
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 13px;
        pointer-events: none;
        transform: translateY(-50%);
    }

    /* --- STYLES for Version Display & Patch Notes --- */
    #versionDisplay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: sans-serif;
        font-size: 12px;
        user-select: none;
        z-index: 10;
    }

    #modalOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
    }

    #patchNotesModal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        background: #2c2c2c;
        color: #eee;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    .patch-notes-header {
        padding: 15px;
        border-bottom: 1px solid #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .patch-notes-header h3 { margin: 0; }
    .patch-notes-header .close-btn {
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
    }
    .patch-notes-body {
        padding: 15px;
        max-height: 60vh;
        overflow-y: auto;
    }
    .patch-notes-body ul {
        padding-left: 20px;
        margin: 0;
    }
    .patch-notes-body li { margin-bottom: 8px; }
    .patch-notes-footer {
        padding: 10px 15px;
        border-top: 1px solid #444;
        background: #333;
        border-radius: 0 0 8px 8px;
    }
    .patch-notes-footer label { user-select: none; font-size: 14px; }

  </style>
</head>
<body>
  <!-- Search and info panel moved to top right -->
  <div id="searchBox">
    <h4>Search</h4>
    <div>
        X: <input id="inpX" type="number" min="0" max="1199" value="0">
        Y: <input id="inpY" type="number" min="0" max="1199" value="0">
        <button id="btnGo">Go</button>
    </div>
    <hr>
    <h4>Display</h4>
    <div>
      <input type="checkbox" id="gridlinesToggle">
      <label for="gridlinesToggle" class="coords-label">Show Gridlines</label>
    </div>
    <div>
      <input type="checkbox" id="coordsToggle">
      <label for="coordsToggle" class="coords-label">Show Coords >80%</label>
    </div>
    <div>
      <input type="checkbox" id="allianceRssToggle">
      <label for="allianceRssToggle" class="coords-label">Show Alliance RSS</label>
    </div>
    <div>
        <input type="checkbox" id="allianceRssAlwaysVisibleToggle">
        <label for="allianceRssAlwaysVisibleToggle" class="coords-label">Always Show RSS</label>
    </div>
    <hr>
    <h4>Performance</h4>
    <div>
        <label for="tileDetailSelect" class="coords-label">Tile Detail:</label>
        <select id="tileDetailSelect">
            <option value="25">Low (Merge Early)</option>
            <option value="50">Normal (Balanced)</option>
            <option value="80">High (Merge Late)</option>
        </select>
    </div>
    <hr>
    <div>
      <button id="infoBtn" title="Show controls">ℹ️</button>
      <button id="statsBtn" title="Toggle stats">⚙️</button>
    </div>
    <div id="infoPanel">
      <h4>Controls</h4>
      <ul>
        <li><strong>Pan</strong>: drag / one-finger touch</li>
        <li><strong>Zoom</strong>: wheel, slider, +/–, q/e, dblclick</li>
        <li><strong>Pinch</strong>: two-finger touch</li>
        <li><strong>Keyboard</strong>: arrows to pan</li>
      </ul>
      <button id="patchNotesBtn">Patch Notes</button>
    </div>
    <div id="statsPanel">
      <div id="statsFPS">FPS: –</div>
      <div id="statsTiles">Tiles: –</div>
    </div>
  </div>

  <!-- Vertically oriented zoom controls moved to left -->
  <div id="zoomControlsContainer">
    <button id="zoomInc">+</button>
    <div id="sliderWrapper">
        <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
        <div id="floatingZoomLabel"></div>
    </div>
    <button id="zoomDec">−</button>
    <div id="presetButtons">
        <button data-zoom="Fit">Fit</button>
        <button data-zoom="50">50%</button>
        <button data-zoom="75">75%</button>
        <button data-zoom="100">100%</button>
    </div>
    <div id="zoomLevel">Zoom: 100%</div>
  </div>
  
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>
  
  <!-- Patch Notes Modal -->
  <div id="modalOverlay"></div>
  <div id="patchNotesModal">
      <div class="patch-notes-header">
          <h3>What's New</h3>
          <button id="closePatchNotesBtn" class="close-btn">×</button>
      </div>
      <div class="patch-notes-body" id="patchNotesBody">
          <!-- Content will be injected by JS -->
      </div>
      <div class="patch-notes-footer">
          <input type="checkbox" id="hidePatchNotesCheckbox">
          <label for="hidePatchNotesCheckbox">Do not show this again until the next update.</label>
      </div>
  </div>


  <canvas id="map"></canvas>

<script>
const KingshotPlanner = {
  // —— CONFIGURATION ——
  config: {
    CURRENT_VERSION: '0.2.6.0',
    N: 1200,
    tileW: 10, tileH: 10,
    strokeW: 0.3, 
    borderColor: '#000', 
    textColor: '#fff',
    maxPct: 1000,
    selectionColor: '#ff0',
    pingColor: '#fff',
    pingDuration: 500, // in milliseconds
    baseScale: 5,
    biomeColors: {
      fertile:  'rgb(109, 159, 62)',
      plains:   'rgb(158, 180, 103)',
      badlands: 'rgb(191, 208, 152)'
    },
    biomeRegions: {
        fertile:  { x1: 480, y1: 480, x2: 719, y2: 719 },
        plains:   { x1: 320, y1: 320, x2: 879, y2: 879 },
        badlands: { x1: 0,   y1: 0,   x2: 1199,y2: 1199}
    },
    ALLIANCE_RSS_STYLES: {
      wood:  { displayName: 'Wood',  fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
      food:  { displayName: 'Food',  fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
      stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
      iron:  { displayName: 'Iron',  fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
    }
  },

  // —— APPLICATION STATE ——
  state: {
    baseMap: { unoccupiableTiles:[], defaultBuildings:[] },
    patchNotes: {},
    allBuildings: [],
    buildingMap: new Map(),
    chunkLevels: [],
    userBuildings: [],
    cam: { x:0, y:0, scale:1 },
    lastFrame: 0,
    tileCount: 0,
    lastFPS: 0,
    lastTiles: 0,
    selection: null, 
    minFitScale: 0.001, // Initial sensible minimum, will be refined by resize()
    isInitialLoad: true,
    touchStartTime: 0,
    dragging: false, 
    lastX: 0, lastY: 0,
    clickStartX: 0, clickStartY: 0,
    touchMode: null,
    startDist: 0, startScale: 1, pinchCenter: null,
    startCamX: 0, startCamY: 0,
    hideLabelTimeout: null,
    animationId: null 
  },

  // —— DOM REFERENCES ——
  dom: {
    canvas: null, ctx: null, inpX: null, inpY: null, btnGo: null,
    zoomLevelEl: null, zoomDecBtn: null, zoomIncBtn: null, zoomSlider: null,
    presetBtns: null, centerTileEl: null, infoBtn: null, infoPanel: null,
    statsBtn: null, statsPanel: null, statsFPSEl: null, statsTilesEl: null,
    coordsToggle: null, floatingZoomLabel: null, versionDisplay: null,
    patchNotesBtn: null, modalOverlay: null, patchNotesModal: null,
    patchNotesBody: null, closePatchNotesBtn: null, hidePatchNotesCheckbox: null,
    tileDetailSelect: null, gridlinesToggle: null, allianceRssToggle: null,
    allianceRssAlwaysVisibleToggle: null
  },

  // —— INITIALIZATION ——
  init() {
    const self = this; 

    this.dom.canvas = document.getElementById('map');
    if (!this.dom.canvas) {
        console.error("Fatal: Canvas element 'map' not found.");
        alert("Fatal Error: Canvas element not found. The application cannot start.");
        return; 
    }
    this.dom.ctx = this.dom.canvas.getContext('2d');
    if (!this.dom.ctx) {
        console.error("Fatal: Could not get 2D rendering context for canvas.");
        alert("Fatal Error: Could not initialize 2D graphics. The application cannot start. Try a different browser or update your current one.");
        return; 
    }

    this.dom.inpX = document.getElementById('inpX');
    this.dom.inpY = document.getElementById('inpY');
    this.dom.btnGo = document.getElementById('btnGo');
    this.dom.zoomLevelEl = document.getElementById('zoomLevel');
    this.dom.zoomDecBtn = document.getElementById('zoomDec');
    this.dom.zoomIncBtn = document.getElementById('zoomInc');
    this.dom.zoomSlider = document.getElementById('zoomSlider');
    this.dom.presetBtns = document.querySelectorAll('#presetButtons button');
    this.dom.centerTileEl = document.getElementById('centerTile');
    this.dom.infoBtn = document.getElementById('infoBtn');
    this.dom.infoPanel = document.getElementById('infoPanel');
    this.dom.statsBtn = document.getElementById('statsBtn');
    this.dom.statsPanel = document.getElementById('statsPanel');
    this.dom.statsFPSEl = document.getElementById('statsFPS');
    this.dom.statsTilesEl = document.getElementById('statsTiles');
    this.dom.coordsToggle = document.getElementById('coordsToggle');
    this.dom.floatingZoomLabel = document.getElementById('floatingZoomLabel');
    this.dom.versionDisplay = document.getElementById('versionDisplay');
    this.dom.patchNotesBtn = document.getElementById('patchNotesBtn');
    this.dom.modalOverlay = document.getElementById('modalOverlay');
    this.dom.patchNotesModal = document.getElementById('patchNotesModal');
    this.dom.patchNotesBody = document.getElementById('patchNotesBody');
    this.dom.closePatchNotesBtn = document.getElementById('closePatchNotesBtn');
    this.dom.hidePatchNotesCheckbox = document.getElementById('hidePatchNotesCheckbox');
    this.dom.tileDetailSelect = document.getElementById('tileDetailSelect');
    this.dom.gridlinesToggle = document.getElementById('gridlinesToggle');
    this.dom.allianceRssToggle = document.getElementById('allianceRssToggle');
    this.dom.allianceRssAlwaysVisibleToggle = document.getElementById('allianceRssAlwaysVisibleToggle');
    
    // Check if all essential DOM elements are found (optional, but good for robustness)
    for (const key in this.dom) {
        if (this.dom[key] === null && key !== 'ctx' && key !== 'canvas') { // ctx and canvas checked above
            console.warn(`DOM element for '${key}' not found.`);
        }
    }

    this.state.lastFrame = performance.now();
    
    Promise.all([
      fetch('baseMap.json').then(r => r.ok ? r.json() : Promise.resolve({ unoccupiableTiles:[], defaultBuildings:[] })),
      fetch('patch_notes.json').then(r => r.ok ? r.json() : Promise.resolve({}))
    ])
    .then(([baseMapData, patchNotesData]) => {
        Object.assign(self.state.baseMap, baseMapData);
        self.state.patchNotes = patchNotesData;

        self.preProcessBuildings();
        self.preCalculateChunks();
        self.initializeUI();
        self.resize(); 
        
        requestAnimationFrame(self.mainLoop.bind(self));
    })
    .catch(e => {
        console.error("Error during application initialization:", e);
        alert('Error loading essential application data or initializing. Check console for details.');
    });
  },

  initializeUI() {
    if(this.dom.infoBtn) this.dom.infoBtn.addEventListener('click', ()=>this.dom.infoPanel.classList.toggle('open'));
    if(this.dom.statsBtn) this.dom.statsBtn.addEventListener('click', ()=>this.dom.statsPanel.classList.toggle('open'));

    if(this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
    if(this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
    if(this.dom.closePatchNotesBtn) this.dom.closePatchNotesBtn.addEventListener('click', this.hidePatchNotes.bind(this));
    if(this.dom.modalOverlay) this.dom.modalOverlay.addEventListener('click', this.hidePatchNotes.bind(this));
    
    const lastSeenVersion = localStorage.getItem('lastSeenVersion');
    if (lastSeenVersion !== this.config.CURRENT_VERSION) {
        this.showPatchNotes();
    }

    if(this.dom.tileDetailSelect) {
        const savedDetail = localStorage.getItem('mapTileDetail') || '50';
        this.dom.tileDetailSelect.value = savedDetail;
        this.dom.tileDetailSelect.addEventListener('change', () => localStorage.setItem('mapTileDetail', this.dom.tileDetailSelect.value));
    }
    if(this.dom.allianceRssAlwaysVisibleToggle) {
        const savedAlwaysVisible = localStorage.getItem('mapAlwaysShowRss') === 'true';
        this.dom.allianceRssAlwaysVisibleToggle.checked = savedAlwaysVisible;
        this.dom.allianceRssAlwaysVisibleToggle.addEventListener('change', () => localStorage.setItem('mapAlwaysShowRss', this.dom.allianceRssAlwaysVisibleToggle.checked));
    }
    if(this.dom.gridlinesToggle) {
        const savedGridlines = localStorage.getItem('mapShowGridlines') !== 'false';
        this.dom.gridlinesToggle.checked = savedGridlines;
        this.dom.gridlinesToggle.addEventListener('change', () => localStorage.setItem('mapShowGridlines', this.dom.gridlinesToggle.checked));
    }
    if(this.dom.allianceRssToggle) {
        const savedAllianceRss = localStorage.getItem('mapShowAllianceRss') !== 'false';
        this.dom.allianceRssToggle.checked = savedAllianceRss;
        this.dom.allianceRssToggle.addEventListener('change', () => localStorage.setItem('mapShowAllianceRss', this.dom.allianceRssToggle.checked));
    }
    if(this.dom.coordsToggle) {
        const savedCoords = localStorage.getItem('mapShowCoords') === 'true';
        this.dom.coordsToggle.checked = savedCoords;
        this.dom.coordsToggle.addEventListener('change', () => localStorage.setItem('mapShowCoords', this.dom.coordsToggle.checked));
    }

    if(this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
    if(this.dom.inpX && this.dom.inpY) [this.dom.inpX, this.dom.inpY].forEach(i => i.addEventListener('keydown', e => { if (e.key==='Enter') this.doSearch(); }));

    if(this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-1));
    if(this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+1));
    if(this.dom.presetBtns) this.dom.presetBtns.forEach(b => {
        const zoomVal = b.dataset.zoom;
        if (zoomVal === 'Fit') {
            b.textContent = 'Fit';
            b.addEventListener('click', this.zoomToFit.bind(this));
        } else {
            b.addEventListener('click', () => {
                const cx = this.dom.canvas.width/2, cy = this.dom.canvas.height/2;
                this.animateZoom((Number(zoomVal) / 100) * this.config.baseScale, cx, cy, 200);
            });
        }
    });
    if(this.dom.zoomSlider) {
        this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));
        this.dom.zoomSlider.addEventListener('mousedown', () => {
            clearTimeout(this.state.hideLabelTimeout);
            this.updateFloatingZoomLabel();
        });
    }

    window.addEventListener('resize', this.resize.bind(this));
    window.addEventListener('mousemove', this.handleMouseMove.bind(this));
    window.addEventListener('mouseup', () => { this.state.dragging = false; });
    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    
    this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
    this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
    this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
    this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
    this.dom.canvas.addEventListener('contextmenu', e => e.preventDefault());
    
    this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
    this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
    this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
  },


  // —— DATA PROCESSING ——
  preProcessBuildings() {
    let buildings = [...(this.state.baseMap.defaultBuildings || []), ...(this.state.userBuildings || [])];
    if (this.state.baseMap.allianceRssBuildings) {
      const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
        const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
        return {
          x: rss.x, y: rss.y, w: 2, h: 2,
          displayName: style.displayName,
          fillColor: style.fillColor,
          borderColor: style.borderColor,
          displayCoordinates: false,
          isRss: true
        };
      });
      buildings = buildings.concat(formattedRssBuildings);
    }
    this.state.allBuildings = buildings;
    this.state.buildingMap.clear();
    for (const b of this.state.allBuildings) {
      if (typeof b.w === 'number' && typeof b.h === 'number') { // Ensure b.w and b.h are valid
        for (let dx = 0; dx < b.w; dx++) {
          for (let dy = 0; dy < b.h; dy++) {
            this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b);
          }
        }
      }
    }
  },

  preCalculateChunks() {
    const numLevels = 4;
    this.state.chunkLevels = []; // Ensure it's reset if called multiple times
    for (let level = 0; level < numLevels; level++) {
      const chunkSize = Math.pow(2, level + 1);
      const levelMap = new Map();
      for (let x = 0; x < this.config.N; x += chunkSize) {
        for (let y = 0; y < this.config.N; y += chunkSize) {
          const biome = this.getBiomeForTile(x, y);
          levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
        }
      }
      this.state.chunkLevels.push(levelMap);
    }
  },

  // —— HELPERS & GETTERS ——
  worldToScreen(x,y) {
    return [(x - y)*(this.config.tileW/2), -(x + y)*(this.config.tileH/2)];
  },

  screenToWorld(sx,sy) {
    const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
    const tileW_half = this.config.tileW / 2;
    const tileH_half = this.config.tileH / 2;

    if (tileW_half === 0 || tileH_half === 0) { // Prevent division by zero if tileW/H are misconfigured
        console.error("tileW or tileH is zero in config!");
        return [0,0]; 
    }

    const lx = (sx - this.state.cam.x)/scale;
    const ly = (sy - this.state.cam.y)/scale;
    const u  = lx/tileW_half;
    const v  = -ly/tileH_half;
    const world_x = Math.round((u+v)/2);
    const world_y = Math.round((v-u)/2);
    return [world_x,world_y];
  },

  getBuildingAt(x, y) {
    return this.state.buildingMap.get(`${x},${y}`) || null;
  },

  getBiomeForTile(x, y) {
    const { fertile, plains } = this.config.biomeRegions;
    if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
    if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
    return 'badlands';
  },

  getChunkLevelForZoom(pct) {
    if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100; // Recalculate if NaN
    const detailThreshold = parseInt(this.dom.tileDetailSelect ? this.dom.tileDetailSelect.value : '50', 10);
    if (pct > detailThreshold) return -1;
    if (pct > detailThreshold / 2) return 0;
    if (pct > detailThreshold / 5) return 1;
    if (pct > detailThreshold / 10) return 2;
    return 3;
  },

  // —— UI & INTERACTION HANDLERS ——
  showPatchNotes() {
    if (!this.dom.patchNotesBody || !this.dom.modalOverlay || !this.dom.patchNotesModal) return;
    const versions = Object.keys(this.state.patchNotes || {});
    if (versions.length === 0) {
        this.dom.patchNotesBody.innerHTML = `<p>No patch notes are available at this time.</p>`;
    } else {
        versions.sort((a, b) => {
            const partsA = a.split('.').map(Number);
            const partsB = b.split('.').map(Number);
            for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
                const numA = partsA[i] || 0;
                const numB = partsB[i] || 0;
                if (numA !== numB) return numB - numA;
            }
            return 0;
        });
        let content = '';
        versions.forEach((version, index) => {
            content += `<h4>Version ${version}</h4><ul>${(this.state.patchNotes[version] || []).map(note => `<li>${note}</li>`).join('')}</ul>`;
            if (index < versions.length - 1) content += '<hr style="border-color: #444; border-top: 0;">';
        });
        this.dom.patchNotesBody.innerHTML = content;
    }
    this.dom.modalOverlay.style.display = 'block';
    this.dom.patchNotesModal.style.display = 'block';
  },

  hidePatchNotes() {
    if (!this.dom.modalOverlay || !this.dom.patchNotesModal) return;
    if (this.dom.hidePatchNotesCheckbox && this.dom.hidePatchNotesCheckbox.checked) {
        localStorage.setItem('lastSeenVersion', this.config.CURRENT_VERSION);
    }
    this.dom.modalOverlay.style.display = 'none';
    this.dom.patchNotesModal.style.display = 'none';
  },

  handleMouseDown(e) {
    if (e.button===0) {
      this.state.dragging = true;
      this.state.lastX = e.clientX;
      this.state.lastY = e.clientY;
      this.state.clickStartX = e.clientX;
      this.state.clickStartY = e.clientY;
    }
  },

  handleMouseMove(e) {
    if (!this.state.dragging) return;
    this.state.cam.x += e.clientX - this.state.lastX;
    this.state.cam.y += e.clientY - this.state.lastY;
    this.state.lastX = e.clientX;
    this.state.lastY = e.clientY;
    this.clampCamera();
  },

  handleCanvasClick(e) {
    const dist = Math.hypot(e.clientX - this.state.clickStartX, e.clientY - this.state.clickStartY);
    if (dist > 5) return;
    
    const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
    if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
      const building = this.getBuildingAt(worldX, worldY);
      this.state.selection = building || { x: worldX, y: worldY };
      if(this.state.selection) this.state.selection.pingStart = performance.now(); 
      if(this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
      if(this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
    }
  },

  handleWheel(e) {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.2 : 0.8;
    let targetScale = this.state.cam.scale * factor;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    this.animateZoom(targetScale, e.offsetX, e.offsetY, 60);
  },

  handleDblClick(e) {
    e.preventDefault();
    const factor = e.button === 2 ? 0.5 : 2.0;
    let targetScale = this.state.cam.scale * factor;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    this.animateZoom(targetScale, e.offsetX, e.offsetY, 150);
  },

  handleZoomSlider() {
    if(!this.dom.zoomSlider) return;
    const pct = Number(this.dom.zoomSlider.value);
    let targetScale = (pct / 100) * this.config.baseScale;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    const cx = this.dom.canvas.width / 2, cy = this.dom.canvas.height / 2;
    this.animateZoom(targetScale, cx, cy, 0); 
    this.updateFloatingZoomLabel();
  },

  handleKeyDown(e) {
    if (e.target && e.target.tagName==='INPUT') return;
    switch(e.key) {
      case '+': case '=': this.changeZoomBy(+1); break;
      case '-': this.changeZoomBy(-1); break;
      case 'q': this.changeZoomBy(+1); break;
      case 'e': this.changeZoomBy(-1); break;
      case 'ArrowUp':    this.state.cam.y += this.config.tileW * 5; this.clampCamera(); break;
      case 'ArrowDown':  this.state.cam.y -= this.config.tileW * 5; this.clampCamera(); break;
      case 'ArrowLeft':  this.state.cam.x += this.config.tileW * 5; this.clampCamera(); break;
      case 'ArrowRight': this.state.cam.x -= this.config.tileW * 5; this.clampCamera(); break;
    }
  },

  handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length === 1) {
        this.state.touchMode = 'pan';
        const t = e.touches[0];
        this.state.lastX = t.clientX;
        this.state.lastY = t.clientY;
        this.state.clickStartX = t.clientX;
        this.state.clickStartY = t.clientY;
        this.state.touchStartTime = performance.now();
    } else if (e.touches.length === 2) {
        this.state.touchMode = 'pinch';
        const [a,b] = e.touches;
        this.state.startDist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
        this.state.startScale = this.state.cam.scale;
        this.state.pinchCenter = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
        
        this.state.startCamX = this.state.cam.x;
        this.state.startCamY = this.state.cam.y;
    }
  },

  handleTouchMove(e) {
    e.preventDefault();
    if (this.state.animationId) {
        cancelAnimationFrame(this.state.animationId);
        this.state.animationId = null;
    }

    if (this.state.touchMode === 'pan' && e.touches.length === 1) {
        const t = e.touches[0];
        this.state.cam.x += t.clientX - this.state.lastX;
        this.state.cam.y += t.clientY - this.state.lastY;
        this.state.lastX = t.clientX; this.state.lastY = t.clientY;
        this.clampCamera();
    } else if (this.state.touchMode === 'pinch' && e.touches.length === 2) {
        const [a,b] = e.touches;
        const dist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);

        // *** FIX APPLIED HERE ***
        if (this.state.startDist === 0) {
            // If startDist was 0, it means the initial two touch points were identical.
            // Avoid division by zero.
            // If points are still identical, do nothing.
            // If they have separated, we could re-initialize the pinch, but for now,
            // simply not processing the zoom change prevents NaN.
            return; 
        }

        let newScale = this.state.startScale * (dist / this.state.startDist);
        
        this.state.cam.scale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct/100 * this.config.baseScale, newScale));
        if (isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.startScale; // Failsafe for NaN

        // Ensure startScale used for calculating wx, wy is not zero.
        const safeStartScale = (this.state.startScale === 0 || isNaN(this.state.startScale)) ? this.state.minFitScale : this.state.startScale;

        const wx = (this.state.pinchCenter.x - this.state.startCamX) / safeStartScale;
        const wy = (this.state.pinchCenter.y - this.state.startCamY) / safeStartScale;

        if (isNaN(wx) || isNaN(wy)) { // If wx/wy became NaN, reset to prevent further issues
             this.state.cam.x = this.state.startCamX;
             this.state.cam.y = this.state.startCamY;
        } else {
            this.state.cam.x = this.state.pinchCenter.x - wx * this.state.cam.scale;
            this.state.cam.y = this.state.pinchCenter.y - wy * this.state.cam.scale;
        }
        this.clampCamera();
    }
  },

  handleTouchEnd(e) {
    if (this.state.touchMode === 'pan' && e.changedTouches.length === 1) {
      const t = e.changedTouches[0];
      const dist = Math.hypot(t.clientX - this.state.clickStartX, t.clientY - this.state.clickStartY);
      const duration = performance.now() - this.state.touchStartTime;
      if (duration < 200 && dist < 10) {
          const [worldX, worldY] = this.screenToWorld(t.clientX, t.clientY);
          if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
              const building = this.getBuildingAt(worldX, worldY);
              this.state.selection = building || { x: worldX, y: worldY };
              if(this.state.selection) this.state.selection.pingStart = performance.now(); 
              if(this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
              if(this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
          }
      }
    }
    if (e.touches.length < 2) this.state.touchMode = null;
  },

  // —— CORE LOGIC ——
  doSearch() {
    if(!this.dom.inpX || !this.dom.inpY) return;
    const x = +this.dom.inpX.value, y = +this.dom.inpY.value;
    if (x >= 0 && y >= 0 && x < this.config.N && y < this.config.N) {
      this.state.selection = this.getBuildingAt(x, y) || { x, y };
      if(this.state.selection) this.state.selection.pingStart = performance.now(); 
      const targetScale = (150 / 100) * this.config.baseScale;
      const [screenX, screenY] = this.worldToScreen(x, y);
      const targetCamX = this.dom.canvas.width/2 - screenX * targetScale;
      const targetCamY = this.dom.canvas.height/2 - screenY * targetScale;
      this.animatePanZoom(targetScale, targetCamX, targetCamY);
    }
  },
  
  centerOn(x,y) {
    const [lx, ly] = this.worldToScreen(x,y);
    this.state.cam.x = this.dom.canvas.width*0.5 - lx*this.state.cam.scale;
    this.state.cam.y = this.dom.canvas.height*0.5 - ly*this.state.cam.scale;
    this.clampCamera();
  },
  
  zoomToFit() {
    this.state.cam.scale = this.state.minFitScale; 
    this.state.cam.x = this.dom.canvas.width / 2;
    this.state.cam.y = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * this.state.cam.scale;
    this.clampCamera(); 
  },

  resize() {
    this.dom.canvas.width  = window.innerWidth;
    this.dom.canvas.height = window.innerHeight;
    const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
    const mapTotalHeight = (this.config.N - 1) * this.config.tileH;

    const safeMapTotalWidth = Math.max(1, mapTotalWidth);
    const safeMapTotalHeight = Math.max(1, mapTotalHeight);

    const scaleX = this.dom.canvas.width / safeMapTotalWidth;
    const scaleY = this.dom.canvas.height / safeMapTotalHeight;
    
    this.state.minFitScale = Math.max(0.001, Math.min(scaleX, scaleY) * 0.95);
    if (isNaN(this.state.minFitScale)) this.state.minFitScale = 0.001; // Failsafe
    
    if (this.state.isInitialLoad) {
        this.zoomToFit();
        this.state.isInitialLoad = false;
    } else {
        this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
        if(isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.minFitScale; // Failsafe
        this.clampCamera();
    }
  },

  clampCamera() {
    const s = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const canvasW = this.dom.canvas.width;
    const canvasH = this.dom.canvas.height;
    
    const mapScreenW = (this.config.N - 1) * this.config.tileW * s;
    const mapScreenH = (this.config.N - 1) * this.config.tileH * s;

    if (mapScreenW > canvasW) {
        const minCamX = canvasW - mapScreenW / 2;
        const maxCamX = mapScreenW / 2;
        this.state.cam.x = Math.max(minCamX, Math.min(maxCamX, this.state.cam.x));
    } else {
        this.state.cam.x = canvasW / 2;
    }

    if (mapScreenH > canvasH) {
        const minCamY = canvasH; 
        const maxCamY = mapScreenH; 
        this.state.cam.y = Math.max(minCamY, Math.min(maxCamY, this.state.cam.y));
    } else {
        this.state.cam.y = canvasH / 2 + mapScreenH / 2;
    }
    if(isNaN(this.state.cam.x)) this.state.cam.x = canvasW / 2; // Failsafe
    if(isNaN(this.state.cam.y)) this.state.cam.y = canvasH / 2; // Failsafe
  },

  changeZoomBy(delta) {
    let currentPct = (this.state.cam.scale / this.config.baseScale) * 100;
    if(isNaN(currentPct)) currentPct = (this.state.minFitScale / this.config.baseScale) * 100;

    const changeAmt = delta > 0 ? currentPct * 0.25 : currentPct * -0.2;
    let targetScale = ((currentPct + changeAmt) / 100) * this.config.baseScale;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    if(isNaN(targetScale)) targetScale = this.state.cam.scale; // Failsafe

    const cx = this.dom.canvas.width / 2, cy = this.dom.canvas.height / 2;
    this.animateZoom(targetScale, cx, cy, 100);
  },

  // —— ANIMATION & DRAWING ——
  animateZoom(targetScale, anchorX, anchorY, duration=150) {
    if (this.state.animationId) {
        cancelAnimationFrame(this.state.animationId);
    }
    const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const startX = this.state.cam.x, startY = this.state.cam.y;
    const start = performance.now();

    if (startScale === 0) { // Should not happen with minFitScale logic
        console.error("animateZoom called with startScale 0");
        this.state.cam.scale = targetScale; // Just jump to target
        this.clampCamera();
        return;
    }

    const wx = (anchorX - startX)/startScale;
    const wy = (anchorY - startY)/startScale;

    if (isNaN(wx) || isNaN(wy)) { // Failsafe if anchor calculation is NaN
        this.state.cam.scale = targetScale;
        this.clampCamera();
        return;
    }

    const step = (now) => {
      const t = duration === 0 ? 1 : Math.min(1, (now - start)/duration);
      const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
      this.state.cam.scale = startScale + (targetScale - startScale)*k;
      this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale); 
      if(isNaN(this.state.cam.scale)) this.state.cam.scale = startScale; // Failsafe

      this.state.cam.x = anchorX - wx * this.state.cam.scale;
      this.state.cam.y = anchorY - wy * this.state.cam.scale;
      this.clampCamera();
      if (t < 1) {
          this.state.animationId = requestAnimationFrame(step);
      } else {
          this.state.animationId = null;
      }
    };
    this.state.animationId = requestAnimationFrame(step);
  },

  animatePanZoom(targetScale, targetX, targetY, duration=300) {
    if (this.state.animationId) {
        cancelAnimationFrame(this.state.animationId);
    }
    const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const startX = this.state.cam.x, startY = this.state.cam.y;
    const start = performance.now();
    const step = (now) => {
        const t = Math.min(1, (now - start)/duration);
        const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
        this.state.cam.scale = startScale + (targetScale - startScale)*k;
        this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
        if(isNaN(this.state.cam.scale)) this.state.cam.scale = startScale; // Failsafe

        this.state.cam.x = startX + (targetX - startX)*k;
        this.state.cam.y = startY + (targetY - startY)*k;
        this.clampCamera();
        if (t < 1) {
            this.state.animationId = requestAnimationFrame(step);
        } else {
            this.state.animationId = null;
        }
    };
    this.state.animationId = requestAnimationFrame(step);
  },
  
  updateFloatingZoomLabel() {
    if(!this.dom.zoomSlider || !this.dom.floatingZoomLabel) return;
    const slider = this.dom.zoomSlider;
    const label = this.dom.floatingZoomLabel;
    const min = parseInt(slider.min, 10);
    const max = parseInt(slider.max, 10);
    const val = parseInt(slider.value, 10);

    if (max === min) { // Avoid division by zero if slider range is 0
        label.style.display = 'none';
        return;
    }

    const percent = (val - min) / (max - min);
    const thumbHeight = 15;
    const trackHeight = slider.offsetHeight;
    const topPos = (1 - percent) * (trackHeight - thumbHeight) + (thumbHeight / 2);
    label.style.top = `${topPos}px`;
    label.textContent = `Zoom: ${val}%`;
    label.style.display = 'block';
    clearTimeout(this.state.hideLabelTimeout);
    this.state.hideLabelTimeout = setTimeout(() => { label.style.display = 'none'; }, 1500);
  },

  drawTile(x, y, drawBorder = true) {
    this.state.tileCount++;
    const [sx,sy] = this.worldToScreen(x,y);
    const { config } = this;
    const ctx = this.dom.ctx;
    ctx.beginPath();
    ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
    ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
    ctx.closePath();

    ctx.fillStyle = config.biomeColors[this.getBiomeForTile(x, y)];
    ctx.fill();
    if (drawBorder) ctx.stroke();

    const building = this.getBuildingAt(x, y);
    if (building && building.hideCoordinates) return;

    const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const pct = Math.round((currentCamScale / config.baseScale) * 100);
    const showCoords = this.dom.coordsToggle ? this.dom.coordsToggle.checked : false;
    const showThreshold = showCoords ? 80 : 200;

    if (pct <= showThreshold) return;
    
    const text = `${x}, ${y}`;
    let optimalFontSize = Math.min(
      config.tileH * 0.8 * 0.5,
      (config.tileW * 0.8 / (text.length || 1)) * 1.8 // Ensure text.length is not 0
    ) * 0.7;
    if ((optimalFontSize * currentCamScale) < 5) return;

    ctx.fillStyle = config.textColor;
    ctx.font = `${optimalFontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, sx, sy);
  },

  drawChunk(chunk, drawBorder = true) {
    this.state.tileCount += chunk.size * chunk.size;
    const { x, y, size, biome } = chunk;
    const { config } = this;
    const ctx = this.dom.ctx;
    const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const inflation = drawBorder ? 0 : (1 / currentCamScale);
    const x0 = x, y0 = y, w = size, h = size;
    const [sbx, sby] = this.worldToScreen(x0, y0);
    const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
    const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1);
    const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
    const p_bottom = { x: sbx, y: sby + config.tileH/2 + inflation };
    const p_right  = { x: srx + config.tileW/2 + inflation, y: sry };
    const p_top    = { x: stx, y: sty - config.tileH/2 - inflation };
    const p_left   = { x: slx - config.tileW/2 - inflation, y: sly };
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y);
    ctx.closePath();
    ctx.fillStyle = config.biomeColors[biome];
    ctx.fill();
    if (drawBorder) ctx.stroke();
  },
  
  drawBuildingFootprint(b, highlightStyle = null, drawBorder = true) {
    const { config, state } = this;
    const ctx = this.dom.ctx;
    const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
    const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
    const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
    const [sbx, sby] = this.worldToScreen(x0, y0);
    const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
    const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1);
    const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
    const p_bottom = { x: sbx, y: sby + config.tileH/2 };
    const p_right  = { x: srx + config.tileW/2, y: sry };
    const p_top    = { x: stx, y: sty - config.tileH/2 };
    const p_left   = { x: slx - config.tileW/2, y: sly };
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = border; 
    ctx.lineWidth = highlightStyle ? config.strokeW * 2 : config.strokeW;
    if (drawBorder) ctx.stroke();

    const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
    if (currentCamScale > 0.4 && b.displayName) {
      const availableWidth = (p_right.x - p_left.x) * 0.8;
      const availableHeight = p_bottom.y - p_top.y;
      if (availableWidth < 10 || availableHeight < 10) return;
      const hasCoords = b.displayCoordinates;
      const heightFactor = hasCoords ? 0.5 : 1.0; 
      const fontSizeBasedOnHeight = (availableHeight * heightFactor) * 0.9;
      ctx.font = `bold 100px sans-serif`; 
      const textMetrics = ctx.measureText(b.displayName);
      const displayNameWidth = textMetrics.width || 1; // Ensure not zero
      const fontSizeBasedOnWidth = (availableWidth / displayNameWidth) * 100;
      const optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);

      if (optimalFontSize * currentCamScale < 7) return;
      const centerX = (p_left.x + p_right.x) / 2;
      const yOffset = hasCoords ? optimalFontSize * -0.45 : 0;
      const centerY = (p_top.y + p_bottom.y) / 2 + yOffset;
      ctx.fillStyle = config.textColor;
      ctx.font = `bold ${optimalFontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.displayName, centerX, centerY);
      if (b.displayCoordinates) {
        const coordFontSize = optimalFontSize * 0.7;
        ctx.font = `${coordFontSize}px sans-serif`;
        ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, centerY + optimalFontSize * 0.9);
      }
    }
  },

  // —— MAIN RENDER LOOP ——
  mainLoop(now) {
    const { dom, state, config } = this;
    const ctx = dom.ctx; // Assumed to be valid by checks in init()
    
    try {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,dom.canvas.width,dom.canvas.height);

        const [centerX, centerY] = this.screenToWorld(dom.canvas.width/2, dom.canvas.height/2);
        if(dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
        
        const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
        const pct = Math.round((currentCamScale / config.baseScale) * 100);

        if(dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
        if(dom.zoomSlider) {
            if (pct > parseInt(dom.zoomSlider.max,10)) dom.zoomSlider.max = pct.toString();
            if (pct < parseInt(dom.zoomSlider.min,10)) dom.zoomSlider.min = pct.toString();
            dom.zoomSlider.value = pct.toString();
        }
        state.tileCount = 0;

        ctx.save();
        ctx.setTransform(currentCamScale,0,0,currentCamScale,state.cam.x,state.cam.y);
        ctx.strokeStyle = config.borderColor;
        ctx.lineWidth = config.strokeW;
        
        const [tl_x, tl_y] = this.screenToWorld(0, 0);
        const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
        const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height);
        const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
        const viewBounds = {
          minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2,
          maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
          minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2,
          maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
        };

        if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
            console.error("View bounds are NaN, skipping render cycle.", viewBounds);
            ctx.restore();
            requestAnimationFrame(this.mainLoop.bind(this));
            return;
        }

        const chunkLevel = this.getChunkLevelForZoom(pct);
        const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
        const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
        const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;

        if (chunkLevel === -1) {
          const shouldDrawBorders = showGrid && pct > 50;
          const minSum = Math.floor(viewBounds.minX + viewBounds.minY);
          const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);
          for (let sum = minSum; sum <= maxSum; sum++) {
            const startX = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY)));
            const endX = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));
            for (let x = startX; x <= endX; x++) {
                const y = sum - x;
                if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue;
                if (!this.getBuildingAt(x, y)) this.drawTile(x, y, shouldDrawBorders);
            }
          }
          
          state.allBuildings
            .filter(b => !b.isRss || showRss)
            .filter(b => !(b.x > viewBounds.maxX || b.x + (b.w || 1) -1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + (b.h || 1) -1 < viewBounds.minY))
            .forEach(b => this.drawBuildingFootprint(b, null, shouldDrawBorders));

          ctx.fillStyle = '#444';
          (state.baseMap.unoccupiableTiles || []).forEach(([x,y])=>{
            if (this.getBuildingAt(x, y)) return;
            if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
            const [sx,sy] = this.worldToScreen(x,y);
            ctx.beginPath();
            ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
            ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
            ctx.closePath(); ctx.fill();
          });

        } else {
          if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
            const chunksToDraw = state.chunkLevels[chunkLevel];
            const chunkSize = Math.pow(2, chunkLevel + 1);
            const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize;
            const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
            const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize;
            const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
            for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
              for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
                  const chunk = chunksToDraw.get(`${x},${y}`);
                  if (chunk) this.drawChunk(chunk, false);
              }
            }
          }

          (state.baseMap.defaultBuildings || [])
            .filter(b => !(b.x > viewBounds.maxX || b.x + (b.w || 1) -1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + (b.h || 1) -1 < viewBounds.minY))
            .forEach(b => this.drawBuildingFootprint(b, null, false));
          
          if (showRss && alwaysShowRss) {
            state.allBuildings
              .filter(b => b.isRss && !(b.x > viewBounds.maxX || b.x + (b.w || 1) -1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + (b.h || 1) -1 < viewBounds.minY))
              .forEach(b => this.drawBuildingFootprint(b, null, false));
          }
          
          if (chunkLevel < 2) {
              ctx.fillStyle = '#444';
              (state.baseMap.unoccupiableTiles || []).forEach(([x,y])=>{
                if (this.getBuildingAt(x, y)) return;
                if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
                const [sx,sy] = this.worldToScreen(x,y);
                ctx.beginPath();
                ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
                ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
                ctx.closePath(); ctx.fill();
              });
          }
        }

        if (state.selection) {
          let highlightColor = config.selectionColor;
          if (state.selection.pingStart && now - state.selection.pingStart < config.pingDuration) {
              if (Math.floor((now - state.selection.pingStart) / 100) % 2 === 0) {
                  highlightColor = config.pingColor;
              }
          }
          if (state.selection.w) { // It's a building
            this.drawBuildingFootprint(state.selection, highlightColor, true);
          } else { // It's a tile
            const [sx, sy] = this.worldToScreen(state.selection.x, state.selection.y);
            ctx.beginPath();
            ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
            ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
            ctx.closePath();
            ctx.strokeStyle = highlightColor;
            ctx.lineWidth = config.strokeW * 1.5;
            ctx.stroke();
          }
        }
        
        ctx.restore();

        const dt  = now - state.lastFrame;
        state.lastFrame = now;
        if (dt > 0) { // Avoid division by zero if dt is 0
            state.lastFPS   = Math.round(1000/dt);
        }
        state.lastTiles = state.tileCount;
        if (!mainLoop.t0) mainLoop.t0 = now;
        if (now - mainLoop.t0 > 500) {
          if(dom.statsFPSEl) dom.statsFPSEl.textContent   = `FPS:   ${state.lastFPS}`;
          if(dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
          mainLoop.t0 = now;
        }
    } catch (error) {
        console.error("Error in mainLoop:", error);
        // Optionally, stop the loop if errors are too frequent or critical
        // cancelAnimationFrame(this.state.animationId); // Or however you store the main loop's ID
        // alert("A critical error occurred in the rendering loop. Please refresh.");
    }
    
    requestAnimationFrame(this.mainLoop.bind(this));
  }
};

KingshotPlanner.init();

</script>
</body>
</html>