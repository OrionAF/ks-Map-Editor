<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
<style>
    body {
      margin:0; background:#111; overflow:hidden;
      -webkit-user-select:none; user-select:none;
    }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }

    /* UI Container */
    #searchBox {
      position:absolute; top:10px; left:10px; z-index:10;
      color:#fff; font-family:sans-serif;
      background:rgba(0,0,0,0.6); padding:8px; border-radius:4px;
    }
    #searchBox input { width:60px; }
    #searchBox input[type=range] {
      width:250px;
      vertical-align:middle; margin:0 6px;
    }
    #searchBox button {
      margin:2px 4px 2px 0;
      -webkit-user-select:none; user-select:none;
    }
    #zoomLevel, #centerTile {
      margin-top:4px; font-size:14px;
      -webkit-user-select:none; user-select:none;
    }

    /* Info & Stats panels */
    #infoBtn, #statsBtn {
      margin-top:6px; -webkit-user-select:none; user-select:none;
    }
    #infoPanel, #statsPanel {
      max-height:0; overflow:hidden;
      transition:max-height 0.3s ease;
      margin-top:6px;
      background:rgba(58,55,55,0.85);
      padding:0 6px; border-radius:4px;
      font-size:13px; color:#ddd;
    }
    #infoPanel.open, #statsPanel.open { max-height:120px; }
    #infoPanel h4 { margin:6px 0 4px; color:#fff; }
    #infoPanel ul { padding-left:16px; margin:0 }
    #infoPanel li { margin-bottom:4px; }
    #statsPanel div { margin:4px 0; color:#fff; }
  </style>
</head>
<body>
  <div id="searchBox">
    X: <input id="inpX" type="number" min="0" max="1199" value="0">
    Y: <input id="inpY" type="number" min="0" max="1199" value="0">
    <button id="btnGo">Go</button>
    <div id="zoomLevel">Zoom: 100%</div>
    <button id="zoomDec">−</button>
    <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
    <button id="zoomInc">+</button>
    <div id="presetButtons">
        <button data-zoom="Fit">Fit</button>
        <button data-zoom="50">50%</button>
        <button data-zoom="75">75%</button>
        <button data-zoom="100">100%</button>
    </div>
    <div id="centerTile">Center: X0 Y0</div>
    <button id="infoBtn" title="Show controls">ℹ️</button>
    <div id="infoPanel">
      <h4>Controls</h4>
      <ul>
        <li><strong>Pan</strong>: drag / one-finger touch</li>
        <li><strong>Zoom</strong>: wheel, slider, +/–, q/e, dblclick</li>
        <li><strong>Zoom out</strong>: right-dblclick</li>
        <li><strong>Pinch</strong>: two-finger touch</li>
        <li><strong>Keyboard</strong>: arrows to pan</li>
        <li><strong>Search</strong>: enter X/Y then Go (zooms to 150%)</li>
      </ul>
    </div>
    <button id="statsBtn" title="Toggle stats">⚙️</button>
    <div id="statsPanel">
      <div id="statsFPS">FPS: –</div>
      <div id="statsTiles">Tiles: –</div>
    </div>
  </div>

  <canvas id="map"></canvas>

<script>
// —— CONFIG ——
  const N           = 1200,
        tileW       = 10, tileH = 10,
        strokeW     = 0.3, 
        borderColor = '#000', 
        textColor   = '#fff',
        maxPct      = 1000,
        selectionColor = '#ff0';
  
  const baseScale = 5;

  const biomeColors = {
    fertile:  'rgb(109, 159, 62)',
    plains:   'rgb(158, 180, 103)',
    badlands: 'rgb(191, 208, 152)'
  };
  
  const biomeRegions = {
      fertile:  { x1: 480, y1: 480, x2: 719, y2: 719 },
      plains:   { x1: 320, y1: 320, x2: 879, y2: 879 },
      badlands: { x1: 0,   y1: 0,   x2: 1199,y2: 1199}
  };
  // ——————————

  // DOM refs
  const canvas       = document.getElementById('map');
  const ctx          = canvas.getContext('2d');
  const inpX         = document.getElementById('inpX');
  const inpY         = document.getElementById('inpY');
  const btnGo        = document.getElementById('btnGo');
  const zoomLevelEl  = document.getElementById('zoomLevel');
  const zoomDecBtn   = document.getElementById('zoomDec');
  const zoomIncBtn   = document.getElementById('zoomInc');
  const zoomSlider   = document.getElementById('zoomSlider');
  const presetBtns   = document.querySelectorAll('#presetButtons button');
  const centerTileEl = document.getElementById('centerTile');
  const infoBtn      = document.getElementById('infoBtn');
  const infoPanel    = document.getElementById('infoPanel');
  const statsBtn     = document.getElementById('statsBtn');
  const statsPanel   = document.getElementById('statsPanel');
  const statsFPSEl   = document.getElementById('statsFPS');
  const statsTilesEl = document.getElementById('statsTiles');

  // toggle panels
  infoBtn.addEventListener('click', ()=>infoPanel.classList.toggle('open'));
  statsBtn.addEventListener('click', ()=>statsPanel.classList.toggle('open'));

  // data layers
  let baseMap = { unoccupiableTiles:[], defaultBuildings:[] };
  const buildingMap = new Map();
  const chunkLevels = []; 

  function preProcessBuildings() {
    buildingMap.clear();
    const allBuildings = [...baseMap.defaultBuildings, ...userBuildings];
    for (const b of allBuildings) {
      for (let dx = 0; dx < b.w; dx++) {
        for (let dy = 0; dy < b.h; dy++) {
          const key = `${b.x + dx},${b.y + dy}`;
          buildingMap.set(key, b);
        }
      }
    }
  }

  function preCalculateChunks() {
    const numLevels = 4;
    for (let level = 0; level < numLevels; level++) {
      const chunkSize = Math.pow(2, level + 1);
      const levelMap = new Map();
      
      for (let x = 0; x < N; x += chunkSize) {
        for (let y = 0; y < N; y += chunkSize) {
          const biome = getBiomeForTile(x, y);
          levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
        }
      }
      chunkLevels.push(levelMap);
    }
  }


  fetch('baseMap.json')
    .then(r=>r.ok? r.json(): Promise.resolve({ unoccupiableTiles:[], defaultBuildings:[] }))
    .then(d=>{
      Object.assign(baseMap, d);
      preProcessBuildings();
      preCalculateChunks();
      resize();
      
      requestAnimationFrame(mainLoop);
    })
    .catch(e=>{ console.error(e); alert('BaseMap load error'); });
  
  let userBuildings = [];

  // camera + stats state …
  const cam = { x:0, y:0, scale:1 };
  let lastFrame = performance.now(),
      tileCount = 0,
      lastFPS = 0,
      lastTiles = 0;
  let selection = null; 
  let minFitScale = 0.01;
  // FIX 1: Add a flag for robust initial loading.
  let isInitialLoad = true;
  let touchStartTime = 0; // Add this line

  // coord transforms
  function worldToScreen(x,y) {
    return [(x - y)*(tileW/2), -(x + y)*(tileH/2)];
  }
  function screenToWorld(sx,sy) {
    const lx = (sx - cam.x)/cam.scale,
          ly = (sy - cam.y)/cam.scale,
          u  = lx/(tileW/2),
          v  = -ly/(tileH/2);
    const x = Math.round((u+v)/2),
          y = Math.round((v-u)/2);
    return [x,y];
  }

  function getBuildingAt(x, y) {
    return buildingMap.get(`${x},${y}`) || null;
  }

  function getBiomeForTile(x, y) {
    const { fertile, plains } = biomeRegions;
    if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) {
      return 'fertile';
    }
    if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) {
      return 'plains';
    }
    return 'badlands';
  }

  // --- GRID DRAWING ---
  function drawTile(x, y, drawBorder = true) {
    tileCount++;
    const [sx,sy] = worldToScreen(x,y);
    ctx.beginPath();
    ctx.moveTo(   sx,        sy - tileH/2);
    ctx.lineTo(sx + tileW/2, sy      );
    ctx.lineTo(   sx,        sy + tileH/2);
    ctx.lineTo(sx - tileW/2, sy      );
    ctx.closePath();

    const biome = getBiomeForTile(x, y);
    ctx.fillStyle = biomeColors[biome];
    ctx.fill();
    if (drawBorder) {
      ctx.stroke();
    }

    const building = getBuildingAt(x, y);
    if (building && building.hideCoordinates) {
        return;
    }

    if (cam.scale <= baseScale) {
        return;
    }
    
    const availableWidth = tileW;
    const availableHeight = tileH;
    const text = `${x}, ${y}`;
    const padding = 0.8;
    let optimalFontSize = Math.min(
      availableHeight * padding * 0.5,
      (availableWidth * padding / text.length) * 1.8
    );
    
    optimalFontSize *= 0.7;

    if ((optimalFontSize * cam.scale) < 5) {
        return;
    }

    ctx.fillStyle = textColor;
    ctx.font = `${optimalFontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, sx, sy);
  }

  function drawChunk(chunk, drawBorder = true) {
    tileCount += chunk.size * chunk.size;
    const { x, y, size, biome } = chunk;

    // When borders are off, slightly inflate the chunk to cover rendering seams.
    const inflation = drawBorder ? 0 : 0.5;

    const x0 = x, y0 = y, w = size, h = size;
    const bottomTile = { x: x0, y: y0 };
    const rightTile  = { x: x0 + w - 1, y: y0 };
    const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
    const leftTile   = { x: x0, y: y0 + h - 1 };
    const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
    const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
    const [stx, sty] = worldToScreen(topTile.x, topTile.y);
    const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);

    // Apply the inflation to the corner points of the polygon
    const p_bottom = { x: sbx, y: sby + tileH/2 + inflation };
    const p_right  = { x: srx + tileW/2 + inflation, y: sry };
    const p_top    = { x: stx, y: sty - tileH/2 - inflation };
    const p_left   = { x: slx - tileW/2 - inflation, y: sly };

    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y);
    ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x,    p_top.y);
    ctx.lineTo(p_left.x,   p_left.y);
    ctx.closePath();

    ctx.fillStyle = biomeColors[biome];
    ctx.fill();
    if (drawBorder) {
      ctx.stroke();
    }
  }


  function drawBuildingFootprint(b, highlightStyle = null, drawBorder = true) {
    const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
    const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
    const x0 = b.x, y0 = b.y, w = b.w, h = b.h;

    const bottomTile = { x: x0, y: y0 };
    const rightTile  = { x: x0 + w - 1, y: y0 };
    const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
    const leftTile   = { x: x0, y: y0 + h - 1 };
    const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
    const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
    const [stx, sty] = worldToScreen(topTile.x, topTile.y);
    const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);
    const p_bottom = { x: sbx, y: sby + tileH/2 };
    const p_right  = { x: srx + tileW/2, y: sry };
    const p_top    = { x: stx, y: sty - tileH/2 };
    const p_left   = { x: slx - tileW/2, y: sly };
    
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y);
    ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x,    p_top.y);
    ctx.lineTo(p_left.x,   p_left.y);
    ctx.closePath();
    
    ctx.fillStyle = fill;
    ctx.fill();
    
    ctx.strokeStyle = border; 
    ctx.lineWidth = highlightStyle ? strokeW * 2 : strokeW;
    if (drawBorder) {
        ctx.stroke();
    }

    if (cam.scale > 0.4 && b.displayName) {
      const availableWidth = p_right.x - p_left.x;
      const availableHeight = p_bottom.y - p_top.y;
      
      // Stop if there's no space at all
      if (availableWidth < 10 || availableHeight < 10) return;
      
      const hasCoords = b.displayCoordinates;
      const coordText = `(X${b.x}, Y${b.y})`;
      const effectiveLength = hasCoords ? Math.max(b.displayName.length, coordText.length * 0.7) : b.displayName.length;
      const heightFactor = hasCoords ? 0.5 : 1.0;
      
      const padding = 0.9;
      
      let optimalFontSize = Math.min(
        (availableHeight * heightFactor) * padding,
        (availableWidth * padding / effectiveLength) * 1.2
      );
      
      // Don't render text if it would be illegibly small on screen.
      if (optimalFontSize * cam.scale < 7) return;
      
      // Set a minimum logical font size for the primary name.
      optimalFontSize = Math.max(10, optimalFontSize);
      
      const centerX = (p_left.x + p_right.x) / 2;
      const yOffset = hasCoords ? optimalFontSize * -0.45 : 0;
      const centerY = (p_top.y + p_bottom.y) / 2 + yOffset;

      ctx.fillStyle = textColor;
      ctx.font = `bold ${optimalFontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.displayName, centerX, centerY);
      
      if (b.displayCoordinates) {
        // The coordinate font size is now ALWAYS a proportion of the (clamped) main font size.
        const coordFontSize = optimalFontSize * 0.6;
        ctx.font = `${coordFontSize}px sans-serif`;
        ctx.fillText(coordText, centerX, centerY + optimalFontSize * 0.9);
      }
    }
  }

  function centerOn(x,y) {
    const [lx, ly] = worldToScreen(x,y);
    cam.x = canvas.width*0.5 - lx*cam.scale;
    cam.y = canvas.height*0.5 - ly*cam.scale;
  }
  
  function zoomToFit() {
    cam.scale = minFitScale;
    clampCamera();
  }

  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    const mapTotalWidth = (N - 1) * tileW;
    const mapTotalHeight = (N - 1) * tileH;
    
    const scaleX = canvas.width / mapTotalWidth;
    const scaleY = canvas.height / mapTotalHeight;

    const padding = 0.95;
    minFitScale = Math.min(scaleX, scaleY) * padding;
    
    // FIX 1: Use the robust flag to handle initial load.
    if (isInitialLoad) {
        zoomToFit();
        isInitialLoad = false;
    } else {
        clampCamera();
    }
  }
  window.addEventListener('resize', resize);

function clampCamera() {
    const s = cam.scale;
    const mapTotalWidth = (N - 1) * tileW;
    const mapTotalHeight = (N - 1) * tileH;
    const mapScaledWidth = mapTotalWidth * s;
    const mapScaledHeight = mapTotalHeight * s;

    const worldHalfWidth = mapScaledWidth / 2;
    
    // Allow panning until the map edge is near the center of the screen.
    const overscrollX = canvas.width * 0.5;
    const overscrollY = canvas.height * 0.5;

    // Horizontal clamping
    if (mapScaledWidth < canvas.width) {
      // Center the map if it's smaller than the canvas
      cam.x = canvas.width / 2;
    } else {
      const minCamX = canvas.width - worldHalfWidth;
      const maxCamX = worldHalfWidth;
      cam.x = Math.max(minCamX - overscrollX, Math.min(maxCamX + overscrollX, cam.x));
    }
    
    // Vertical clamping
    if (mapScaledHeight < canvas.height) {
      // Center the map if it's smaller than the canvas
      cam.y = canvas.height / 2 + mapScaledHeight / 2;
    } else {
      const minCamY = canvas.height;
      const maxCamY = mapScaledHeight;
      cam.y = Math.max(minCamY - overscrollY, Math.min(maxCamY + overscrollY, cam.y));
    }
  }

  let dragging=false, lastX, lastY;
  let clickStartX, clickStartY;
  canvas.addEventListener('mousedown', e=>{
    if (e.button===0) {
      dragging=true;
      lastX = e.clientX;
      lastY = e.clientY;
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    }
  });
  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    cam.x += e.clientX - lastX;
    cam.y += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    clampCamera();
  });
  window.addEventListener('mouseup', ()=>dragging=false);

  canvas.addEventListener('click', e => {
    const dist = Math.hypot(e.clientX - clickStartX, e.clientY - clickStartY);
    if (dist > 5) {
      return;
    }
    const [worldX, worldY] = screenToWorld(e.offsetX, e.offsetY);

    if (worldX >= 0 && worldX < N && worldY >= 0 && worldY < N) {
      const building = getBuildingAt(worldX, worldY);
      
      if (building) {
        selection = building;
        inpX.value = building.x;
        inpY.value = building.y;
      } else {
        selection = { x: worldX, y: worldY };
        inpX.value = worldX;
        inpY.value = worldY;
      }
    }
  });

  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.1 : 0.9;
    const mx = e.offsetX, my = e.offsetY;
    const wx = (mx - cam.x)/cam.scale,
          wy = (my - cam.y)/cam.scale;
    cam.scale *= factor;
    cam.scale = Math.max(minFitScale,
      Math.min(maxPct/100 * baseScale, cam.scale));
    cam.x = mx - wx * cam.scale;
    cam.y = my - wy * cam.scale;
    clampCamera();
  },{ passive:false });

  function animateZoom(targetScale, anchorX, anchorY, duration=150) {
    const startScale = cam.scale;
    const startX = cam.x, startY = cam.y;
    const start = performance.now();
    const wx = (anchorX - startX)/startScale,
          wy = (anchorY - startY)/startScale;

    function step(now) {
      const t = Math.min(1, (now - start)/duration);
      const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
      cam.scale = startScale + (targetScale - startScale)*k;
      cam.x = anchorX - wx * cam.scale;
      cam.y = anchorY - wy * cam.scale;
      clampCamera();
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  canvas.addEventListener('dblclick', e=>{
    e.preventDefault();
    const curPct = Math.round((cam.scale / baseScale) * 100);
    let targetPct;
    if (e.button === 2) { 
      targetPct = curPct - 75;
    } else { 
      targetPct = curPct + 75;
    }
    const targetScale = (targetPct / 100) * baseScale;
    animateZoom(Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale)), e.offsetX, e.offsetY);
  });

  canvas.addEventListener('contextmenu', e=>e.preventDefault());

  zoomSlider.addEventListener('input', () => {
    const cx = canvas.width/2, cy = canvas.height/2;
    const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
    let pct = Number(zoomSlider.value);
    const targetScale = (pct / 100) * baseScale;
    cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
    cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
    clampCamera();
  });

  function changeZoomBy(delta) {
    const cx = canvas.width/2, cy = canvas.height/2;
    const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
    let pct = Math.round((cam.scale / baseScale) * 100) + delta;
    const targetScale = (pct / 100) * baseScale;
    cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
    cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
    clampCamera();
  }
  zoomDecBtn.addEventListener('click', ()=>changeZoomBy(-1));
  zoomIncBtn.addEventListener('click', ()=>changeZoomBy(+1));

  presetBtns.forEach(b => {
    const zoomVal = b.dataset.zoom;
    if (zoomVal === 'Fit') {
        b.textContent = 'Fit';
        b.addEventListener('click', zoomToFit);
        return;
    }

    b.addEventListener('click', () => {
        // UX FIX: Use smooth animation for preset buttons.
        const cx = canvas.width/2, cy = canvas.height/2;
        let pct = Number(zoomVal);
        const targetScale = (pct / 100) * baseScale;
        animateZoom(targetScale, cx, cy, 200); // Animate over 200ms
    });
  });

  window.addEventListener('keydown', e=>{
    if (e.target.tagName==='INPUT') return;
    switch(e.key) {
      case '+': case '=': changeZoomBy(+1); break;
      case '-': changeZoomBy(-1); break;
      case 'q': changeZoomBy(+1); break;
      case 'e': changeZoomBy(-1); break;
      case 'ArrowUp':    cam.y += tileW * 5; clampCamera(); break;
      case 'ArrowDown':  cam.y -= tileW * 5; clampCamera(); break;
      case 'ArrowLeft':  cam.x += tileW * 5; clampCamera(); break;
      case 'ArrowRight': cam.x -= tileW * 5; clampCamera(); break;
    }
  });

  function doSearch() {
    const x = +inpX.value, y = +inpY.value;
    if (x>=0 && y>=0 && x<N && y<N) {
      const building = getBuildingAt(x, y);
      selection = building || { x, y };

      const targetScale = (150 / 100) * baseScale;
      
      // Animate to the target
      const [screenX, screenY] = worldToScreen(x, y);
      const targetCamX = canvas.width/2 - screenX * targetScale;
      const targetCamY = canvas.height/2 - screenY * targetScale;
      
      animatePanZoom(targetScale, targetCamX, targetCamY);
    }
  }

  // Helper function for combined pan-and-zoom animation
  function animatePanZoom(targetScale, targetX, targetY, duration=300) {
      const startScale = cam.scale, startX = cam.x, startY = cam.y;
      const start = performance.now();

      function step(now) {
          const t = Math.min(1, (now - start)/duration);
          const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; // ease-in-out
          
          cam.scale = startScale + (targetScale - startScale)*k;
          cam.x = startX + (targetX - startX)*k;
          cam.y = startY + (startY - targetY)*k;
          
          clampCamera();
          if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
  }
  btnGo.addEventListener('click', doSearch);
  [inpX,inpY].forEach(i=>{
    i.addEventListener('keydown', e=>{ if (e.key==='Enter') doSearch(); });
  });

  let touchMode = null;
  let startDist, startScale, pinchCenter;

  canvas.addEventListener('touchstart', e=>{
    e.preventDefault();
    if (e.touches.length===1) {
      touchMode = 'pan';
      const t = e.touches[0];
      lastX = t.clientX;
      lastY = t.clientY;
      clickStartX = t.clientX; // Record start position for tap detection
      clickStartY = t.clientY;
      touchStartTime = performance.now(); // Record start time for tap detection
    } else if (e.touches.length===2) {
      touchMode = 'pinch';
      const [a,b] = e.touches;
      startDist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
      startScale= cam.scale;
      pinchCenter = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', e=>{
    e.preventDefault();
    if (touchMode==='pan' && e.touches.length===1) {
      const t = e.touches[0];
      const dx = t.clientX - lastX, dy = t.clientY - lastY;
      cam.x += dx; cam.y += dy;
      lastX = t.clientX; lastY = t.clientY;
      clampCamera();
    }
    else if (touchMode==='pinch' && e.touches.length===2) {
      const [a,b] = e.touches;
      const dist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
      let scaleFactor = dist / startDist;
      let newScale = startScale * scaleFactor;
      newScale = Math.max(minFitScale, Math.min(maxPct/100 * baseScale, newScale));
      const wx = (pinchCenter.x - cam.x)/cam.scale, wy = (pinchCenter.y - cam.y)/cam.scale;
      cam.scale = newScale;
      cam.x = pinchCenter.x - wx*newScale;
      cam.y = pinchCenter.y - wy*newScale;
      clampCamera();
    }
  }, { passive:false });

  canvas.addEventListener('touchend', e=>{
    // Logic to handle tap-to-select on touch devices
    if (touchMode === 'pan' && e.changedTouches.length === 1) {
      const t = e.changedTouches[0];
      const dist = Math.hypot(t.clientX - clickStartX, t.clientY - clickStartY);
      const duration = performance.now() - touchStartTime;

      // Consider it a 'tap' if it's short and hasn't moved far.
      if (duration < 200 && dist < 10) {
        const [worldX, worldY] = screenToWorld(t.clientX, t.clientY);
        if (worldX >= 0 && worldX < N && worldY >= 0 && worldY < N) {
          const building = getBuildingAt(worldX, worldY);
          
          if (building) {
            selection = building;
            inpX.value = building.x;
            inpY.value = building.y;
          } else {
            selection = { x: worldX, y: worldY };
            inpX.value = worldX;
            inpY.value = worldY;
          }
        }
      }
    }
    
    if (e.touches.length<2) touchMode = null;
  });
  
  function getChunkLevelForZoom(pct) {
    if (pct <= 10) return 3;
    if (pct <= 20) return 2;
    if (pct <= 40) return 1;
    if (pct <= 80) return 0;
    return -1;
  }

  function mainLoop(now) {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const [centerX, centerY] = screenToWorld(canvas.width/2, canvas.height/2);
    centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
    
    const pct = Math.round((cam.scale / baseScale) * 100);
    zoomLevelEl.textContent = `Zoom: ${pct}%`;
    
    if (pct > zoomSlider.max) {
      zoomSlider.max = pct;
    }
    zoomSlider.value = pct;
    
    tileCount = 0;

    ctx.save();
    ctx.setTransform(cam.scale,0,0,cam.scale,cam.x,cam.y);
    
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = strokeW;
    
    const shouldDrawBorders = pct > 40;
    
    const [tl_x, tl_y] = screenToWorld(0, 0);
    const [tr_x, tr_y] = screenToWorld(canvas.width, 0);
    const [bl_x, bl_y] = screenToWorld(0, canvas.height);
    const [br_x, br_y] = screenToWorld(canvas.width, canvas.height);

    const buffer = 2;
    const viewBounds = {
      minX: Math.min(tl_x, tr_x, bl_x, br_x) - buffer,
      maxX: Math.max(tl_x, tr_x, bl_x, br_x) + buffer,
      minY: Math.min(tl_y, tr_y, bl_y, br_y) - buffer,
      maxY: Math.max(tl_y, tr_y, bl_y, br_y) + buffer,
    };

    const chunkLevel = getChunkLevelForZoom(pct);
    
    if (chunkLevel === -1) {
      const minSum = Math.floor(viewBounds.minX + viewBounds.minY);
      const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);

      for (let sum = minSum; sum <= maxSum; sum++) {
        const startX = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY)));
        const endX = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));

        for (let x = startX; x <= endX; x++) {
            const y = sum - x;
            if (x < 0 || x >= N || y < 0 || y >= N) continue;
            if (!getBuildingAt(x, y)) drawTile(x, y, shouldDrawBorders);
        }
      }
    } else {
      const chunksToDraw = chunkLevels[chunkLevel];
      const chunkSize = Math.pow(2, chunkLevel + 1);

      const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize;
      const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
      const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize;
      const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
      
      for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
        for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
            const chunk = chunksToDraw.get(`${x},${y}`);
            if (chunk) {
                drawChunk(chunk, shouldDrawBorders);
            }
        }
      }
    }

    ctx.fillStyle = '#444';
    baseMap.unoccupiableTiles.forEach(([x,y])=>{
      if (getBuildingAt(x, y)) return;
      if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
      const [sx,sy] = worldToScreen(x,y);
      ctx.beginPath();
      ctx.moveTo(sx, sy - tileH/2);
      ctx.lineTo(sx + tileW/2, sy);
      ctx.lineTo(sx, sy + tileH/2);
      ctx.lineTo(sx - tileW/2, sy);
      ctx.closePath();
      ctx.fill();
    });

    const allBuildings = [...baseMap.defaultBuildings, ...userBuildings];
    const visibleBuildings = allBuildings.filter(b => 
        !(b.x > viewBounds.maxX || b.x + b.w < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h < viewBounds.minY)
    );

    if (chunkLevel !== -1) {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      
      visibleBuildings.forEach(b => {
        const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
        const bottomTile = { x: x0, y: y0 };
        const rightTile  = { x: x0 + w - 1, y: y0 };
        const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
        const leftTile   = { x: x0, y: y0 + h - 1 };
        const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
        const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
        const [stx, sty] = worldToScreen(topTile.x, topTile.y);
        const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);
        const p_bottom = { x: sbx, y: sby + tileH/2 };
        const p_right  = { x: srx + tileW/2, y: sry };
        const p_top    = { x: stx, y: sty - tileH/2 };
        const p_left   = { x: slx - tileW/2, y: sly };
        
        ctx.beginPath();
        ctx.moveTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_right.x,  p_right.y);
        ctx.lineTo(p_top.x,    p_top.y);
        ctx.lineTo(p_left.x,   p_left.y);
        ctx.closePath();
        
        ctx.fillStyle = '#000';
        ctx.fill();
      });
      ctx.restore();
    }
    
    // CRITICAL FIX: The loop to draw the buildings was missing. It is now restored.
    visibleBuildings.forEach(b => {
        drawBuildingFootprint(b, null, shouldDrawBorders);
    });

    if (selection) {
      if (selection.w) {
        drawBuildingFootprint(selection, selectionColor, true);
      } else {
        const [sx, sy] = worldToScreen(selection.x, selection.y);
        ctx.beginPath();
        ctx.moveTo(sx, sy - tileH/2);
        ctx.lineTo(sx + tileW/2, sy);
        ctx.lineTo(sx, sy + tileH/2);
        ctx.lineTo(sx - tileW/2, sy);
        ctx.closePath();
        ctx.strokeStyle = selectionColor;
        ctx.lineWidth = strokeW * 1.5;
        ctx.stroke();
      }
    }
    ctx.restore();

    const dt  = now - lastFrame;
    lastFrame = now;
    lastFPS   = Math.round(1000/dt);
    lastTiles = tileCount;
    
    if (!mainLoop.t0) mainLoop.t0 = now;
    if (now - mainLoop.t0 > 500) {
      statsFPSEl.textContent   = `FPS:   ${lastFPS}`;
      statsTilesEl.textContent = `Tiles: ${lastTiles}`;
      mainLoop.t0 = now;
    }
    
    requestAnimationFrame(mainLoop);
  }
  </script>
</body>
</html>