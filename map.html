<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* --- BASE STYLES --- */
    body {
      margin: 0;
      background: #111;
      overflow: hidden;
      -webkit-user-select: none;
      user-select: none;
    }

    canvas {
      display: block;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    /* --- LAYOUT CONTAINERS --- */
    #settingsContainer {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      width: 210px;
      text-align: right;
    }

    #zoomControlsContainer {
      position: absolute;
      left: 1px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      z-index: 10;
      color: #fff;
      font-family: sans-serif;
      width: 100px;
    }

    #searchControls {
      position: fixed;
      bottom: 45px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 10px;
      border-radius: 4px;
      width: auto;
      box-sizing: border-box;
      white-space: nowrap;
    }

    #centerTile {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      -webkit-user-select: none;
      user-select: none;
      z-index: 10;
    }

    #minimapContainer {
      position: absolute;
      top: 10px;
      margin-top: 40px;
      right: 10px;
      z-index: 900;
      transition: margin-top 0.3s ease-out;
      width: 352px;
    }

    #versionDisplay {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.5);
      font-family: sans-serif;
      font-size: 12px;
      user-select: none;
      z-index: 10;
    }

    /* --- COMPONENT STYLES --- */
    #settingsBtn {
      margin-bottom: 5px;
      padding: 6px 10px;
    }

    #settingsPanel {
      color: #fff;
      font-family: sans-serif;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 4px;
      max-height: 0;
      padding: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out, padding 0.3s ease-out;
      text-align: left;
    }

    #settingsPanel.open {
      max-height: 500px;
      padding: 8px;
    }

    #settingsPanel input[type="checkbox"],
    #settingsPanel select {
      vertical-align: middle;
    }

    #settingsPanel>div {
      margin-top: 4px;
      text-align: left;
    }

    #settingsPanel>hr {
      border: none;
      border-top: 1px solid #444;
      margin: 8px 0;
    }

    #settingsPanel h4 {
      margin: 6px 0 2px;
      font-size: 13px;
      color: #aaa;
      text-transform: uppercase;
      text-align: left;
    }

    #infoBtn,
    #statsBtn {
      margin-top: 6px;
      -webkit-user-select: none;
      user-select: none;
    }

    #infoPanel,
    #statsPanel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      margin-top: 6px;
      background: rgba(58, 55, 55, 0.85);
      padding: 0 6px;
      border-radius: 4px;
      font-size: 13px;
      color: #ddd;
      text-align: left;
    }

    #infoPanel.open {
      max-height: 160px;
    }

    #statsPanel.open {
      max-height: 120px;
    }

    #infoPanel h4 {
      margin: 6px 0 4px;
      color: #fff;
      text-transform: none;
    }

    #infoPanel ul {
      padding-left: 16px;
      margin: 0
    }

    #infoPanel li {
      margin-bottom: 4px;
    }

    #statsPanel div {
      margin: 4px 0;
      color: #fff;
    }

    #zoomControlsContainer button {
      -webkit-user-select: none;
      user-select: none;
      margin: 0;
      width: 60px;
    }

    #zoomPresetSelect {
      order: 4;
      width: 60px;
      -webkit-user-select: none;
      user-select: none;
    }

    #zoomControlsContainer #zoomInc {
      order: 1;
    }

    #zoomControlsContainer #sliderWrapper {
      order: 2;
      position: relative;
    }

    #zoomControlsContainer #zoomDec {
      order: 3;
    }

    #zoomControlsContainer #zoomLevel {
      order: 5;
      font-size: 14px;
      margin-top: 5px;
    }

    #zoomSlider {
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr;
      height: 65vh;
      max-height: 65vh;
      width: auto;
      margin: 0;
    }

    #floatingZoomLabel {
      position: absolute;
      display: none;
      left: 25px;
      background-color: #0b508f;
      color: white;
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 13px;
      pointer-events: none;
      transform: translateY(-50%);
    }

    #searchControls h4 {
      margin: 0 0 4px;
      font-size: 13px;
      color: #aaa;
      text-transform: uppercase;
      text-align: left;
    }

    #searchControls>div {
      text-align: left;
    }

    #searchControls input {
      width: 60px;
    }

    #searchControls button {
      margin: 2px 0 2px 4px;
      -webkit-user-select: none;
      user-select: none;
    }

    label.coords-label {
      font-size: 13px;
      vertical-align: middle;
      user-select: none;
    }

    #minimapToggleBtn {
      display: block;
      width: 100%;
      padding: 0;
      line-height: 1.5;
      background-color: #282828;
      color: #bbb;
      border: 1px solid #444;
      font-family: sans-serif;
      font-size: 13px;
      text-align: center;
      cursor: pointer;
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
    }

    #minimapCanvas {
      width: 350px;
      height: 300px;
      border: 1px solid #444;
      border-top: none;
      background-color: rgba(0, 0, 0, 0.5);
      display: block;
    }

    #minimapCanvas.hidden {
      display: none;
    }

    /* --- MODAL STYLES --- */
    #modalOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 999;
    }

    #patchNotesModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 500px;
      background: #2c2c2c;
      color: #eee;
      border-radius: 8px;
      z-index: 1000;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .patch-notes-header {
      padding: 15px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .patch-notes-header h3 {
      margin: 0;
    }

    .patch-notes-header .close-btn {
      background: none;
      border: none;
      color: #ccc;
      font-size: 24px;
      cursor: pointer;
    }

    .patch-notes-body {
      padding: 15px;
      max-height: 60vh;
      overflow-y: auto;
    }

    .patch-notes-body ul {
      padding-left: 20px;
      margin: 0;
    }

    .patch-notes-body li {
      margin-bottom: 8px;
    }

    .patch-notes-footer {
      padding: 10px 15px;
      border-top: 1px solid #444;
      background: #333;
      border-radius: 0 0 8px 8px;
    }

    .patch-notes-footer label {
      user-select: none;
      font-size: 14px;
    }

    /* --- RESPONSIVE STYLES --- */
    @media (max-width: 768px) {
      #minimapContainer,
      #settingsContainer {
        display: none;
      }
    }

    @media (max-width: 768px) and (orientation: portrait) {
      #zoomControlsContainer {
        gap: 15px;
      }

      #zoomSlider {
        height: 70vh;
      }

      #searchControls {
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
      }

      #centerTile {
        display: none;
      }

      #versionDisplay {
        bottom: 5px;
        right: 5px;
        font-size: 10px;
      }
    }

    @media (max-height: 500px) and (orientation: landscape) {
      #zoomControlsContainer {
        left: 0;
        right: 0;
        top: auto;
        bottom: 0;
        transform: none;
        width: 100%;
        height: 60px;
        padding: 0 10px;
        box-sizing: border-box;
        flex-direction: row;
        justify-content: space-between;
        background: rgba(0, 0, 0, 0.7);
      }

      #sliderWrapper {
        flex-grow: 1;
        margin: 0 10px;
      }

      #zoomSlider {
        -webkit-appearance: none;
        appearance: none;
        writing-mode: horizontal-tb;
        height: 25px;
        width: 100%;
        max-height: none;
      }

      #zoomPresetSelect {
        flex-direction: row;
      }

      #zoomLevel {
        font-size: 14px;
      }

      #searchControls,
      #centerTile {
        display: none;
      }

      #versionDisplay {
        bottom: 65px;
      }
    }
  </style>
</head>
<body>
  <!-- TOP RIGHT UI -->
  <div id="settingsContainer">
    <button id="settingsBtn">⚙️ Settings</button>
    <div id="settingsPanel">
      <h4>Display</h4>
      <div>
        <input type="checkbox" id="gridlinesToggle">
        <label for="gridlinesToggle" class="coords-label">Show Gridlines</label>
      </div>
      <div>
        <input type="checkbox" id="coordsToggle">
        <label for="coordsToggle" class="coords-label">Show Coords >80%</label>
      </div>
      <div>
        <input type="checkbox" id="allianceRssToggle">
        <label for="allianceRssToggle" class="coords-label">Show Alliance RSS</label>
      </div>
      <div>
        <input type="checkbox" id="allianceRssAlwaysVisibleToggle">
        <label for="allianceRssAlwaysVisibleToggle" class="coords-label">Always Show RSS</label>
      </div>
      <hr>
      <h4>Performance</h4>
      <div>
        <label for="tileDetailSelect" class="coords-label">Merge tiles at zoom level:</label>
        <select id="tileDetailSelect">
          <option value="19">20% (Ultra)</option>
          <option value="39">40% (Super)</option>
          <option value="49">50% (High)</option>
          <option value="59">60% (Medium)</option>
          <option value="69">70% (Low)</option>
          <option value="79">80% (Very Low)</option>
        </select>
      </div>
      <hr>
      <div>
        <button id="infoBtn" title="Show controls">ℹ️</button>
        <button id="statsBtn" title="Toggle stats">📊</button>
      </div>
      <div id="infoPanel">
        <h4>Controls</h4>
        <ul>
          <li><strong>Pan</strong>: drag / one-finger touch</li>
          <li><strong>Zoom</strong>: wheel, slider, +/–, q/e, dblclick</li>
          <li><strong>Pinch</strong>: two-finger touch</li>
          <li><strong>Keyboard</strong>: arrows to pan</li>
        </ul>
        <button id="patchNotesBtn">Patch Notes</button>
      </div>
      <div id="statsPanel">
        <div id="statsFPS">FPS: –</div>
        <div id="statsTiles">Tiles: –</div>
      </div>
    </div>
  </div>
  <div id="minimapContainer">
    <button id="minimapToggleBtn" title="Toggle Minimap">Hide Minimap</button>
    <canvas id="minimapCanvas"></canvas>
  </div>

  <!-- LEFT & BOTTOM UI -->
  <div id="zoomControlsContainer">
    <button id="zoomInc">+</button>
    <div id="sliderWrapper">
      <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
      <div id="floatingZoomLabel"></div>
    </div>
    <button id="zoomDec">−</button>
    <select id="zoomPresetSelect">
      <option value="Fit" selected>Fit</option>
      <option value="5">5%</option>
      <option value="10">10%</option>
      <option value="15">15%</option>
      <option value="20">20%</option>
      <option value="40">40%</option>
      <option value="60">60%</option>
      <option value="80">80%</option>
      <option value="100">100%</option>
    </select>
    <div id="zoomLevel">Zoom: 100%</div>
  </div>
  <div id="searchControls">
    <h4>Go To</h4>
    <div>
      X: <input id="inpX" type="number" min="0" max="1199" value="0">
      Y: <input id="inpY" type="number" min="0" max="1199" value="0">
      <button id="btnGo">Go</button>
    </div>
  </div>
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>

  <!-- MODALS -->
  <div id="modalOverlay"></div>
  <div id="patchNotesModal">
    <div class="patch-notes-header">
      <h3>What's New?!</h3>
      <button id="closePatchNotesBtn" class="close-btn">×</button>
    </div>
    <div class="patch-notes-body" id="patchNotesBody">
    </div>
    <div class.patch-notes-footer">
      <input type="checkbox" id="hidePatchNotesCheckbox">
      <label for="hidePatchNotesCheckbox">Do not show this again until the next update.</label>
    </div>
  </div>

  <!-- MAIN CANVAS -->
  <canvas id="map"></canvas>

  <script>
    const KingshotPlanner = {
      // --- TWEAKABLE SETTINGS ---
      config: {
        CURRENT_VERSION: '0.2.9.1',
        N: 1200,
        tileW: 10,
        tileH: 10,
        strokeW: 0.3,
        borderColor: '#000',
        textColor: '#fff',
        maxPct: 250,
        selectionColor: '#ff0',
        pingColor: '#fff',
        pingDuration: 500,
        baseScale: 5,
        biomeColors: {
          fertile: 'rgb(109, 159, 62)',
          plains: 'rgb(158, 180, 103)',
          badlands: 'rgb(191, 208, 152)'
        },
        biomeRegions: {
          fertile: { x1: 480, y1: 480, x2: 719, y2: 719 },
          plains: { x1: 320, y1: 320, x2: 879, y2: 879 },
          badlands: { x1: 0, y1: 0, x2: 1199, y2: 1199 }
        },
        ALLIANCE_RSS_STYLES: {
          wood: { displayName: 'Wood', fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
          food: { displayName: 'Food', fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
          stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
          iron: { displayName: 'Iron', fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
        },
        minimap: {
          width: 350,
          height: 300,
          padding: 5,
          bgColor: 'rgba(40,40,40,0.8)',
          viewportFillColor: 'rgba(255, 255, 255, 0.2)',
          viewportBorderColor: 'rgba(255, 255, 255, 0.85)',
          kingCastleColor: 'rgba(255,215,0,0.9)',
          fortressColor: 'rgba(178,34,34,1)',
          sanctuaryColor: 'rgba(65,105,225,1)',
          zoomFactorMin: 1.0, // When main map is zoomed out, minimap shows the whole map (1x)
          zoomFactorMax: 12.0, // When main map is fully zoomed in, minimap zooms in by this factor
          mainMapZoomThresholdForMinimapZoom: 0.08 // Main map zoom % at which minimap starts zooming
        }
      },

      // --- APPLICATION STATE ---
      state: {
        baseMap: { unoccupiableTiles: [], defaultBuildings: [] },
        patchNotes: '',
        allBuildings: [],
        buildingMap: new Map(),
        chunkLevels: [],
        userBuildings: [],
        cam: { x: 0, y: 0, scale: 1 },
        lastFrame: 0,
        tileCount: 0,
        lastFPS: 0,
        lastTiles: 0,
        selection: null,
        minFitScale: 0.1,
        isInitialLoad: true,
        touchStartTime: 0,
        dragging: false,
        lastX: 0,
        lastY: 0,
        clickStartX: 0,
        clickStartY: 0,
        touchMode: null,
        startDist: 0,
        startScale: 1,
        pinchCenter: null,
        startCamX: 0,
        startCamY: 0,
        hideLabelTimeout: null,
        statsUpdateTime: 0,
        currentTileDetailThreshold: 50,
        isMinimapVisible: true,
        isMinimapDragging: false,
        minimapClickStartPos: { x: 0, y: 0 },
        minimapCam: { x: 0, y: 0, scale: 0.1 },
        animationId: null
      },

      // --- DOM REFERENCES ---
      dom: {
        canvas: null, ctx: null, inpX: null, inpY: null, btnGo: null,
        zoomLevelEl: null, zoomDecBtn: null, zoomIncBtn: null, zoomSlider: null,
        zoomPresetSelect: null, centerTileEl: null, infoBtn: null, infoPanel: null,
        statsBtn: null, statsPanel: null, statsFPSEl: null, statsTilesEl: null,
        coordsToggle: null, floatingZoomLabel: null, versionDisplay: null,
        patchNotesBtn: null, modalOverlay: null, patchNotesModal: null,
        patchNotesBody: null, closePatchNotesBtn: null, hidePatchNotesCheckbox: null,
        tileDetailSelect: null, gridlinesToggle: null, allianceRssToggle: null,
        allianceRssAlwaysVisibleToggle: null, settingsBtn: null, settingsPanel: null,
        minimapCanvas: null, minimapCtx: null, minimapContainer: null, minimapToggleBtn: null
      },

      // --- CORE INITIALIZATION ---
      init() {
        const self = this;
        this.dom.canvas = document.getElementById('map');
        if (!this.dom.canvas) { console.error("Fatal: Canvas element 'map' not found."); alert("Fatal Error: Canvas element not found. The application cannot start."); return; }
        this.dom.ctx = this.dom.canvas.getContext('2d');
        if (!this.dom.ctx) { console.error("Fatal: Could not get 2D rendering context for canvas."); alert("Fatal Error: Could not initialize 2D graphics. The application cannot start. Try a different browser or update your current one."); return; }
        this.dom.inpX = document.getElementById('inpX');
        this.dom.inpY = document.getElementById('inpY');
        this.dom.btnGo = document.getElementById('btnGo');
        this.dom.zoomLevelEl = document.getElementById('zoomLevel');
        this.dom.zoomDecBtn = document.getElementById('zoomDec');
        this.dom.zoomIncBtn = document.getElementById('zoomInc');
        this.dom.zoomSlider = document.getElementById('zoomSlider');
        this.dom.zoomPresetSelect = document.getElementById('zoomPresetSelect');
        this.dom.centerTileEl = document.getElementById('centerTile');
        this.dom.infoBtn = document.getElementById('infoBtn');
        this.dom.infoPanel = document.getElementById('infoPanel');
        this.dom.statsBtn = document.getElementById('statsBtn');
        this.dom.statsPanel = document.getElementById('statsPanel');
        this.dom.statsFPSEl = document.getElementById('statsFPS');
        this.dom.statsTilesEl = document.getElementById('statsTiles');
        this.dom.coordsToggle = document.getElementById('coordsToggle');
        this.dom.floatingZoomLabel = document.getElementById('floatingZoomLabel');
        this.dom.versionDisplay = document.getElementById('versionDisplay');
        this.dom.patchNotesBtn = document.getElementById('patchNotesBtn');
        this.dom.modalOverlay = document.getElementById('modalOverlay');
        this.dom.patchNotesModal = document.getElementById('patchNotesModal');
        this.dom.patchNotesBody = document.getElementById('patchNotesBody');
        this.dom.closePatchNotesBtn = document.getElementById('closePatchNotesBtn');
        this.dom.hidePatchNotesCheckbox = document.getElementById('hidePatchNotesCheckbox');
        this.dom.tileDetailSelect = document.getElementById('tileDetailSelect');
        this.dom.gridlinesToggle = document.getElementById('gridlinesToggle');
        this.dom.allianceRssToggle = document.getElementById('allianceRssToggle');
        this.dom.allianceRssAlwaysVisibleToggle = document.getElementById('allianceRssAlwaysVisibleToggle');
        this.dom.settingsBtn = document.getElementById('settingsBtn');
        this.dom.settingsPanel = document.getElementById('settingsPanel');
        this.dom.minimapContainer = document.getElementById('minimapContainer');
        this.dom.minimapToggleBtn = document.getElementById('minimapToggleBtn');
        this.dom.minimapCanvas = document.getElementById('minimapCanvas');
        if (this.dom.minimapCanvas) {
          this.dom.minimapCanvas.width = this.config.minimap.width * (window.devicePixelRatio || 1);
          this.dom.minimapCanvas.height = this.config.minimap.height * (window.devicePixelRatio || 1);
          this.dom.minimapCtx = this.dom.minimapCanvas.getContext('2d');
        } else { console.warn("Minimap canvas element not found."); }
        for (const key in this.dom) {
          if (this.dom[key] === null && !['ctx', 'canvas', 'minimapCtx', 'minimapCanvas'].includes(key) && this.dom.hasOwnProperty(key)) {
            console.warn(`DOM element for '${key}' not found.`);
          }
        }
        this.state.lastFrame = performance.now();
        Promise.all([
            fetch('baseMap.json').then(r => r.ok ? r.json() : Promise.resolve({ unoccupiableTiles: [], defaultBuildings: [] })),
            fetch('CHANGELOG.md').then(r => r.ok ? r.text() : Promise.resolve(''))
          ])
          .then(([baseMapData, changelogText]) => {
            Object.assign(self.state.baseMap, baseMapData);
            self.state.patchNotes = changelogText;
            self.preProcessBuildings();
            self.preCalculateChunks();
            self.initializeUI();
            self.resize();
            requestAnimationFrame(self.mainLoop.bind(self));
          })
          .catch(e => {
            console.error("Error during application initialization:", e);
            alert('Error loading essential application data or initializing. Check console for details.');
          });
      },

      initializeUI() {
        if (this.dom.infoBtn && this.dom.infoPanel) this.dom.infoBtn.addEventListener('click', () => this.dom.infoPanel.classList.toggle('open'));
        if (this.dom.statsBtn && this.dom.statsPanel) this.dom.statsBtn.addEventListener('click', () => this.dom.statsPanel.classList.toggle('open'));
        if (this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
        if (this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
        if (this.dom.closePatchNotesBtn) this.dom.closePatchNotesBtn.addEventListener('click', this.hidePatchNotes.bind(this));
        if (this.dom.modalOverlay) this.dom.modalOverlay.addEventListener('click', this.hidePatchNotes.bind(this));
        const lastSeenVersion = localStorage.getItem('lastSeenVersion');
        if (lastSeenVersion !== this.config.CURRENT_VERSION) { this.showPatchNotes(); }
        if (this.dom.tileDetailSelect) {
          const savedDetail = localStorage.getItem('mapTileDetail') || '50';
          this.dom.tileDetailSelect.value = savedDetail;
          this.state.currentTileDetailThreshold = parseInt(savedDetail, 10);
          this.dom.tileDetailSelect.addEventListener('change', () => {
            localStorage.setItem('mapTileDetail', this.dom.tileDetailSelect.value);
            this.state.currentTileDetailThreshold = parseInt(this.dom.tileDetailSelect.value, 10);
          });
        }
        if (this.dom.allianceRssAlwaysVisibleToggle) {
          const savedAlwaysVisible = localStorage.getItem('mapAlwaysShowRss') === 'true';
          this.dom.allianceRssAlwaysVisibleToggle.checked = savedAlwaysVisible;
          this.dom.allianceRssAlwaysVisibleToggle.addEventListener('change', () => localStorage.setItem('mapAlwaysShowRss', this.dom.allianceRssAlwaysVisibleToggle.checked));
        }
        if (this.dom.gridlinesToggle) {
          const savedGridlines = localStorage.getItem('mapShowGridlines') !== 'false';
          this.dom.gridlinesToggle.checked = savedGridlines;
          this.dom.gridlinesToggle.addEventListener('change', () => localStorage.setItem('mapShowGridlines', this.dom.gridlinesToggle.checked));
        }
        if (this.dom.allianceRssToggle) {
          const savedAllianceRss = localStorage.getItem('mapShowAllianceRss') !== 'false';
          this.dom.allianceRssToggle.checked = savedAllianceRss;
          this.dom.allianceRssToggle.addEventListener('change', () => localStorage.setItem('mapShowAllianceRss', this.dom.allianceRssToggle.checked));
        }
        if (this.dom.coordsToggle) {
          const savedCoords = localStorage.getItem('mapShowCoords') === 'true';
          this.dom.coordsToggle.checked = savedCoords;
          this.dom.coordsToggle.addEventListener('change', () => localStorage.setItem('mapShowCoords', this.dom.coordsToggle.checked));
        }
        if (this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
        if (this.dom.inpX && this.dom.inpY)[this.dom.inpX, this.dom.inpY].forEach(i => i.addEventListener('keydown', e => { if (e.key === 'Enter') this.doSearch(); }));
        if (this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-1));
        if (this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+1));
        if (this.dom.zoomPresetSelect) {
            this.dom.zoomPresetSelect.addEventListener('change', (e) => {
                const value = e.target.value;
                if (value === 'Fit') {
                    this.zoomToFit();
                } else {
                    const zoomVal = Number(value);
                    if (!isNaN(zoomVal)) {
                        const targetScale = (zoomVal / 100) * this.config.baseScale;
                        const cx = this.dom.canvas.width / 2;
                        const cy = this.dom.canvas.height / 2;
                        this.animateZoom(targetScale, cx, cy, 200);
                    }
                }
            });
        }
        if (this.dom.settingsBtn && this.dom.settingsPanel && this.dom.minimapContainer) {
          const panel = this.dom.settingsPanel; const minimap = this.dom.minimapContainer; const settingsBtn = this.dom.settingsBtn;
          const originalMinimapMarginTop = getComputedStyle(minimap).marginTop; const gap = 10;
          this.dom.settingsBtn.addEventListener('click', () => {
            const isOpening = !panel.classList.contains('open');
            if (isOpening) { const panelContentHeight = panel.scrollHeight + 16; const settingsButtonHeight = settingsBtn.offsetHeight; const settingsButtonMarginBottom = parseInt(getComputedStyle(settingsBtn).marginBottom, 10) || 0; const newMarginTop = settingsButtonHeight + settingsButtonMarginBottom + panelContentHeight + gap; minimap.style.marginTop = `${newMarginTop}px`; panel.classList.add('open'); } 
            else { minimap.style.marginTop = originalMinimapMarginTop; panel.classList.remove('open'); }
          });
        }
        if (this.dom.minimapToggleBtn && this.dom.minimapCanvas) {
          this.dom.minimapCanvas.classList.toggle('hidden', !this.state.isMinimapVisible);
          this.dom.minimapToggleBtn.textContent = this.state.isMinimapVisible ? 'Hide Minimap' : 'Show Minimap';
          this.dom.minimapToggleBtn.addEventListener('click', () => {
            this.state.isMinimapVisible = !this.state.isMinimapVisible;
            this.dom.minimapCanvas.classList.toggle('hidden', !this.state.isMinimapVisible);
            this.dom.minimapToggleBtn.textContent = this.state.isMinimapVisible ? 'Hide Minimap' : 'Show Minimap';
          });
        }
        if (this.dom.zoomSlider) {
          this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));
          this.dom.zoomSlider.addEventListener('mousedown', () => { clearTimeout(this.state.hideLabelTimeout); this.updateFloatingZoomLabel(); });
        }
        window.addEventListener('resize', this.resize.bind(this));
        window.addEventListener('mousemove', this.handleMouseMove.bind(this));
        window.addEventListener('mouseup', () => { this.state.dragging = false; });
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
        this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
        this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
        this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
        this.dom.canvas.addEventListener('contextmenu', e => e.preventDefault());
        this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
        this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        if (this.dom.minimapCanvas) {
          this.dom.minimapCanvas.addEventListener('mousedown', this.handleMinimapMouseDown.bind(this));
          this.dom.minimapCanvas.addEventListener('mousemove', this.handleMinimapMouseMove.bind(this));
          this.dom.minimapCanvas.addEventListener('mouseleave', this.handleMinimapMouseUp.bind(this));
          window.addEventListener('mouseup', this.handleMinimapMouseUp.bind(this));
        }
      },

      preProcessBuildings() {
        let buildings = [...(this.state.baseMap.defaultBuildings || []), ...(this.state.userBuildings || [])];
        if (this.state.baseMap.allianceRssBuildings) {
          const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
            const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
            return { x: rss.x, y: rss.y, w: 2, h: 2, displayName: style.displayName, fillColor: style.fillColor, borderColor: style.borderColor, displayCoordinates: false, isRss: true };
          });
          buildings = buildings.concat(formattedRssBuildings);
        }
        this.state.allBuildings = buildings;
        this.state.buildingMap.clear();
        for (const b of this.state.allBuildings) {
          if (typeof b.w === 'number' && typeof b.h === 'number') {
            for (let dx = 0; dx < b.w; dx++) {
              for (let dy = 0; dy < b.h; dy++) { this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b); }
            }
          }
        }
      },

      preCalculateChunks() {
        const numLevels = 4; this.state.chunkLevels = [];
        for (let level = 0; level < numLevels; level++) {
          const chunkSize = Math.pow(2, level + 1); const levelMap = new Map();
          for (let x = 0; x < this.config.N; x += chunkSize) {
            for (let y = 0; y < this.config.N; y += chunkSize) {
              const biome = this.getBiomeForTile(x, y); levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
            }
          }
          this.state.chunkLevels.push(levelMap);
        }
      },

      worldToScreen(x, y) { return [(x - y) * (this.config.tileW / 2), -(x + y) * (this.config.tileH / 2)]; },
      screenToWorld(sx, sy) {
        const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
        const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
        if (tileW_half === 0 || tileH_half === 0 || scale === 0) { return [0, 0]; }
        const lx = (sx - this.state.cam.x) / scale; const ly = (sy - this.state.cam.y) / scale;
        const u = lx / tileW_half; const v = -ly / tileH_half;
        return [Math.round((u + v) / 2), Math.round((v - u) / 2)];
      },
      getBuildingAt(x, y) { return this.state.buildingMap.get(`${x},${y}`) || null; },
      getBiomeForTile(x, y) {
        const { fertile, plains } = this.config.biomeRegions;
        if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
        if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
        return 'badlands';
      },
      getChunkLevelForZoom(pct) {
        if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100;
        const detailThreshold = this.state.currentTileDetailThreshold;
        if (pct > detailThreshold) return -1; if (pct > detailThreshold / 2) return 0;
        if (pct > detailThreshold / 5) return 1; if (pct > detailThreshold / 10) return 2;
        return 3;
      },

      clampCamera() {
        const s = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const canvasW = this.dom.canvas.width; const canvasH = this.dom.canvas.height;
        const N = this.config.N; const tileW = this.config.tileW; const tileH = this.config.tileH;
        
        const mapScreenW = (N - 1) * tileW * s;
        if (mapScreenW > canvasW) {
            const minCamX = canvasW - mapScreenW / 2; const maxCamX = mapScreenW / 2;
            this.state.cam.x = Math.max(minCamX, Math.min(maxCamX, this.state.cam.x));
        } else { this.state.cam.x = canvasW / 2; }

        const mapScreenH = (N - 1) * tileH * s;
        if (mapScreenH > canvasH) {
            const topOfMapY = mapScreenH; const bottomOfMapY = canvasH;
            this.state.cam.y = Math.max(bottomOfMapY, Math.min(topOfMapY, this.state.cam.y));
        } else {
            // Correctly center the map vertically when it's smaller than the canvas
            this.state.cam.y = canvasH / 2 + mapScreenH / 2;
        }
        
        if (isNaN(this.state.cam.x)) this.state.cam.x = canvasW / 2;
        if (isNaN(this.state.cam.y)) this.state.cam.y = canvasH / 2;
      },
      
      changeZoomBy(delta) {
        // Get the current zoom percentage, rounded to what the user sees
        let currentPct = Math.round((this.state.cam.scale / this.config.baseScale) * 100);
        if (isNaN(currentPct)) {
          currentPct = Math.round((this.state.minFitScale / this.config.baseScale) * 100);
        }
        
        // Calculate the target percentage by adding the delta (+1 or -1)
        const targetPct = currentPct + delta;

        // Convert the target percentage back to a scale value
        let targetScale = (targetPct / 100) * this.config.baseScale;
        
        // Clamp the new scale to the allowed min/max zoom levels
        const minScale = this.state.minFitScale;
        const maxScale = (this.config.maxPct / 100) * this.config.baseScale;
        targetScale = Math.max(minScale, Math.min(maxScale, targetScale));

        if (!isNaN(targetScale)) {
          this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 150);
        }
      },

      animateZoom(targetScale, anchorX, anchorY, duration = 150) {
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
        const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const startX = this.state.cam.x; const startY = this.state.cam.y;
        const start = performance.now();
        if (startScale === 0) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
        const wx = (anchorX - startX) / startScale; const wy = (anchorY - startY) / startScale;
        if (isNaN(wx) || isNaN(wy)) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
        const step = (now) => {
          const t = duration === 0 ? 1 : Math.min(1, (now - start) / duration);
          const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          this.state.cam.scale = startScale + (targetScale - startScale) * k;
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
          this.state.cam.x = anchorX - wx * this.state.cam.scale;
          this.state.cam.y = anchorY - wy * this.state.cam.scale;
          this.clampCamera();
          if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
          else { this.state.animationId = null; }
        };
        this.state.animationId = requestAnimationFrame(step);
      },

      animatePanZoom(targetScale, targetX, targetY, duration = 300) {
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
        const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const startX = this.state.cam.x; const startY = this.state.cam.y;
        const start = performance.now();
        const step = (now) => {
          const t = Math.min(1, (now - start) / duration);
          const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          this.state.cam.scale = startScale + (targetScale - startScale) * k;
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
          this.state.cam.x = startX + (targetX - startX) * k;
          this.state.cam.y = startY + (targetY - startY) * k;
          this.clampCamera();
          if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
          else { this.state.animationId = null; }
        };
        this.state.animationId = requestAnimationFrame(step);
      },

      zoomToFit() {
        const targetScale = this.state.minFitScale;
        const targetCamX = this.dom.canvas.width / 2;
        // Correctly calculate the Y position to center the isometric diamond
        const targetCamY = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * targetScale;
        this.animatePanZoom(targetScale, targetCamX, targetCamY, 200);
      },
      showPatchNotes() {
        if (!this.dom.patchNotesBody || !this.dom.modalOverlay || !this.dom.patchNotesModal) return;
        
        if (typeof marked !== 'undefined') {
          marked.setOptions({ gfm: true, breaks: true, sanitize: false });
        } else { 
          console.warn("marked.js library not loaded. Markdown processing will be basic.");
        }
        
        let changelogText = this.state.patchNotes || '';
        
        if (!changelogText.trim()) {
          this.dom.patchNotesBody.innerHTML = `<p>No changelog is available at this time.</p>`;
        } else {
            // To make it cleaner, remove the main "# Changelog" title from the modal
            const firstVersionIndex = changelogText.indexOf('## [');
            if (firstVersionIndex !== -1) {
                changelogText = changelogText.substring(firstVersionIndex);
            }
            this.dom.patchNotesBody.innerHTML = marked.parse(changelogText);
        }
        
        this.dom.modalOverlay.style.display = 'block';
        this.dom.patchNotesModal.style.display = 'block';
      },
      hidePatchNotes() {
        if (!this.dom.modalOverlay || !this.dom.patchNotesModal) return;
        if (this.dom.hidePatchNotesCheckbox && this.dom.hidePatchNotesCheckbox.checked) {
          localStorage.setItem('lastSeenVersion', this.config.CURRENT_VERSION);
        }
        this.dom.modalOverlay.style.display = 'none';
        this.dom.patchNotesModal.style.display = 'none';
      },
      
      handleMinimapMouseDown(e) {
        this.state.isMinimapDragging = true;
        this.state.minimapClickStartPos = { x: e.clientX, y: e.clientY };
        this.state.startCamX = this.state.cam.x; this.state.startCamY = this.state.cam.y;
      },
      handleMinimapMouseMove(e) {
        if (!this.state.isMinimapDragging) return;
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }

        // Teleport-drag: Instantly center the main view on the world coordinate under the mouse.
        const rect = this.dom.minimapCanvas.getBoundingClientRect();
        const minimapCam = this.state.minimapCam;
        
        const clickScreenX = (e.clientX - rect.left); 
        const clickScreenY = (e.clientY - rect.top);

        const lx = (clickScreenX - minimapCam.x) / minimapCam.scale;
        const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
        
        const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
        const u = lx / tileW_half; const v = -ly / tileH_half;
        const world_x = (u + v) / 2; const world_y = (v - u) / 2;
        
        const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
        
        this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale;
        this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
        this.clampCamera();
      },
      handleMinimapMouseUp(e) {
        if (!this.state.isMinimapDragging) return;
        this.state.isMinimapDragging = false;
        
        const dist = Math.hypot(e.clientX - this.state.minimapClickStartPos.x, e.clientY - this.state.minimapClickStartPos.y);

        if (dist < 5) {
          const rect = this.dom.minimapCanvas.getBoundingClientRect();
          const minimapCam = this.state.minimapCam;
          
          const clickScreenX = (e.clientX - rect.left); const clickScreenY = (e.clientY - rect.top);

          const lx = (clickScreenX - minimapCam.x) / minimapCam.scale;
          const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
          
          const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
          const u = lx / tileW_half; const v = -ly / tileH_half;
          const world_x = (u + v) / 2; const world_y = (v - u) / 2;
          
          const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
          const targetCamX = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale;
          const targetCamY = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
          this.animatePanZoom(this.state.cam.scale, targetCamX, targetCamY, 200);
        }
      },
      handleMouseDown(e) {
        if (e.button === 0) {
          this.state.dragging = true; this.state.lastX = e.clientX; this.state.lastY = e.clientY;
          this.state.clickStartX = e.clientX; this.state.clickStartY = e.clientY;
        }
      },
      handleMouseMove(e) {
        if (!this.state.dragging) return;
        // "Content Grab" - camera moves in the opposite direction of the mouse.
        this.state.cam.x += e.clientX - this.state.lastX;
        this.state.cam.y += e.clientY - this.state.lastY;
        this.state.lastX = e.clientX;
        this.state.lastY = e.clientY;
        this.clampCamera();
      },
      handleCanvasClick(e) {
        const dist = Math.hypot(e.clientX - this.state.clickStartX, e.clientY - this.state.clickStartY);
        if (dist > 5) return; 
        const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
        if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
          const building = this.getBuildingAt(worldX, worldY);
          this.state.selection = building || { x: worldX, y: worldY };
          if (this.state.selection) this.state.selection.pingStart = performance.now();
          if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
          if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
        }
      },
      handleWheel(e) {
        e.preventDefault(); const factor = e.deltaY < 0 ? 1.2 : 0.8;
        let targetScale = this.state.cam.scale * factor;
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
        this.animateZoom(targetScale, e.offsetX, e.offsetY, 150);
      },
      handleDblClick(e) {
        e.preventDefault(); const factor = e.button === 2 ? 0.5 : 2.0;
        let targetScale = this.state.cam.scale * factor;
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
        this.animateZoom(targetScale, e.offsetX, e.offsetY, 150);
      },
      handleZoomSlider() {
        if (!this.dom.zoomSlider) return; const pct = Number(this.dom.zoomSlider.value);
        let targetScale = (pct / 100) * this.config.baseScale;
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
        this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 0);
        this.updateFloatingZoomLabel();
      },
      handleKeyDown(e) {
        if (e.target && e.target.tagName === 'INPUT') return;
        switch (e.key) {
          case '+': case '=': this.changeZoomBy(+1); break;
          case '-':           this.changeZoomBy(-1); break;
          case 'q':           this.changeZoomBy(+1); break;
          case 'e':           this.changeZoomBy(-1); break;
          case 'ArrowUp':     this.state.cam.y += this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowDown':   this.state.cam.y -= this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowLeft':   this.state.cam.x += this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowRight':  this.state.cam.x -= this.config.tileW * 5; this.clampCamera(); break;
        }
      },
      handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
          this.state.touchMode = 'pan'; const t = e.touches[0]; this.state.lastX = t.clientX; this.state.lastY = t.clientY;
          this.state.clickStartX = t.clientX; this.state.clickStartY = t.clientY; this.state.touchStartTime = performance.now();
        } else if (e.touches.length === 2) {
          this.state.touchMode = 'pinch'; const [a, b] = e.touches;
          this.state.startDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          this.state.startScale = this.state.cam.scale; this.state.pinchCenter = { x: (a.clientX + b.clientX) / 2, y: (a.clientY + b.clientY) / 2 };
          this.state.startCamX = this.state.cam.x; this.state.startCamY = this.state.cam.y;
        }
      },
      handleTouchMove(e) {
        e.preventDefault();
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
        if (this.state.touchMode === 'pan' && e.touches.length === 1) {
          const t = e.touches[0];
          // Invert drag direction to match mouse "content drag"
          this.state.cam.x -= t.clientX - this.state.lastX;
          this.state.cam.y -= t.clientY - this.state.lastY;
          this.state.lastX = t.clientX; this.state.lastY = t.clientY;
          this.clampCamera();
        } else if (this.state.touchMode === 'pinch' && e.touches.length === 2) {
          const [a, b] = e.touches; const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          if (this.state.startDist === 0) return;
          let newScale = this.state.startScale * (dist / this.state.startDist);
          this.state.cam.scale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, newScale));
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.startScale;
          const safeStartScale = (this.state.startScale === 0 || isNaN(this.state.startScale)) ? this.state.minFitScale : this.state.startScale;
          const wx = (this.state.pinchCenter.x - this.state.startCamX) / safeStartScale; const wy = (this.state.pinchCenter.y - this.state.startCamY) / safeStartScale;
          if (isNaN(wx) || isNaN(wy)) { this.state.cam.x = this.state.startCamX; this.state.cam.y = this.state.startCamY; } 
          else { this.state.cam.x = this.state.pinchCenter.x - wx * this.state.cam.scale; this.state.cam.y = this.state.pinchCenter.y - wy * this.state.cam.scale; }
          this.clampCamera();
        }
      },
      handleTouchEnd(e) {
        if (this.state.touchMode === 'pan' && e.changedTouches.length === 1) {
          const t = e.changedTouches[0]; const dist = Math.hypot(t.clientX - this.state.clickStartX, t.clientY - this.state.clickStartY);
          const duration = performance.now() - this.state.touchStartTime;
          if (duration < 200 && dist < 10) {
            const [worldX, worldY] = this.screenToWorld(t.clientX, t.clientY);
            if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
              const building = this.getBuildingAt(worldX, worldY);
              this.state.selection = building || { x: worldX, y: worldY };
              if (this.state.selection) this.state.selection.pingStart = performance.now();
              if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
              if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
            }
          }
        }
        if (e.touches.length < 2) this.state.touchMode = null;
      },

      resize() {
        this.dom.canvas.width = window.innerWidth; this.dom.canvas.height = window.innerHeight;
        if (this.dom.minimapCanvas && this.config.minimap) {
          const dpr = window.devicePixelRatio || 1;
          this.dom.minimapCanvas.width = this.config.minimap.width * dpr;
          this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
        }
        const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
        const mapTotalHeight = (this.config.N - 1) * this.config.tileH;
        const scaleX = this.dom.canvas.width / mapTotalWidth;
        const scaleY = this.dom.canvas.height / mapTotalHeight;
        this.state.minFitScale = Math.max(0.1, Math.min(scaleX, scaleY) * 0.95);
        if (isNaN(this.state.minFitScale)) { this.state.minFitScale = 0.1; }
        if (this.state.isInitialLoad) {
          this.state.isInitialLoad = false;
          this.zoomToFit();
        } else {
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) { this.state.cam.scale = this.state.minFitScale; }
          this.clampCamera();
        }
      },
      
      doSearch() {
        if (!this.dom.inpX || !this.dom.inpY) return;
        const x = +this.dom.inpX.value; const y = +this.dom.inpY.value;
        if (x >= 0 && y >= 0 && x < this.config.N && y < this.config.N) {
          this.state.selection = this.getBuildingAt(x, y) || { x, y };
          if (this.state.selection) this.state.selection.pingStart = performance.now();
          const targetScale = (150 / 100) * this.config.baseScale;
          const [screenX, screenY] = this.worldToScreen(x, y);
          const targetCamX = this.dom.canvas.width / 2 - screenX * targetScale;
          const targetCamY = this.dom.canvas.height / 2 - screenY * targetScale;
          this.animatePanZoom(targetScale, targetCamX, targetCamY);
        }
      },
      
      updateFloatingZoomLabel() {
        if (!this.dom.zoomSlider || !this.dom.floatingZoomLabel) return;
        const slider = this.dom.zoomSlider; const label = this.dom.floatingZoomLabel;
        const min = parseInt(slider.min, 10); const max = parseInt(slider.max, 10); const val = parseInt(slider.value, 10);
        if (max === min) { label.style.display = 'none'; return; }
        const percent = (val - min) / (max - min); const thumbHeight = 15; const trackHeight = slider.offsetHeight;
        const topPos = (1 - percent) * (trackHeight - thumbHeight) + (thumbHeight / 2);
        label.style.top = `${topPos}px`; label.textContent = `Zoom: ${val}%`; label.style.display = 'block';
        clearTimeout(this.state.hideLabelTimeout);
        this.state.hideLabelTimeout = setTimeout(() => { label.style.display = 'none'; }, 1500);
      },

      drawIsometricMinimap(viewportCorners) {
        if (!this.dom.minimapCtx || !this.state.isMinimapVisible || !this.config.minimap) return;

        const mmCtx = this.dom.minimapCtx;
        const { minimap, N, tileW, tileH, baseScale, maxPct } = this.config;
        const canvasWidth = this.dom.minimapCanvas.width;
        const canvasHeight = this.dom.minimapCanvas.height;

        mmCtx.save();
        mmCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset
        mmCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        mmCtx.fillStyle = minimap.bgColor;
        mmCtx.fillRect(0, 0, canvasWidth, canvasHeight);

        // --- Interpolated Focus Rendering Logic ---

        // 1. Calculate base scale. (No change)
        const worldIsoWidth = N * tileW;
        const worldIsoHeight = N * tileH;
        const drawableWidth = canvasWidth - (minimap.padding * 2);
        const drawableHeight = canvasHeight - (minimap.padding * 2);
        const baseMinimapScale = Math.min(drawableWidth / worldIsoWidth, drawableHeight / worldIsoHeight);

        // 2. Determine the dynamic zoom factor and a normalized progress value. (No change in zoomFactor, added normalizedZoom)
        const mainMapCurrentScale = this.state.cam.scale;
        const mainMapMaxScale = (maxPct / 100) * baseScale;
        const zoomStartThresholdScale = minimap.mainMapZoomThresholdForMinimapZoom * baseScale;
        
        let zoomFactor;
        let normalizedZoom = 0; // This will be our 0-to-1 interpolation factor
        if (mainMapCurrentScale <= zoomStartThresholdScale) {
            zoomFactor = minimap.zoomFactorMin;
        } else {
            normalizedZoom = Math.max(0, Math.min(1, (mainMapCurrentScale - zoomStartThresholdScale) / (mainMapMaxScale - zoomStartThresholdScale)));
            zoomFactor = minimap.zoomFactorMin + (minimap.zoomFactorMax - minimap.zoomFactorMin) * normalizedZoom;
        }
        const finalMinimapScale = baseMinimapScale * zoomFactor;

        // 4. **[MODIFIED]** Interpolate the translation between the map's center and the viewport's center.
        
        // Target 1: The center of the entire map (for a static overview)
        const mapVisualCenterX_iso = 0;
        const mapVisualCenterY_iso = -((N - 1) * tileH / 2);

        // Target 2: The center of the user's viewport (for a focused view)
        const [mainViewCenterX, mainViewCenterY] = this.screenToWorld(this.dom.canvas.width / 2, this.dom.canvas.height / 2);
        const [viewportCenterX_iso, viewportCenterY_iso] = this.worldToScreen(mainViewCenterX, mainViewCenterY);

        // Linearly interpolate between the two focal points using our normalizedZoom factor.
        const focalPointX = mapVisualCenterX_iso + (viewportCenterX_iso - mapVisualCenterX_iso) * normalizedZoom;
        const focalPointY = mapVisualCenterY_iso + (viewportCenterY_iso - mapVisualCenterY_iso) * normalizedZoom;
        
        // Calculate the final translation needed to place our interpolated focal point in the center of the canvas.
        const translateX = (canvasWidth / 2) - (focalPointX * finalMinimapScale);
        const translateY = (canvasHeight / 2) - (focalPointY * finalMinimapScale);
        
        // 5. Store this transform for correct click/drag handling on the minimap.
        this.state.minimapCam = { x: translateX, y: translateY, scale: finalMinimapScale };
        
        // 6. Apply the final transform and draw the map content.
        mmCtx.setTransform(finalMinimapScale, 0, 0, finalMinimapScale, translateX, translateY);

        const chunksToDraw = this.state.chunkLevels[3];
        chunksToDraw.forEach(chunk => { this.drawChunk(chunk, false, mmCtx); });
        
        (this.state.baseMap.defaultBuildings || []).forEach(b => {
            let buildingFillStyle = null;
            if (b.displayName === "King's Castle") buildingFillStyle = minimap.kingCastleColor;
            else if (b.displayName.startsWith("Fortress")) buildingFillStyle = minimap.fortressColor;
            else if (b.displayName.startsWith("Sanctuary")) buildingFillStyle = minimap.sanctuaryColor;
            
            if (buildingFillStyle) {
                const originalFill = b.fillColor; b.fillColor = buildingFillStyle;
                this.drawBuildingFootprint(b, null, false, mmCtx);
                b.fillColor = originalFill;
            }
        });

        // 7. Draw the moving viewport indicator. (No change)
        if (viewportCorners) {
            const p1 = this.worldToScreen(viewportCorners.tl.x, viewportCorners.tl.y);
            const p2 = this.worldToScreen(viewportCorners.tr.x, viewportCorners.tr.y);
            const p3 = this.worldToScreen(viewportCorners.br.x, viewportCorners.br.y);
            const p4 = this.worldToScreen(viewportCorners.bl.x, viewportCorners.bl.y);

            mmCtx.fillStyle = minimap.viewportFillColor;
            mmCtx.strokeStyle = minimap.viewportBorderColor;
            mmCtx.lineWidth = 2 / finalMinimapScale;
            mmCtx.beginPath();
            mmCtx.moveTo(p1[0], p1[1]); mmCtx.lineTo(p2[0], p2[1]); mmCtx.lineTo(p3[0], p3[1]); mmCtx.lineTo(p4[0], p4[1]);
            mmCtx.closePath();
            mmCtx.fill();
            mmCtx.stroke();
        }
        mmCtx.restore();
      },

      drawTile(x, y, drawBorder = true) {
        this.state.tileCount++;
        const [sx, sy] = this.worldToScreen(x, y);
        const { config } = this; const ctx = this.dom.ctx;
        ctx.beginPath();
        ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy);
        ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy);
        ctx.closePath();
        ctx.fillStyle = config.biomeColors[this.getBiomeForTile(x, y)]; ctx.fill();
        if (drawBorder) ctx.stroke();
        const building = this.getBuildingAt(x, y);
        if (building && building.hideCoordinates) return;
        const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const pct = Math.round((currentCamScale / config.baseScale) * 100);
        const showCoords = this.dom.coordsToggle ? this.dom.coordsToggle.checked : false;
        const showThreshold = showCoords ? 80 : 200;
        if (pct <= showThreshold) return;
        const text = `${x}, ${y}`;
        let optimalFontSize = Math.min(config.tileH * 0.8 * 0.5, (config.tileW * 0.8 / (text.length || 1)) * 1.8) * 0.7;
        if ((optimalFontSize * currentCamScale) < 5) return;
        ctx.fillStyle = config.textColor; ctx.font = `${optimalFontSize}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, sx, sy);
      },

      drawChunk(chunk, drawBorder = true, overrideCtx = null) {
        this.state.tileCount++;
        const ctx = overrideCtx || this.dom.ctx;
        const { x, y, size, biome } = chunk; const { config } = this;
        const currentCamScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
        const inflation = drawBorder || currentCamScale === 0 ? 0 : (1 / currentCamScale);
        const x0 = x; const y0 = y; const w = size; const h = size;
        const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
        const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
        const p_bottom = { x: sbx, y: sby + config.tileH / 2 + inflation }; const p_right = { x: srx + config.tileW / 2 + inflation, y: sry };
        const p_top = { x: stx, y: sty - config.tileH / 2 - inflation }; const p_left = { x: slx - config.tileW / 2 - inflation, y: sly };
        ctx.beginPath();
        ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y);
        ctx.closePath();
        ctx.fillStyle = config.biomeColors[biome]; ctx.fill();
        if (drawBorder) ctx.stroke();
      },

      drawBuildingFootprint(b, highlightStyle = null, drawBorder = true, overrideCtx = null) {
        const { config, state } = this; const ctx = overrideCtx || this.dom.ctx;
        const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
        const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
        const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
        const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
        const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
        const p_bottom = { x: sbx, y: sby + config.tileH / 2 }; const p_right = { x: srx + config.tileW / 2, y: sry };
        const p_top = { x: stx, y: sty - config.tileH / 2 }; const p_left = { x: slx - config.tileW / 2, y: sly };
        ctx.beginPath();
        ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y);
        ctx.closePath();
        ctx.fillStyle = fill; ctx.fill();
        if(drawBorder) {
            ctx.strokeStyle = border;
            const currentScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
            ctx.lineWidth = (highlightStyle ? config.strokeW * 2 : config.strokeW) / (overrideCtx ? currentScale : 1);
            ctx.stroke();
        }
        if (overrideCtx || highlightStyle) return;
        const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
        if (currentCamScale > 0.4 && b.displayName) {
          const availableWidth = (p_right.x - p_left.x) * 0.8; const availableHeight = p_bottom.y - p_top.y;
          if (availableWidth < 10 || availableHeight < 10) return;
          const hasCoords = b.displayCoordinates; const heightFactor = hasCoords ? 0.5 : 1.0;
          const fontSizeBasedOnHeight = (availableHeight * heightFactor) * 0.9;
          ctx.font = `bold 100px sans-serif`; const textMetrics = ctx.measureText(b.displayName);
          const displayNameWidth = textMetrics.width || 1;
          const fontSizeBasedOnWidth = (availableWidth / displayNameWidth) * 100;
          const optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);
          if (optimalFontSize * currentCamScale < 7) return;
          const centerX = (p_left.x + p_right.x) / 2;
          const yOffset = hasCoords ? optimalFontSize * -0.45 : 0;
          const centerY = (p_top.y + p_bottom.y) / 2 + yOffset;
          ctx.fillStyle = config.textColor; ctx.font = `bold ${optimalFontSize}px sans-serif`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(b.displayName, centerX, centerY);
          if (b.displayCoordinates) {
            const coordFontSize = optimalFontSize * 0.7; ctx.font = `${coordFontSize}px sans-serif`;
            ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, centerY + optimalFontSize * 0.9);
          }
        }
      },
      
      mainLoop(now) {
        const { dom, state, config } = this;
        const ctx = dom.ctx;
        try {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
          const [centerX, centerY] = this.screenToWorld(dom.canvas.width / 2, dom.canvas.height / 2);
          if (dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
          const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
          const pct = Math.round((currentCamScale / config.baseScale) * 100);
          if (dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
          if (dom.zoomSlider) {
            const sliderMin = parseInt(dom.zoomSlider.min, 10); const sliderMax = parseInt(dom.zoomSlider.max, 10);
            if (pct > sliderMax) dom.zoomSlider.max = pct.toString();
            if (pct < sliderMin && pct < sliderMax) dom.zoomSlider.min = pct.toString();
            else if (sliderMin > sliderMax) dom.zoomSlider.min = sliderMax.toString();
            if (pct >= parseInt(dom.zoomSlider.min, 10) && pct <= parseInt(dom.zoomSlider.max, 10)) { dom.zoomSlider.value = pct.toString(); } 
            else if (pct < parseInt(dom.zoomSlider.min, 10)) { dom.zoomSlider.value = dom.zoomSlider.min; } 
            else { dom.zoomSlider.value = dom.zoomSlider.max; }
          }
          state.tileCount = 0;
          ctx.save();
          ctx.setTransform(currentCamScale, 0, 0, currentCamScale, state.cam.x, state.cam.y);
          ctx.strokeStyle = config.borderColor; ctx.lineWidth = config.strokeW;
          const [tl_x, tl_y] = this.screenToWorld(0, 0); const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
          const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height); const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
          const viewBounds = {
            minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2, maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
            minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2, maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
          };
          const viewportCorners = { tl: { x: tl_x, y: tl_y }, tr: { x: tr_x, y: tr_y }, bl: { x: bl_x, y: bl_y }, br: { x: br_x, y: br_y } };
          if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
            ctx.restore();
            if (this.state.isMinimapVisible) this.drawIsometricMinimap(null);
            requestAnimationFrame(this.mainLoop.bind(this)); return;
          }
          const chunkLevel = this.getChunkLevelForZoom(pct);
          const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
          const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
          const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;
          if (chunkLevel === -1) {
            const shouldDrawBorders = showGrid && pct > 50;
            const minSum = Math.floor(viewBounds.minX + viewBounds.minY); const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);
            for (let sum = minSum; sum <= maxSum; sum++) {
              const startXCoord = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY)));
              const endXCoord = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));
              for (let x = startXCoord; x <= endXCoord; x++) {
                const y = sum - x;
                if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue;
                if (!this.getBuildingAt(x, y)) this.drawTile(x, y, shouldDrawBorders);
              }
            }
            state.allBuildings
              .filter(b => (!b.isRss || showRss) && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
              .forEach(b => this.drawBuildingFootprint(b, null, shouldDrawBorders));
            ctx.fillStyle = '#444';
            (state.baseMap.unoccupiableTiles || []).forEach(([x, y]) => {
              if (this.getBuildingAt(x, y)) return;
              if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
              const [sx, sy] = this.worldToScreen(x, y);
              ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy);
              ctx.closePath(); ctx.fill();
            });
          } else {
            if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
              const chunksToDraw = state.chunkLevels[chunkLevel]; const chunkSize = Math.pow(2, chunkLevel + 1);
              const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize; const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
              const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize; const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
              for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
                for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
                  const chunk = chunksToDraw.get(`${x},${y}`); if (chunk) this.drawChunk(chunk, false);
                }
              }
            }
            (state.baseMap.defaultBuildings || [])
            .filter(b => !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
              .forEach(b => this.drawBuildingFootprint(b, null, false));
            if (showRss && alwaysShowRss) {
              state.allBuildings
                .filter(b => b.isRss && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
                .forEach(b => this.drawBuildingFootprint(b, null, false));
            }
            if (chunkLevel < 2) {
              ctx.fillStyle = '#444';
              (state.baseMap.unoccupiableTiles || []).forEach(([x, y]) => {
                if (this.getBuildingAt(x, y)) return;
                if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
                const [sx, sy] = this.worldToScreen(x, y);
                ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy);
                ctx.closePath(); ctx.fill();
              });
            }
          }
          if (state.selection) {
            let highlightColor = config.selectionColor;
            if (state.selection.pingStart && now - state.selection.pingStart < config.pingDuration) {
              if (Math.floor((now - state.selection.pingStart) / 100) % 2 === 0) { highlightColor = config.pingColor; }
            }
            this.drawBuildingFootprint(state.selection, highlightColor, true);
          }
          ctx.restore();
          if (this.state.isMinimapVisible) { this.drawIsometricMinimap(viewportCorners); }
          const dt = now - state.lastFrame; state.lastFrame = now;
          if (dt > 0) { state.lastFPS = Math.round(1000 / dt); }
          state.lastTiles = state.tileCount;
          if (now - state.statsUpdateTime > 500) {
            if (dom.statsFPSEl) dom.statsFPSEl.textContent = `FPS:   ${state.lastFPS}`;
            if (dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
            state.statsUpdateTime = now;
          }
        } catch (error) { console.error("Error in mainLoop:", error); }
        requestAnimationFrame(this.mainLoop.bind(this));
      }
    };
    KingshotPlanner.init();
  </script>
</body>
</html>