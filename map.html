<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
/* --- BASE & LAYOUT --- */
:root {
	--toolbar-height: 55px;
	--toolbar-bg: rgba(25, 28, 32, 0.75);
	--panel-bg: rgba(35, 38, 43, 0.9);
	--text-color: #e0e0e0;
	--highlight-color: #2a9fd6;
	--border-color: #444;
	--build-mode-bg: rgba(214, 102, 43, 0.9);
	--success-color: #28a745;
	--danger-color: #dc3545;
}

body {
	margin: 0;
	background: #111;
	overflow: hidden;
	user-select: none;
	-webkit-user-select: none;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
	color: var(--text-color);
}

canvas#map {
	display: block;
	cursor: grab;
}
canvas#map:active {
	cursor: grabbing;
}
canvas#map.build-cursor {
	cursor: crosshair;
}

/* --- TOP BANNERS --- */
#buildModeBanner {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background-color: var(--build-mode-bg);
    color: white;
    text-align: center;
    padding: 8px 0;
    font-size: 14px;
    font-weight: bold;
    z-index: 1001;
    display: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}
#infoBanner {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--panel-bg);
    color: var(--text-color);
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 950;
    display: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    text-align: center;
    pointer-events: none;
    transition: top 0.3s ease-in-out; /* Add smooth transition */
}
#infoBannerName { font-weight: bold; }
#infoBannerCoords { margin-left: 10px; font-size: 12px; opacity: 0.8; }

/* *** NEW RULE to move info banner down when build banner is active *** */
#infoBanner.with-build-banner {
    top: 45px;
}

/* --- OVERLAY UI --- */
#versionDisplay, #centerTile {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 5px);
	background: rgba(0, 0, 0, 0.5);
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 13px;
	user-select: none;
	z-index: 5;
}
#versionDisplay { left: 10px; font-size: 11px; color: rgba(255, 255, 255, 0.4); }
#centerTile { left: 50%; transform: translateX(-50%); }
#minimapContainer {
	position: absolute;
	top: 10px;
	right: 10px;
	z-index: 900;
	width: 352px;
	background-color: var(--panel-bg);
	border: 1px solid var(--border-color);
	border-radius: 6px;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	display: none;
}
#minimapContainer.visible { display: block; }
#minimapCanvas { width: 350px; height: 300px; display: block; border-radius: 0 0 6px 6px; }

/* --- BOTTOM TOOLBAR --- */
#bottomToolbar {
	position: fixed;
	bottom: 0;
	left: 0;
	width: 100%;
	height: var(--toolbar-height);
	background: var(--toolbar-bg);
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
	border-top: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	box-sizing: border-box;
	z-index: 1000;
}
.toolbar-group { display: flex; align-items: center; gap: 5px; }
.toolbar-group.center { flex-grow: 1; justify-content: center; min-width: 200px; padding: 0 10px; }
#bottomToolbar button { background: none; border: none; color: var(--text-color); font-size: 24px; padding: 8px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; line-height: 1; }
#bottomToolbar button:hover { background-color: rgba(255, 255, 255, 0.1); }
#bottomToolbar button.active { background-color: var(--highlight-color); color: white; }
#bottomToolbar button#allianceMgtToggleBtn.active,
#bottomToolbar button#buildMenuToggleBtn.active {
    background-color: var(--build-mode-bg);
}
#bottomToolbar #zoomLevel { font-size: 14px; min-width: 90px; text-align: center; user-select: none; }
#zoomSlider { -webkit-appearance: none; appearance: none; width: 100%; height: 5px; background: rgba(255, 255, 255, 0.2); border-radius: 5px; outline: none; margin: 0 10px; }
#zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #f1f1f1; border-radius: 50%; cursor: pointer; }
#zoomSlider::-moz-range-thumb { width: 18px; height: 18px; background: #f1f1f1; border-radius: 50%; cursor: pointer; border: none; }

/* --- GENERAL PANEL & BUTTON STYLES --- */
.toolbar-panel, .sidebar-panel {
	background: var(--panel-bg);
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
	border: 1px solid var(--border-color);
	box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
	padding: 15px;
	z-index: 999;
	box-sizing: border-box;
}
.toolbar-panel button, .sidebar-panel button {
    background-color: #4f5358; color: var(--text-color); border: 1px solid var(--border-color);
    border-radius: 4px; padding: 6px 12px; cursor: pointer; transition: background-color 0.2s;
}
.toolbar-panel button:hover, .sidebar-panel button:hover { background-color: #5f6368; }
.toolbar-panel button.primary, .sidebar-panel button.primary { background-color: var(--highlight-color); }
.toolbar-panel button.danger, .sidebar-panel button.danger { background-color: var(--danger-color); }
.panel-section button.warning, .sidebar-panel button.warning { background-color: #ffc107; color: #212529; }
.toolbar-panel button:disabled, .sidebar-panel button:disabled { background-color: #333; color: #888; cursor: not-allowed; }
.toolbar-panel input, .sidebar-panel input {
    background-color: #222; border: 1px solid var(--border-color); color: var(--text-color);
    padding: 6px; border-radius: 4px; box-sizing: border-box;
}
.toolbar-panel h4, .sidebar-panel h4 {
	margin: 0 0 10px 0; font-size: 13px; color: #aaa; text-transform: uppercase;
	font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;
}
.panel-section { margin-bottom: 15px; }
.panel-section:last-child { margin-bottom: 0; }

/* --- TOOLBAR POPUP PANELS (Bottom Bar) --- */
.toolbar-panel {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 10px);
	border-radius: 8px;
	display: none;
	opacity: 0;
	transform: translateY(10px);
	transition: opacity 0.2s ease-out, transform 0.2s ease-out;
	width: 320px;
    max-height: calc(100vh - 80px - var(--toolbar-height));
    overflow-y: auto;
}
.toolbar-panel.open { display: block; opacity: 1; transform: translateY(0); }
#pinnedBookmarksPanel { left: 110px; }
#navPanel { left: 165px; }
#settingsPanel { right: 10px; }
#zoomPresetsPanel { right: 120px; width: 120px; }
#overwatchPanel { right: 175px; width: 300px; }
#buildMenuPanel { left: 55px; } 

/* --- SIDEBAR PANELS --- */
.sidebar-panel {
    position: fixed;
    top: 0;
    height: 100%;
    width: 350px; 
    max-width: 90vw;
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease-in-out;
    padding-bottom: calc(var(--toolbar-height) + 15px);
}

/* Positioning for left-side panels */
#buildPanel, #devModePanel {
    left: 0;
    border-right: 1px solid var(--border-color);
    transform: translateX(-105%);
}
#buildPanel.open, #devModePanel.open {
    transform: translateX(0);
}

/* Specific content styling */
#buildPanel .alliance-list-container { flex-grow: 1; overflow-y: auto; margin: 0 -15px 0 0; padding-left: 15px; padding-right: 10px; }
#buildPanel .create-alliance-container { flex-shrink: 0; border-top: 1px solid var(--border-color); padding-top: 15px; margin-bottom: -15px; }

/* --- BUILD MENU PANEL --- */
#buildMenuPanel .building-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
#buildMenuPanel .building-list button { text-align: center; }
#buildMenuPanel .building-list button.selected { background-color: var(--highlight-color); }
#buildModeToggleContainer > * { width: 100%; box-sizing: border-box; }
#buildModeToggleContainer .placeholder-text { text-align: center; font-style: italic; color: #888; padding: 6px 12px; border: 1px dashed var(--border-color); border-radius: 4px; }


/* --- ALLIANCE MANAGEMENT CONTENT --- */
.alliance-list { display: flex; flex-direction: column; gap: 8px; }
.alliance-item { background: rgba(0,0,0,0.2); border-radius: 4px; border-left: 5px solid transparent; transition: background-color 0.2s, border-left-color 0.2s; }
.alliance-item[open] { background: rgba(42, 159, 214, 0.1); border-left-color: var(--highlight-color); }
.alliance-item summary { display: flex; align-items: center; gap: 8px; padding: 8px; cursor: pointer; list-style: none; }
.alliance-item summary::-webkit-details-marker { display: none; }
.alliance-item summary .controls button { pointer-events: auto; }
.alliance-item .color-swatch { width: 16px; height: 16px; border-radius: 3px; flex-shrink: 0; }
.alliance-item .name { flex-grow: 1; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.alliance-item .tag { font-weight: bold; font-size: 13px; background: #555; padding: 2px 5px; border-radius: 3px; }
.alliance-item .controls { display: flex; gap: 4px; }
.alliance-item .controls button { font-size: 12px; padding: 3px 6px; }
.alliance-item.is-active-builder { border-left-color: var(--success-color); }
.alliance-item.is-active-builder summary { background: rgba(40, 167, 69, 0.15); }
.alliance-details-content { padding: 0 12px 12px 12px; font-size: 14px; display: flex; flex-direction: column; gap: 12px; border-top: 1px solid var(--border-color); margin-top: 8px; }
.alliance-details-content h5 { margin: 8px 0 0 0; font-size: 12px; color: #aaa; text-transform: uppercase; font-weight: 600; }
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px 15px; }
.stats-grid strong { font-weight: bold; text-align: right; }
.hq-list, .outpost-list { display: flex; flex-direction: column; gap: 5px; }
.hq-list-item, .outpost-list-item { display: flex; justify-content: space-between; align-items: center; font-size: 14px; padding: 4px 0; }
.hq-list-item .controls button, .outpost-list-item .controls button { padding: 2px 6px; font-size: 12px; }
.create-alliance-container .form-grid { display: grid; grid-template-columns: auto 1fr; gap: 8px; align-items: center; margin-bottom: 12px; }
.create-alliance-container .form-grid input[type="color"] { padding: 0; height: 30px; width: 50px; }
.create-alliance-container #createAllianceBtn { width: 100%; margin-top: 5px; }
#toggleDeleteModeBtn {
    width: 100%;
    margin-bottom: 15px;
}

/* Style for the main button when delete mode is active */
#toggleDeleteModeBtn.active {
    background-color: #fff;
    color: var(--danger-color);
    font-weight: bold;
}

/* Style for the individual delete buttons that appear on each alliance */
.alliance-item .delete-confirm-btn {
    width: 100%;
}

/* --- DEV MODE PANEL --- */
#devModePanel {
    z-index: 998; /* Lower priority so other panels open on top */
}
.dev-tools-container {
    flex-grow: 1;
    overflow-y: auto;
    margin: 0 -15px 0 0;
    padding-left: 15px;
    padding-right: 10px;
}
.dev-tools-list {
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.dev-tools-list button.active {
    background-color: var(--success-color);
    font-weight: bold;
}
#exportDevMapBtn {
    width: 100%;
}

/* --- OTHER PANELS --- */
.bookmarks-list { max-height: 250px; overflow-y: auto; margin-right: -5px; padding-right: 5px; }
.bookmark-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 5px; font-size: 14px; border-bottom: 1px solid #3a3a3a; }
.bookmark-item:last-child { border-bottom: none; }
.bookmark-item > span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; padding-right: 10px; }
.bookmark-item .controls button { padding: 2px 6px; font-size: 12px; margin-left: 5px; cursor: pointer; }
.bookmark-item .unpin-btn { color: #fdd; background: #5a3838; }
#navPanel .tab-buttons { display: flex; margin-bottom: 15px; border-radius: 6px; overflow: hidden; border: 1px solid var(--border-color); }
#navPanel .tab-button { flex: 1; padding: 8px; background: rgba(0, 0, 0, 0.2); border: none; color: var(--text-color); cursor: pointer; font-size: 14px; }
#navPanel .tab-button.active { background: var(--highlight-color); }
#navPanel .tab-content { display: none; }
#navPanel .tab-content.active { display: block; }
#navPanel #goToContent div { display: flex; gap: 10px; align-items: center; }
#settingsPanel label { font-size: 14px; user-select: none; vertical-align: middle; }
#settingsPanel > .panel-section > div { margin-bottom: 8px; }
#settingsPanel .info-buttons, #settingsPanel .plan-buttons { display: flex; gap: 10px; }
#settingsPanel .info-buttons button, #settingsPanel .plan-buttons button { flex: 1; cursor: pointer; }
.overwatch-list details { border-bottom: 1px solid var(--border-color); }
.overwatch-list details:last-of-type { border-bottom: none; }
.overwatch-list summary { cursor: pointer; list-style: none; padding: 8px 0; font-weight: bold; }
.overwatch-list summary::-webkit-details-marker { display: none; }
.overwatch-list summary:before { content: '‚ñ∂'; margin-right: 8px; font-size: 0.8em; display: inline-block; transition: transform 0.2s; }
.overwatch-list details[open] > summary:before { transform: rotate(90deg); }
.overwatch-list details[data-category="king's_castle"] > summary:before { content: ''; margin-right: 0; padding-left: 18px; }
.overwatch-item { font-size: 14px; padding: 4px 0 4px 25px; }
.overwatch-item label { cursor: pointer; }
#zoomPresetsPanel .preset-list { display: flex; flex-direction: column; gap: 4px; }
#floatingBuildingsBtn { position: fixed; right: 10px; top: 50%; transform: translateY(-50%); z-index: 998; writing-mode: vertical-rl; text-orientation: mixed; padding: 15px 8px; border-radius: 8px 0 0 8px; background-color: var(--panel-bg); display: none; border-left: none; border-top: 1px solid var(--border-color); border-right: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); transition: transform 0.3s ease-in-out, background-color 0.2s; }
#floatingBuildingsBtn.active { background-color: var(--highlight-color); transform: translate(-280px, -50%); }
#buildingPalettePanel { top: 50%; right: 0; bottom: unset; height: auto; transform: translate(100%, -50%); border-radius: 8px 0 0 8px; border-right: none; transition: transform 0.3s ease-in-out; width: 280px; max-height: calc(100vh - 40px); overflow-y: auto; }
#buildingPalettePanel.open { transform: translate(0, -50%); opacity: 1; }
#buildingPalettePanel .building-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
#buildingPalettePanel .building-list button { text-align: center; }
#statsPanel { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0, 0, 0, 0.6); padding: 6px 10px; border-radius: 4px; font-size: 13px; }

/* --- MODALS --- */
.modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1001; }
.modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px; background: #2c2c2c; color: #eee; border-radius: 8px; z-index: 1002; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
.modal-header { padding: 15px; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; }
.modal-header h3 { margin: 0; }
.modal-header .close-btn { background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; }
.modal-body { padding: 15px; max-height: 60vh; overflow-y: auto; }
.modal-body ul { padding-left: 20px; margin: 0; }
.modal-body li { margin-bottom: 8px; }
.modal-body details { border-bottom: 1px solid #4a4a4a; margin-bottom: 5px; }
.modal-body details:last-of-type { border-bottom: none; }
.modal-body summary { cursor: pointer; list-style: none; padding: 10px 0; font-weight: bold; font-size: 1.1em; position: relative; }
.modal-body summary::-webkit-details-marker { display: none; }
.modal-body summary:before { content: '‚ñ∂'; position: absolute; left: -15px; font-size: 0.8em; transition: transform 0.2s; transform: rotate(0deg); }
.modal-body details[open] > summary:before { transform: rotate(90deg); }
.modal-body details > :not(summary) { padding-bottom: 10px; padding-left: 5px; }
.modal-footer { padding: 10px 15px; border-top: 1px solid #444; background: #333; border-radius: 0 0 8px 8px; }
.modal-footer label { user-select: none; font-size: 14px; }

/* Add these new rules to your <style> tag */

/* --- SIDEBAR PANEL (Alliance Management) --- */
#buildPanel, #devModePanel {
    left: 0;
    border-right: 1px solid var(--border-color);
    transform: translateX(-105%);
}

/* --- PLAYER MANAGEMENT PANEL --- */
#playerPanel {
    left: 0;
    border-right: 1px solid var(--border-color);
    transform: translateX(-105%);
}
#playerPanel.open {
    transform: translateX(0);
}

#playerPanel .player-list-container {
    flex-grow: 1;
    overflow-y: auto;
    margin: 0 -15px 0 0;
    padding-left: 15px;
    padding-right: 10px;
}

#playerPanel .create-player-container {
    flex-shrink: 0;
    border-top: 1px solid var(--border-color);
    padding-top: 15px;
    margin-bottom: -15px;
}

/* Form grid specific to the player panel for better layout */
#playerPanel .form-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 12px;
    align-items: center;
    margin-bottom: 15px;
}
#playerPanel .form-grid input[type="color"] {
    padding: 0;
    height: 30px;
    width: 50px;
}
#playerPanel .form-grid input {
    width: 100%;
}
#playerPanel #startPlayerPlacementBtn {
    width: 100%;
}

/* Player list styles */
.player-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.player-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background: rgba(0,0,0,0.2);
    border-radius: 4px;
    border-left: 5px solid transparent;
}
.player-item .color-swatch {
    width: 16px;
    height: 16px;
    border-radius: 3px;
    flex-shrink: 0;
}
.player-item .info {
    flex-grow: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.player-item .info .name {
    font-size: 14px;
    font-weight: bold;
}
.player-item .info .power {
    font-size: 12px;
    opacity: 0.8;
}
.player-item .controls {
    display: flex;
    gap: 4px;
}
.player-item .controls button {
    font-size: 12px;
    padding: 3px 6px;
}
#buildPanel.open, #devModePanel.open { transform: translateX(0); }
#devModePanel {
    padding-bottom: calc(var(--toolbar-height) + 15px);
}
.dev-tools-container {
    flex-grow: 1;
    overflow-y: auto;
    margin: 0 -15px 0 0;
    padding-left: 15px;
    padding-right: 10px;
}
.dev-tools-list {
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.dev-tools-list button.active {
    background-color: var(--success-color);
    font-weight: bold;
}
#exportDevMapBtn {
    width: 100%;
}

/* --- RESPONSIVE STYLES --- */
@media (max-width: 768px) {
	.toolbar-group.center { padding: 0 5px; }
	.toolbar-panel, #buildPanel { width: calc(100vw - 20px); max-width: 400px; }
	#pinnedBookmarksPanel, #navPanel, #settingsPanel, #zoomPresetsPanel { left: 10px; right: 10px; width: auto; }
}
@media (max-width: 480px) {
	:root { --toolbar-height: 50px; }
	#bottomToolbar { padding: 0 5px; }
	.toolbar-group { gap: 0; }
	.toolbar-group.center { min-width: 0; flex: 1; }
	#bottomToolbar button { font-size: 20px; padding: 6px; }
	#zoomLevel { display: none; }
	#statsPanel, #centerTile, #versionDisplay { display: none; }
}
</style>
</head>
<body>
    <!-- TOP UI ELEMENTS -->
    <div id="statsPanel">
        <div id="statsFPS">FPS: ‚Äì</div>
        <div id="statsTiles">Tiles: ‚Äì</div>
    </div>

    <!-- BUILD MODE BANNER -->
    <div id="buildModeBanner">Build Mode Enabled</div>

    <!-- INFO BANNER -->
    <div id="infoBanner">
        <span id="infoBannerName"></span>
        <span id="infoBannerCoords"></span>
    </div>

    <div id="minimapContainer">
        <canvas id="minimapCanvas"></canvas>
    </div>

    <div id="centerTile">Center: X0 Y0</div>
    <div id="versionDisplay"></div>

    <!-- MAIN CANVAS -->
    <canvas id="map"></canvas>

    <!-- NEW BOTTOM TOOLBAR & PANELS -->
    <div id="bottomToolbar">
        <div class="toolbar-group left">
            <button id="allianceMgtToggleBtn" title="Alliance Management">üè∞</button>
            <button id="buildMenuToggleBtn" title="Build Menu">üõ†Ô∏è</button>
            <button id="placePlayerToggleBtn" title="Player Management">üë§</button>
            <button id="pinnedBookmarksToggleBtn" title="Pinned Landmarks">üìå</button>
            <button id="navPanelToggleBtn" title="Navigation">üß≠</button>
        </div>
    
        <div class="toolbar-group center">
            <button id="zoomDecBtn" title="Zoom Out">-</button>
            <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
            <button id="zoomIncBtn" title="Zoom In">+</button>
            <div id="zoomLevel">Zoom: 100%</div>
        </div>
    
        <div class="toolbar-group right">
            <button id="overwatchToggleBtn" title="Overwatch">üëÅÔ∏è</button> 
            <button id="zoomPresetsToggleBtn" title="Zoom Presets">üéØ</button>
            <button id="minimapToggleBtn" title="Toggle Minimap">üó∫Ô∏è</button>
            <button id="settingsToggleBtn" title="Settings">‚öôÔ∏è</button>
        </div>
    </div>

    <div id="pinnedBookmarksPanel" class="toolbar-panel">
        <h4>Pinned Landmarks</h4>
        <div id="pinnedBookmarksList" class="bookmarks-list"></div>
    </div>

    <!-- Navigation Panel -->
    <div id="navPanel" class="toolbar-panel">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="goToContent">Go To</button>
            <button class="tab-button" data-tab="landmarksContent">Landmarks</button>
        </div>
        <div id="goToContent" class="tab-content active">
            <h4>Go To Coordinates</h4>
            <div>
                X: <input id="inpX" type="number" min="0" max="1199" value="0">
                Y: <input id="inpY" type="number" min="0" max="1199" value="0">
                <button id="btnGo">Go</button>
            </div>
        </div>
        <div id="landmarksContent" class="tab-content">
            <h4>Available Landmarks</h4>
            <div id="addBookmarksList" class="bookmarks-list"></div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="toolbar-panel">
        <div class="panel-section">
            <h4>Display</h4>
            <div><input type="checkbox" id="gridlinesToggle"><label for="gridlinesToggle"> Show Gridlines</label></div>
            <div><input type="checkbox" id="coordsToggle"><label for="coordsToggle"> Show Coords >80%</label></div>
            <div><input type="checkbox" id="allianceRssToggle"><label for="allianceRssToggle"> Show Alliance RSS</label></div>
            <div><input type="checkbox" id="allianceRssAlwaysVisibleToggle"><label for="allianceRssAlwaysVisibleToggle"> Always Show RSS</label></div>
        </div>

        <div class="panel-section">
            <h4>Build Overlays</h4>
            <div>
                <label for="userTerritoryRenderSelect">Show Territory at Zoom:</label>
                    <select id="userTerritoryRenderSelect">
                        <option value="0">Always</option>
                        <option value="5">> 5%</option>
                        <option value="10">> 10%</option>
                        <option value="20">> 20%</option>
                        <option value="30">> 30%</option>
                        <option value="40">> 40%</option>
                        <option value="50">> 50%</option>
                        <option value="60">> 60%</option>
                        <option value="80">> 80%</option>
                        <option value="100">> 100%</option>
                        <option value="-1">Never</option>
                    </select>
            </div>

            <div>
                <label for="userBuildingRenderSelect">Show Buildings at Zoom:</label>
                <select id="userBuildingRenderSelect">
                <option value="0">Always</option>
                <option value="5">> 5%</option>
                <option value="10">> 10%</option>
                <option value="20">> 20%</option>
                <option value="30">> 30%</option>
                <option value="40">> 40%</option>
                <option value="50">> 50%</option>
                <option value="60">> 60%</option>
                <option value="80">> 80%</option>
                <option value="100">> 100%</option>
                <option value="-1">Never</option>
                </select>
            </div>
        </div>

        <div class="panel-section">
            <h4>Performance</h4>
            <label for="tileDetailSelect">Un-merge tiles at zoom level:</label>
            <select id="tileDetailSelect">
                <option value="19">20% (Ultra)</option>
                <option value="39">40% (Super)</option>
                <option value="49">50% (High)</option>
                <option value="59">60% (Medium)</option>
                <option value="69">70% (Low)</option>
                <option value="79">80% (Very Low)</option>
            </select>
        </div>

        <div class="panel-section">
            <h4>Build Plan</h4>
            <div class="plan-buttons">
                <button id="importPlanBtn">Import</button>
                <button id="exportPlanBtn">Export</button>
                <button id="clearPlanBtn" class="danger">Clear Plan</button> 
                <input type="file" id="planFileInput" accept=".json" style="display: none;">
            </div>
        </div>

        <div class="panel-section info-buttons">
            <button id="infoBtn">Controls</button>
            <button id="patchNotesBtn">Patch Notes</button>
        </div>
    </div>

    <!-- Zoom Presets Panel -->
    <div id="zoomPresetsPanel" class="toolbar-panel">
        <div id="zoomPresetsList" class="preset-list"></div>
    </div>

    <!-- OVERWATCH PANEL -->
    <div id="overwatchPanel" class="toolbar-panel">
        <h4>Overwatch</h4>
        <div id="overwatchList" class="overwatch-list"></div>
    </div>

    <!-- *** BUILD PANEL IS NOW THE ALLIANCE MANAGEMENT SIDEBAR *** -->
    <div id="buildPanel" class="sidebar-panel">
        <div class="alliance-list-container">
            <h4>Alliances</h4>
            <div id="allianceList" class="alliance-list"></div>
        </div>
        <div class="create-alliance-container panel-section">
            <button id="toggleDeleteModeBtn" class="danger">Delete Alliance</button>
            
            <h4>Create Alliance</h4>
            <div class="form-grid">
                <label for="allianceName">Name:</label>
                <input type="text" id="allianceName" placeholder="AlphabetSoup" maxlength="20">
                <label for="allianceTag">Tag:</label>
                <input type="text" id="allianceTag" placeholder="ABC" maxlength="3">
                <label for="allianceColor">Color:</label>
                <input type="color" id="allianceColor" value="#d6662b">
            </div>
            <button id="createAllianceBtn" class="primary">Create Alliance</button>
        </div>
    </div>

    <!-- Place a Player Panel -->
    <div id="playerPanel" class="sidebar-panel">
        <div class="player-list-container">
            <h4>Placed Players</h4>
            <div id="playerList" class="player-list">
                <!-- Populated by JS -->
            </div>
        </div>
        <div class="create-player-container panel-section">
            <h4>Create Player</h4>
            <div class="form-grid">
                <label for="playerNameInput">Name:</label>
                <input type="text" id="playerNameInput" placeholder="BigKev" maxlength="20">
                <label for="playerPowerInput">Rally Capacity:</label>
                <input type="text" id="playerPowerInput" placeholder="1.23m" maxlength="6">
                <label for="playerColorInput">Color:</label>
                <input type="color" id="playerColorInput" value="#9400d3">
            </div>
            <button id="startPlayerPlacementBtn" class="primary">Place on Map</button>
        </div>
    </div>

    <!-- *** NEW BUILD MENU PANEL *** -->
    <div id="buildMenuPanel" class="toolbar-panel">
        <div id="buildModeToggleContainer" class="panel-section">
            <!-- "Enter Build Mode" button or text will be rendered here by JS -->
        </div>
        <div class="panel-section">
            <h4>Buildings</h4>
            <div id="buildMenuBuildingList" class="building-list">
                <!-- Building buttons will be rendered here by JS -->
            </div>
        </div>
    </div>


    <!-- MODALS (unchanged structure, but triggered from new buttons) -->
    <div id="modalOverlay" class="modal-overlay"></div>
    <div id="patchNotesModal" class="modal">
        <div class="modal-header"><h3>What's New?!</h3><button id="closePatchNotesBtn" class="close-btn">√ó</button></div>
        <div class="modal-body" id="patchNotesBody"></div>
        <div class="modal-footer"><input type="checkbox" id="hidePatchNotesCheckbox"><label for="hidePatchNotesCheckbox"> Hide this window until the next update.</label></div>
    </div>
    <div id="controlsModal" class="modal">
        <div class="modal-header"><h3>Controls</h3><button id="closeControlsBtn" class="close-btn">√ó</button></div>
        <div class="modal-body">
            <ul>
                <li><strong>Pan</strong>: Drag with mouse / One-finger drag on touch</li>
                <li><strong>Zoom</strong>: Mouse wheel, +/- buttons, or the slider</li>
                <li><strong>Pinch-to-Zoom</strong>: Use two fingers on touch devices</li>
                <li><strong>Quick Zoom</strong>: Double-click to zoom in</li>
                <li><strong>Keyboard Pan</strong>: Use Arrow Keys</li>
                <li><strong>Select</strong>: Click or tap on any tile</li>
                <li><strong>Place Building (Build Mode)</strong>: Select a building from the menu and click on the map.</li>
                <li><strong>Cancel Placement (Build Mode)</strong>: Right-click or press Escape key.</li>
                <li><strong>Delete Building (Build Mode)</strong>: Right-click on a placed building.</li>
            </ul>
        </div>
    </div>
    <!-- Add this new modal to your HTML file -->
    <div id="editPlayerModal" class="modal">
        <div class="modal-header">
            <h3>Edit Player</h3><button class="close-btn">√ó</button>
        </div>
        <div class="modal-body">
            <input type="hidden" id="editPlayerId">
            <div class="form-grid">
                <label for="editPlayerName">Name:</label>
                <input type="text" id="editPlayerName" placeholder="Player Name" maxlength="20">
                <label for="editPlayerPower">Rally Capacity:</label>
                <input type="text" id="editPlayerPower" placeholder="1.23m" maxlength="6">
                <label for="editPlayerColor">Color:</label>
                <input type="color" id="editPlayerColor">
            </div>
        </div>
        <div class="modal-footer">
            <button id="savePlayerChangesBtn" class="primary">Save Changes</button>
        </div>
    </div>
    <div id="editAllianceModal" class="modal">
        <div class="modal-header">
            <h3>Edit Alliance</h3><button class="close-btn">√ó</button>
        </div>
        <div class="modal-body">
            <input type="hidden" id="editAllianceId">
            <div class="form-grid">
                <label for="editAllianceName">Name:</label>
                <input type="text" id="editAllianceName" placeholder="Alliance Name" maxlength="20">
                <label for="editAllianceTag">Tag:</label>
                <input type="text" id="editAllianceTag" placeholder="TAG" maxlength="3">
                <label for="editAllianceColor">Color:</label>
                <input type="color" id="editAllianceColor">
            </div>
        </div>
        <div class="modal-footer">
            <button id="saveAllianceChangesBtn" class="primary">Save Changes</button>
        </div>
    </div>

    <div id="devModePanel" class="sidebar-panel">
        <div class="panel-section">
            <button id="exportDevMapBtn" class="primary">Export Map Data</button>
        </div>
        <div class="dev-tools-container">
            <h4>Tools</h4>
            <div id="devModeTools" class="dev-tools-list">
                <!-- Tools will be populated by JS -->
            </div>
        </div>
    </div>

<script>
    const KingshotPlanner = {
        // --- TWEAKABLE SETTINGS ---
        config: {
            CURRENT_VERSION: '9.1.3.0',
            enableDevMode: false,
            N: 1200,
            tileW: 10,
            tileH: 10,
            strokeW: 0.3,
            borderColor: '#000',
            textColor: '#fff',
            textColorAlt: 'rgba(0, 0, 0, 0.65)',
            maxPct: 250,
            selectionColor: '#ff0',
            pingColor: '#fff',
            pingDuration: 500,
            baseScale: 5,
            infoBannerThreshold: 50, // How many tiles away from center to show info banner
            imageBreakpoints: { 
                highZoom: 80,    // % zoom level to use base imageScale
                midZoom: 25,     // % zoom level to use imageScaleBreakpoint_1
                lowZoom: 10,      // % zoom level to use imageScaleBreakpoint_2
                imageRenderThreshold: 4.5 // % zoom level to start rendering images
            },
            biomeColors: {
            fertile: 'rgb(109, 159, 62)',
            plains: 'rgb(158, 180, 103)',
            badlands: 'rgb(191, 208, 152)',
            ruins: 'rgb(120, 108, 92)',      
            forbidden: 'rgb(80, 80, 80)', 
            unoccupiable: 'rgb(30, 30, 30)',
            },
            biomeRegions: {
            fertile: { x1: 480, y1: 480, x2: 719, y2: 719 },
            plains: { x1: 320, y1: 320, x2: 879, y2: 879 },
            badlands: { x1: 0, y1: 0, x2: 1199, y2: 1199 }
            },
            ALLIANCE_RSS_STYLES: {
            wood: { displayName: 'Wood', fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
            food: { displayName: 'Food', fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
            stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
            iron: { displayName: 'Iron', fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
            },
            minimap: {
            width: 350,
            height: 300,
            padding: 5,
            bgColor: 'rgba(40,40,40,0.8)',
            viewportFillColor: 'rgba(255, 255, 255, 0.2)',
            viewportBorderColor: 'rgba(255, 255, 255, 0.85)',
            kingCastleColor: 'rgba(255,215,0,0.9)',
            fortressColor: 'rgba(178,34,34,1)',
            sanctuaryColor: 'rgba(65,105,225,1)',
            buildersGuildOutpostColor: 'rgba(0, 206, 209, 1)',
            foragerGroveOutpostColor: 'rgba(50, 205, 50, 1)',
            harvestAltarOutpostColor: 'rgba(255, 0, 255, 1)',
            scholarsTowerOutpostColor: 'rgba(138, 43, 226, 1)',
            arsenalOutpostColor: 'rgba(255, 0, 0, 1)',
            armoryOutpostColor: 'rgba(0, 128, 128, 1)',
            drillCampOutpostColor: 'rgba(135, 206, 235, 1)',
            frontierLodgeOutpostColor: 'rgba(128, 128, 0, 1)',
            zoomFactorMin: 1.2, 
            zoomFactorMax: 15.0,
            mainMapZoomThresholdForMinimapZoom: 0.03
            }
        },

        // --- NEW HELPER FUNCTIONS ---
        darkenColor(hex, percent) {
            if (!hex.startsWith('#')) return hex;
            let R = parseInt(hex.substring(1, 3), 16);
            let G = parseInt(hex.substring(3, 5), 16);
            let B = parseInt(hex.substring(5, 7), 16);

            R = parseInt(R * (100 - percent) / 100);
            G = parseInt(G * (100 - percent) / 100);
            B = parseInt(B * (100 - percent) / 100);

            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;

            const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

            return "#" + RR + GG + BB;
        },
        hexToRgba(hex, alpha = 1) {
            if (!hex.startsWith('#')) return `rgba(0,0,0,${alpha})`;
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        },

        // --- NEW: CONTRASTING FONT COLOR HELPER ---
        getContrastingTextColor(color) {
            // Handles both hex (#RRGGBB) and rgb(a) strings
            let r, g, b;
            if (color.startsWith('#')) {
                r = parseInt(color.slice(1, 3), 16);
                g = parseInt(color.slice(3, 5), 16);
                b = parseInt(color.slice(5, 7), 16);
            } else {
                const parts = color.match(/(\d+)/g);
                if (!parts || parts.length < 3) return '#FFFFFF'; // Default to white
                [r, g, b] = parts.map(Number);
            }
            
            // Formula for calculating luminance (YIQ)
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            
            // Return black for light backgrounds, white for dark backgrounds
            return (yiq >= 128) ? '#000000' : '#FFFFFF';
        },

        // --- NEW: CAMERA STATE MANAGEMENT ---
        saveCameraState() {
            // Don't save if an animation (like 'Go To') is in progress.
            if (this.state.animationId) return; 
            const cameraState = {
                x: this.state.cam.x,
                y: this.state.cam.y,
                scale: this.state.cam.scale
            };
            localStorage.setItem('kingshot_camera_state', JSON.stringify(cameraState));
        },

        requestSaveCameraState() {
            // This creates a small delay, so we don't save on every single frame of a drag.
            clearTimeout(this.state.saveTimeout);
            this.state.saveTimeout = setTimeout(() => this.saveCameraState(), 500);
        },

        loadCameraState() {
            const savedState = localStorage.getItem('kingshot_camera_state');
            if (savedState) {
                try {
                    const cameraState = JSON.parse(savedState);
                    // Validate the loaded data to prevent errors
                    if (cameraState && typeof cameraState.x === 'number' && typeof cameraState.y === 'number' && typeof cameraState.scale === 'number') {
                        this.state.cam.x = cameraState.x;
                        this.state.cam.y = cameraState.y;
                        this.state.cam.scale = cameraState.scale;
                        console.log("Camera state loaded from browser storage.");
                        return true; // Indicate success
                    }
                } catch (e) {
                    console.error("Could not parse saved camera state:", e);
                    localStorage.removeItem('kingshot_camera_state'); // Clear out corrupted data
                }
            }
            return false; // Indicate failure
        },

                loadDevMapFromLocalStorage() {
            try {
                const savedDevMap = localStorage.getItem('kingshot_dev_map');
                if (savedDevMap) {
                    const data = JSON.parse(savedDevMap);
                    // Validate the loaded data to ensure it's not corrupt
                    if (data && Array.isArray(data.unoccupiableTiles) && Array.isArray(data.allianceRssBuildings) && Array.isArray(data.defaultBuildings)) {
                        // Overwrite the baseMap state with the saved dev data
                        this.state.baseMap.unoccupiableTiles = data.unoccupiableTiles;
                        this.state.baseMap.allianceRssBuildings = data.allianceRssBuildings;
                        this.state.baseMap.defaultBuildings = data.defaultBuildings;
                        console.log("Dev map loaded from browser storage.");
                        return true; // Indicate that data was loaded
                    }
                }
            } catch (e) {
                console.error("Could not load dev map from local storage:", e);
                localStorage.removeItem('kingshot_dev_map'); // Clear corrupted data
            }
            return false; // Indicate no data was loaded
        },

        saveDevMapToLocalStorage() {
            // Only save if dev mode is actually enabled
            if (!this.state.isDevMode) return;
            try {
                const devMapData = {
                    unoccupiableTiles: this.state.baseMap.unoccupiableTiles,
                    allianceRssBuildings: this.state.baseMap.allianceRssBuildings,
                    defaultBuildings: this.state.baseMap.defaultBuildings,
                };
                localStorage.setItem('kingshot_dev_map', JSON.stringify(devMapData));
            } catch(e) {
                console.error("Could not save dev map to local storage:", e);
            }
        },

        // --- BUILDING CATALOG ---
        BUILDING_CATALOG: {
            'alliance_tower': { name: 'Alliance Tower', w: 1, h: 1, coverage: 7, text: 'tag', rule: 'any' },
            'hq_badlands': { name: 'Badlands HQ', w: 3, h: 3, coverage: 15, text: 'tag BadlandsHQ', rule: 'badlands', limit: 1 },
            'hq_plains': { name: 'Plains HQ', w: 3, h: 3, coverage: 15, text: 'tag PlainsHQ', rule: 'plains', limit: 1 },
            'hq_fertile': { name: 'Fertile Lands HQ', w: 3, h: 3, coverage: 15, text: 'tag FertileHQ', rule: 'fertile', limit: 1 },
            'pitfall': { name: 'Pitfall', w: 3, h: 3, coverage: 0, text: 'tag Bear', rule: 'claimed', limit: 1 },
            'statue1': { name: 'Prestige Statue 1', w: 2, h: 2, coverage: 0, text: 'tag Statue 1', rule: 'claimed', limit: 1 },
            'statue2': { name: 'Prestige Statue 2', w: 2, h: 2, coverage: 0, text: 'tag Statue 2', rule: 'claimed', limit: 1 },
            'statue3': { name: 'Prestige Statue 3', w: 2, h: 2, coverage: 0, text: 'tag Statue 3', rule: 'claimed', limit: 1 },
        },
        PLAYER_CATALOG: {
            'player_castle': { name: 'Player Castle', w: 2, h: 2, fillColor: 'rgba(148, 0, 211, 0.7)', borderColor: 'rgba(126, 0, 180, 1)' }
        },
        state: {
            baseMap: { unoccupiableTiles: [], defaultBuildings: [] },
            unoccupiableTileSet: new Set(), 
            patchNotes: '',
            buildingImages: new Map(), 
            saveTimeout: null, 
            allBuildings: [],
            buildingMap: new Map(),
            chunkLevels: [],
            cam: { x: 0, y: 0, scale: 1 },
            lastFrame: 0,
            tileCount: 0,
            lastFPS: 0,
            lastTiles: 0,
            selection: null,
            minFitScale: 0.1,
            isInitialLoad: true,
            touchStartTime: 0,
            placedPlayers: [],
            isPlacingPlayer: false,
            playerToPlace: null,
            dragging: false,
            lastX: 0,
            lastY: 0,
            clickStartX: 0,
            clickStartY: 0,
            touchMode: null,
            startDist: 0,
            startScale: 1,
            pinchCenter: null,
            startCamX: 0,
            startCamY: 0,
            statsUpdateTime: 0,
            currentTileDetailThreshold: 50,
            isMinimapDragging: false,
            minimapClickStartPos: { x: 0, y: 0 },
            minimapCam: { x: 0, y: 0, scale: 0.1 },
            animationId: null,
            pinnedBookmarks: [],
            openPanel: null,
            isBuildMode: false,
            alliances: [],
            activeAllianceId: null,
            buildModeBuildings: [],
            selectedBuildingType: null,
            claimedTerritory: new Map(), 
            globallyClaimedTiles: new Map(), 
            mouseWorldPos: { x: 0, y: 0 },
            userTerritoryRenderThreshold: 0, 
            userBuildingRenderThreshold: 0,
            infoBannerBuildingId: null, 
            infoBannerUpdateTime: 0, 
            isAllianceDeleteMode: false,
            specialTileMap: new Map(), 
            allVisibleBuildings: [], 
            overwatchSettings: {}, 
            isDevMode: false,
            activeDevTool: null,
        },
        dom: {}, // Will be populated in init()

        // --- CORE INITIALIZATION ---
        loadImage(src) {
            return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
            });
        },

        init() {
            // --- DOM REFERENCES (Updated for new UI) ---
            this.dom = {
            canvas:                           document.getElementById('map'),
            ctx:                              null,
            inpX:                             document.getElementById('inpX'),
            inpY:                             document.getElementById('inpY'),
            btnGo:                            document.getElementById('btnGo'),
            zoomLevelEl:                      document.getElementById('zoomLevel'),
            zoomDecBtn:                       document.getElementById('zoomDecBtn'),
            zoomIncBtn:                       document.getElementById('zoomIncBtn'),
            zoomSlider:                       document.getElementById('zoomSlider'),
            zoomPresetsToggleBtn:             document.getElementById('zoomPresetsToggleBtn'),
            zoomPresetsPanel:                 document.getElementById('zoomPresetsPanel'),
            zoomPresetsList:                  document.getElementById('zoomPresetsList'),
            centerTileEl:                     document.getElementById('centerTile'),
            statsPanel:                       document.getElementById('statsPanel'),
            statsFPSEl:                       document.getElementById('statsFPS'),
            statsTilesEl:                     document.getElementById('statsTiles'),
            coordsToggle:                     document.getElementById('coordsToggle'),
            versionDisplay:                   document.getElementById('versionDisplay'),
            modalOverlay:                     document.getElementById('modalOverlay'),
            patchNotesBtn:                    document.getElementById('patchNotesBtn'),
            patchNotesModal:                  document.getElementById('patchNotesModal'),
            patchNotesBody:                   document.getElementById('patchNotesBody'),
            closePatchNotesBtn:               document.getElementById('closePatchNotesBtn'),
            hidePatchNotesCheckbox:           document.getElementById('hidePatchNotesCheckbox'),
            infoBtn:                          document.getElementById('infoBtn'),
            controlsModal:                    document.getElementById('controlsModal'),
            closeControlsBtn:                 document.getElementById('closeControlsBtn'),
            tileDetailSelect:                 document.getElementById('tileDetailSelect'),
            gridlinesToggle:                  document.getElementById('gridlinesToggle'),
            allianceRssToggle:                document.getElementById('allianceRssToggle'),
            allianceRssAlwaysVisibleToggle:   document.getElementById('allianceRssAlwaysVisibleToggle'),
            settingsToggleBtn: document.getElementById('settingsToggleBtn'),
            settingsPanel: document.getElementById('settingsPanel'),
            minimapContainer: document.getElementById('minimapContainer'),
            minimapToggleBtn: document.getElementById('minimapToggleBtn'),
            minimapCanvas: document.getElementById('minimapCanvas'),
            pinnedBookmarksToggleBtn: document.getElementById('pinnedBookmarksToggleBtn'),
            pinnedBookmarksPanel: document.getElementById('pinnedBookmarksPanel'),
            pinnedBookmarksList: document.getElementById('pinnedBookmarksList'),
            navPanelToggleBtn: document.getElementById('navPanelToggleBtn'),
            navPanel: document.getElementById('navPanel'),
            addBookmarksList: document.getElementById('addBookmarksList'),
            buildModeBanner: document.getElementById('buildModeBanner'),
            buildModeToggleBtn: document.getElementById('buildModeToggleBtn'),
            buildPanel: document.getElementById('buildPanel'),
            allianceNameInput: document.getElementById('allianceName'),
            allianceTagInput: document.getElementById('allianceTag'),
            allianceColorInput: document.getElementById('allianceColor'),
            createAllianceBtn: document.getElementById('createAllianceBtn'),
            allianceList: document.getElementById('allianceList'),
            toggleBuildModeActualBtn: document.getElementById('toggleBuildModeActualBtn'),
            floatingBuildingsBtn: document.getElementById('floatingBuildingsBtn'),
            buildingPalettePanel: document.getElementById('buildingPalettePanel'),
            buildingPaletteList: document.getElementById('buildingPaletteList'),
            editAllianceModal: document.getElementById('editAllianceModal'),
            editAllianceIdInput: document.getElementById('editAllianceId'),
            editAllianceNameInput: document.getElementById('editAllianceName'),
            editAllianceTagInput: document.getElementById('editAllianceTag'),
            editAllianceColorInput: document.getElementById('editAllianceColor'),
            saveAllianceChangesBtn: document.getElementById('saveAllianceChangesBtn'),
            importPlanBtn: document.getElementById('importPlanBtn'),
            exportPlanBtn: document.getElementById('exportPlanBtn'),
            planFileInput: document.getElementById('planFileInput'),
            clearPlanBtn: document.getElementById('clearPlanBtn'),
            userTerritoryRenderSelect: document.getElementById('userTerritoryRenderSelect'),
            userBuildingRenderSelect: document.getElementById('userBuildingRenderSelect'),
            infoBanner: document.getElementById('infoBanner'),
            infoBannerName: document.getElementById('infoBannerName'),
            infoBannerCoords: document.getElementById('infoBannerCoords'),
            overwatchToggleBtn: document.getElementById('overwatchToggleBtn'), 
            overwatchPanel: document.getElementById('overwatchPanel'),       
            overwatchList: document.getElementById('overwatchList'),
            allianceMgtToggleBtn: document.getElementById('allianceMgtToggleBtn'),
            toggleDeleteModeBtn: document.getElementById('toggleDeleteModeBtn'),
            buildMenuToggleBtn: document.getElementById('buildMenuToggleBtn'),
            buildMenuPanel: document.getElementById('buildMenuPanel'),
            buildModeToggleContainer: document.getElementById('buildModeToggleContainer'),
            buildMenuBuildingList: document.getElementById('buildMenuBuildingList'),
            devModePanel: document.getElementById('devModePanel'),
            devModeTools: document.getElementById('devModeTools'),
            exportDevMapBtn: document.getElementById('exportDevMapBtn'),
            placePlayerToggleBtn: document.getElementById('placePlayerToggleBtn'),
            playerPanel: document.getElementById('playerPanel'),
            playerList: document.getElementById('playerList'),
            playerNameInput: document.getElementById('playerNameInput'),
            playerPowerInput: document.getElementById('playerPowerInput'),
            playerColorInput: document.getElementById('playerColorInput'),
            startPlayerPlacementBtn: document.getElementById('startPlayerPlacementBtn'),
            editPlayerModal: document.getElementById('editPlayerModal'),
            editPlayerIdInput: document.getElementById('editPlayerId'),
            editPlayerNameInput: document.getElementById('editPlayerName'),
            editPlayerPowerInput: document.getElementById('editPlayerPower'),
            editPlayerColorInput: document.getElementById('editPlayerColor'),
            savePlayerChangesBtn: document.getElementById('savePlayerChangesBtn'),
            };

            this.dom.ctx = this.dom.canvas.getContext('2d');

            if (this.dom.minimapCanvas) {
            const dpr = window.devicePixelRatio || 1;
            this.dom.minimapCanvas.width = this.config.minimap.width * dpr;
            this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
            this.dom.minimapCtx = this.dom.minimapCanvas.getContext('2d');
            }

            const devMapLoaded = this.loadDevMapFromLocalStorage();

            this.state.lastFrame = performance.now();
            Promise.all([
            // Only fetch the baseMap.json if a dev map was NOT loaded from local storage.
            devMapLoaded ? Promise.resolve(null) : fetch('baseMap.json').then(r => r.ok ? r.json() : { unoccupiableTiles: [], defaultBuildings: [] }),
            fetch('CHANGELOG.md').then(r => r.ok ? r.text() : ''),
            this.loadImage('kings_castle.png'),
            this.loadImage('fortress.png'),  
            this.loadImage('sanctuary.png'),
            this.loadImage('scholar&builder.png'),
            this.loadImage('harvest&forager.png'),
            this.loadImage('armory&arsenal.png'),
            this.loadImage('frontier&drill.png')
            ])
            .then(([baseMapData, changelogText, kingCastleImage, fortressImage, sanctuaryImage, scholarBuilderImg, harvestForagerImg, armoryArsenalImg, frontierDrillImg]) => {
            this.state.buildingImages.set('kings_castle', kingCastleImage); 
            this.state.buildingImages.set('fortress', fortressImage);
            this.state.buildingImages.set('sanctuary', sanctuaryImage);
            this.state.buildingImages.set('scholar_builder', scholarBuilderImg);
            this.state.buildingImages.set('harvest_forager', harvestForagerImg);
            this.state.buildingImages.set('armory_arsenal', armoryArsenalImg);
            this.state.buildingImages.set('frontier_drill', frontierDrillImg);

            // If baseMapData exists (meaning we fetched it), assign it to the state.
            if (baseMapData) {
                Object.assign(this.state.baseMap, baseMapData);
            }
            
            this.state.patchNotes = changelogText;
            this.preProcessBuildings();
            this.preProcessSpecialAreas();
            this.preProcessUnoccupiable(); 
            this.preCalculateChunks();
            this.loadPlanFromLocalStorage();
            this.loadOverwatchSettings(); 
            this.initializeUI();
            this.resize();
            requestAnimationFrame(this.mainLoop.bind(this));
            })
            .catch(e => console.error("Error during initialization:", e));
        },

        initializeUI() {
            // --- 1. DEFINE ALL UI PANELS ---
            // Moved panelMap to this.dom for global access
            this.dom.panelMap = {
                'allianceMgt': { btn: this.dom.allianceMgtToggleBtn, panel: this.dom.buildPanel, persistent: true },
                'buildMenu': { btn: this.dom.buildMenuToggleBtn, panel: this.dom.buildMenuPanel, persistent: true },
                'playerMgt': { btn: this.dom.placePlayerToggleBtn, panel: this.dom.playerPanel, persistent: true },
                'devMode': { btn: null, panel: this.dom.devModePanel, persistent: true },
                'pinnedBookmarks': { btn: this.dom.pinnedBookmarksToggleBtn, panel: this.dom.pinnedBookmarksPanel },
                'nav': { btn: this.dom.navPanelToggleBtn, panel: this.dom.navPanel, persistent: true },
                'overwatch': { btn: this.dom.overwatchToggleBtn, panel: this.dom.overwatchPanel },
                'zoomPresets': { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel },
                'settings': { btn: this.dom.settingsToggleBtn, panel: this.dom.settingsPanel },
            };

            // --- 2. EVENT LISTENERS ---

            // A. Listeners for UI interaction
            document.addEventListener('click', (e) => {
                if (!this.state.openPanel) return;
                const currentPanelInfo = this.dom.panelMap[this.state.openPanel];
                if (currentPanelInfo.persistent) return;
                if (!currentPanelInfo.panel.contains(e.target) && !currentPanelInfo.btn.contains(e.target)) {
                    this.togglePanel(this.state.openPanel, true);
                }
            });

            Object.keys(this.dom.panelMap).forEach(key => {
                const panelInfo = this.dom.panelMap[key];
                if (!panelInfo.btn) return;
                panelInfo.btn.addEventListener('click', (e) => { 
                    e.stopPropagation();
                    if (key === 'allianceMgt') this.renderAlliancePanel();
                    if (key === 'buildMenu') this.renderBuildMenu();
                    if (key === 'playerMgt') this.renderPlayerPanel();
                    if (key === 'overwatch') this.buildOverwatchPanel();
                    this.togglePanel(key); 
                });
            });

            // B. Event Delegation for Alliance & Player Lists
            if (this.dom.allianceList) {
                this.dom.allianceList.addEventListener('click', (e) => {
                    const button = e.target.closest('button');
                    if (!button || !button.dataset.action) return;
                    const action = button.dataset.action;
                    const id = parseInt(button.dataset.id, 10);
                    if (!action || isNaN(id)) return;
                    e.preventDefault();
                    switch (action) {
                        case 'select': this.selectAlliance(id); break;
                        case 'edit': this.showEditAllianceModal(id); break;
                        case 'delete': this.deleteAlliance(id); break;
                    }
                });
            }

            if (this.dom.playerList) {
                this.dom.playerList.addEventListener('click', (e) => {
                    const button = e.target.closest('button');
                    if (!button || !button.dataset.action) return;
                    const action = button.dataset.action;
                    const id = parseInt(button.dataset.id, 10);
                    if (!action || isNaN(id)) return;
                    e.preventDefault();

                    const player = this.state.placedPlayers.find(p => p.id === id);
                    if (!player) return;

                    switch (action) {
                        case 'go': this.goToBookmark(player.x, player.y); break;
                        case 'edit': this.showEditPlayerModal(id); break;
                        case 'delete': this.deletePlayer(id); break;
                    }
                });
            }

            // C. Listeners for other specific buttons
            if (this.dom.toggleDeleteModeBtn) this.dom.toggleDeleteModeBtn.addEventListener('click', () => { this.state.isAllianceDeleteMode = !this.state.isAllianceDeleteMode; this.renderAlliancePanel(); });
            if (this.dom.createAllianceBtn) this.dom.createAllianceBtn.addEventListener('click', this.createAlliance.bind(this));
            if (this.dom.saveAllianceChangesBtn) this.dom.saveAllianceChangesBtn.addEventListener('click', this.saveAllianceChanges.bind(this));
            if (this.dom.savePlayerChangesBtn) this.dom.savePlayerChangesBtn.addEventListener('click', this.savePlayerChanges.bind(this));
            if (this.dom.startPlayerPlacementBtn) this.dom.startPlayerPlacementBtn.addEventListener('click', this.startPlayerPlacement.bind(this));


            // D. Dev Mode Activation and Listeners
            if (this.config.enableDevMode) {
                this.state.isDevMode = true;
                this.dom.devModePanel.style.display = 'flex';
                this.dom.devModePanel.classList.add('open');
                this.renderDevModePanel();
                console.log("Developer Mode enabled via config.");

                if (this.dom.devModeTools) this.dom.devModeTools.addEventListener('click', (e) => {
                    const button = e.target.closest('button');
                    if (button && button.dataset.tool) this.selectDevTool(button.dataset.tool, button.dataset.type || null);
                });
                if (this.dom.exportDevMapBtn) this.dom.exportDevMapBtn.addEventListener('click', () => this.exportDevMap());
            }
            
            // E. Navigation, Modals, and Settings Persistence
            const navPanel = this.dom.navPanel;
            if (navPanel) {
                navPanel.addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab-button')) {
                        const tabId = e.target.dataset.tab;
                        if (!tabId) return;
                        navPanel.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                        navPanel.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                        document.getElementById(tabId)?.classList.add('active');
                    }
                });
            }
            if (this.dom.infoBtn) this.dom.infoBtn.addEventListener('click', this.showControlsModal.bind(this));
            if (this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
            document.querySelectorAll('.modal .close-btn').forEach(btn => btn.addEventListener('click', () => this.hideAllModals()));
            if (this.dom.modalOverlay) this.dom.modalOverlay.addEventListener('click', () => this.hideAllModals());
            if (localStorage.getItem('lastSeenVersion') !== this.config.CURRENT_VERSION) {
                this.showPatchNotes();
            }

            const settingsToPersist = {
                'mapTileDetail': { el: this.dom.tileDetailSelect, default: '49', prop: 'value' },
                'mapShowGridlines': { el: this.dom.gridlinesToggle, default: 'true', prop: 'checked' },
                'mapShowCoords': { el: this.dom.coordsToggle, default: 'true', prop: 'checked' },
                'mapShowAllianceRss': { el: this.dom.allianceRssToggle, default: 'true', prop: 'checked' },
                'mapAlwaysShowRss': { el: this.dom.allianceRssAlwaysVisibleToggle, default: 'false', prop: 'checked' },
                'mapUserTerritoryRender': { el: this.dom.userTerritoryRenderSelect, default: '0', prop: 'value' },
                'mapUserBuildingRender': { el: this.dom.userBuildingRenderSelect, default: '0', prop: 'value' }
            };
            Object.entries(settingsToPersist).forEach(([key, conf]) => {
                if (!conf.el) return;
                const saved = localStorage.getItem(key) ?? conf.default;
                conf.el[conf.prop] = conf.prop === 'checked' ? (saved === 'true') : saved;
                
                if (key === 'mapTileDetail') this.state.currentTileDetailThreshold = parseInt(saved, 10);
                if (key === 'mapUserTerritoryRender') this.state.userTerritoryRenderThreshold = parseInt(saved, 10);
                if (key === 'mapUserBuildingRender') this.state.userBuildingRenderThreshold = parseInt(saved, 10);
                
                conf.el.addEventListener('change', () => {
                    localStorage.setItem(key, String(conf.el[conf.prop]));
                    if (key === 'mapTileDetail') this.state.currentTileDetailThreshold = parseInt(conf.el.value, 10);
                    if (key === 'mapUserTerritoryRender') this.state.userTerritoryRenderThreshold = parseInt(conf.el.value, 10);
                    if (key === 'mapUserBuildingRender') this.state.userBuildingRenderThreshold = parseInt(conf.el.value, 10);
                });
            });
            
            this.loadPinnedBookmarks();
            this.renderAllBookmarkUI();
            if (this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
            
            // F. Map and Window Listeners
            if (this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
            if (this.dom.inpX) this.dom.inpX.addEventListener('keydown', e => { if (e.key === 'Enter') this.doSearch(); });
            if (this.dom.inpY) this.dom.inpY.addEventListener('keydown', e => { if (e.key === 'Enter') this.doSearch(); });
            if (this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-5));
            if (this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+5));
            if (this.dom.zoomSlider) this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));
            this.renderZoomPresets();

            if (this.dom.minimapToggleBtn && this.dom.minimapContainer) {
                this.dom.minimapToggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.dom.minimapContainer.classList.toggle('visible');
                    this.dom.minimapToggleBtn.classList.toggle('active', this.dom.minimapContainer.classList.contains('visible'));
                });
                const isDesktop = window.innerWidth > 768;
                this.dom.minimapContainer.classList.toggle('visible', isDesktop);
                this.dom.minimapToggleBtn.classList.toggle('active', isDesktop);
            }
            
            if (this.dom.exportPlanBtn) this.dom.exportPlanBtn.addEventListener('click', this.exportPlan.bind(this));
            if (this.dom.importPlanBtn) this.dom.importPlanBtn.addEventListener('click', () => this.dom.planFileInput.click());
            if (this.dom.planFileInput) this.dom.planFileInput.addEventListener('change', this.importPlan.bind(this));
            if (this.dom.clearPlanBtn) this.dom.clearPlanBtn.addEventListener('click', this.clearPlan.bind(this));
            if (this.dom.overwatchList) this.dom.overwatchList.addEventListener('change', this.handleOverwatchChange.bind(this));

            window.addEventListener('resize', this.resize.bind(this));
            window.addEventListener('mousemove', this.handleMouseMove.bind(this));
            window.addEventListener('mouseup', () => { this.state.dragging = false; });
            this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
            this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
            this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
            this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
            this.dom.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
            this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
            this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
            this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
            if (this.dom.minimapCanvas) {
                this.dom.minimapCanvas.addEventListener('mousedown', this.handleMinimapMouseDown.bind(this));
                this.dom.minimapCanvas.addEventListener('mousemove', this.handleMinimapMouseMove.bind(this));
                this.dom.minimapCanvas.addEventListener('mouseleave', this.handleMinimapMouseUp.bind(this));
                window.addEventListener('mouseup', this.handleMinimapMouseUp.bind(this));
            }

            // G. FINAL, CORRECT KEYDOWN LISTENER
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                
                switch (e.key) {
                    case '+': case '=': this.changeZoomBy(+5); break;
                    case '-':           this.changeZoomBy(-5); break;
                    case 'ArrowUp':     this.state.cam.y += this.config.tileW * 5; this.clampCamera(); break;
                    case 'ArrowDown':   this.state.cam.y -= this.config.tileW * 5; this.clampCamera(); break;
                    case 'ArrowLeft':   this.state.cam.x += this.config.tileW * 5; this.clampCamera(); break;
                    case 'ArrowRight':  this.state.cam.x -= this.config.tileW * 5; this.clampCamera(); break;
                    case 'Escape':
                        if (this.state.isPlacingPlayer) {
                            this.state.isPlacingPlayer = false;
                            this.state.playerToPlace = null;
                            this.dom.canvas.classList.remove('build-cursor');
                        } else if (this.state.isBuildMode && this.state.selectedBuildingType) {
                            this.selectBuildingToPlace(this.state.selectedBuildingType); // Deselect
                        } else if (this.state.isDevMode && this.state.activeDevTool) {
                            this.selectDevTool(this.state.activeDevTool.tool, this.state.activeDevTool.type); // Deselect
                        }
                        break;
                }
            });
        },

        setBuildModeActive() {
            this.state.isBuildMode = !this.state.isBuildMode;
            const isActive = this.state.isBuildMode;

            this.dom.buildModeBanner.style.display = isActive ? 'block' : 'none';
            if (isActive) {
                this.updateBanner();
            }

            if (!isActive) {
                this.state.selectedBuildingType = null;
                this.dom.canvas.classList.remove('build-cursor');
            }

            // Always re-render the build menu to update button states
            this.renderBuildMenu();
            // *** ADD THIS to update the info banner's position immediately ***
            this.updateInfoBanner();
        },

        updateBanner() {
            if (this.state.isBuildMode && this.state.activeAllianceId) {
                const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);
                if (alliance) {
                    this.dom.buildModeBanner.textContent = `Building as [${alliance.tag}] ${alliance.name}`;
                    this.dom.buildModeBanner.style.backgroundColor = alliance.color;
                    // *** FIX IS HERE: Set text color for contrast ***
                    this.dom.buildModeBanner.style.color = this.getContrastingTextColor(alliance.color);
                }
            } else {
                this.dom.buildModeBanner.textContent = "Build Mode Enabled";
                this.dom.buildModeBanner.style.backgroundColor = 'var(--build-mode-bg)';
                // *** FIX IS HERE: Reset text color to default ***
                this.dom.buildModeBanner.style.color = 'white';
            }
        },

        // Add this function
        getControlledResources(allianceId) {
            const counts = { food: 0, wood: 0, stone: 0, iron: 0 };
            const claimedSet = this.state.claimedTerritory.get(allianceId);
            if (!claimedSet || claimedSet.size === 0 || !this.state.baseMap.allianceRssBuildings) {
                return counts;
            }

            const rssBuildings = this.state.baseMap.allianceRssBuildings;

            for (const rss of rssBuildings) {
                let coveredTiles = 0;
                // A resource building is 2x2
                for (let dx = 0; dx < 2; dx++) {
                    for (let dy = 0; dy < 2; dy++) {
                        if (claimedSet.has(`${rss.x + dx},${rss.y + dy}`)) {
                            coveredTiles++;
                        }
                    }
                }
                // It's controlled if 3 or 4 of its tiles are in the claimed territory
                if (coveredTiles >= 3) {
                    if (counts.hasOwnProperty(rss.type)) {
                        counts[rss.type]++;
                    }
                }
            }
            return counts;
        },

        // Add this function
        getControlledOutposts(allianceId) {
            const controlled = [];
            const claimedSet = this.state.claimedTerritory.get(allianceId);
            if (!claimedSet || claimedSet.size === 0) {
                return controlled;
            }

            // Get all default buildings that have a forbiddenArea defined.
            // This correctly targets outposts without needing to check the name.
            const outposts = this.state.allBuildings.filter(b => b.forbiddenArea && !b.allianceId);

            for (const outpost of outposts) {
                let isControlled = false;

                // Calculate the boundaries of the forbidden area
                const radius = Math.floor(outpost.forbiddenArea / 2);
                const centerX = outpost.x + Math.floor(outpost.w / 2);
                const centerY = outpost.y + Math.floor(outpost.h / 2);
                const startX = centerX - radius;
                const startY = centerY - radius;
                const endX = startX + outpost.forbiddenArea;
                const endY = startY + outpost.forbiddenArea;

                // Loop through every tile in the forbidden area to check its neighbors
                for (let x = startX; x < endX; x++) {
                    for (let y = startY; y < endY; y++) {
                        // Check the 4 neighbors of the current forbidden tile to see if they are in the claimed set
                        if (claimedSet.has(`${x + 1},${y}`) ||
                            claimedSet.has(`${x - 1},${y}`) ||
                            claimedSet.has(`${x},${y + 1}`) ||
                            claimedSet.has(`${x},${y - 1}`)) 
                        {
                            isControlled = true;
                            break; // Exit the inner y-loop since we found a connection
                        }
                    }
                    if (isControlled) {
                        break; // Exit the outer x-loop as well
                    }
                }

                if (isControlled) {
                    controlled.push(outpost);
                }
            }
            return controlled;
        },

        // Add this function to create list items dynamically
        createBookmarkHTML(building) {
            return `
                <div class="hq-list-item">
                    <span>${building.displayName}</span>
                    <div class="controls">
                        <button class="go-btn" data-x="${building.x}" data-y="${building.y}">Go</button>
                        <button class="pin-btn" data-x="${building.x}" data-y="${building.y}" data-name="${building.displayName}">Pin</button>
                    </div>
                </div>
            `;
        },

        createAlliance() {
            const name = this.dom.allianceNameInput.value.trim();
            const tag = this.dom.allianceTagInput.value.trim().toUpperCase();
            const color = this.dom.allianceColorInput.value;

            if (!name || !tag || tag.length === 0 || tag.length > 3) {
                alert("Please provide a valid alliance name and a 3 character tag.");
                return;
            }

            const newAlliance = {
                id: Date.now(),
                name,
                tag,
                color
            };

            this.state.alliances.push(newAlliance);
            this.savePlanToLocalStorage();
            this.dom.allianceNameInput.value = '';
            this.dom.allianceTagInput.value = '';
            this.renderAlliancePanel();
        },

        selectAlliance(id) {
            const isDeselecting = this.state.activeAllianceId === id;
            this.state.activeAllianceId = isDeselecting ? null : id;
            
            this.updateBanner();
            this.renderAlliancePanel(); // Re-render to update the "active builder" highlight
            this.renderBuildMenu(); // Re-render to update the build menu state
        },
        
        deleteAlliance(id) {
            if (!confirm("Are you sure you want to delete this alliance and all its buildings? This cannot be undone.")) {
                return;
            }
            this.state.alliances = this.state.alliances.filter(a => a.id !== id);
            this.state.buildModeBuildings = this.state.buildModeBuildings.filter(b => b.allianceId !== id);
            if (this.state.activeAllianceId === id) {
                this.state.activeAllianceId = null;
                this.updateBanner();
            }
            this.recalculateAllClaimedTerritory();
            this.savePlanToLocalStorage();
            
            this.state.isAllianceDeleteMode = false;
            this.renderAlliancePanel();
        },

        renderAlliancePanel() {
            if (!this.dom.allianceList) return;
            this.dom.allianceList.innerHTML = '';

            if (this.dom.toggleDeleteModeBtn) {
                this.dom.toggleDeleteModeBtn.textContent = this.state.isAllianceDeleteMode ? 'Cancel Deletion' : 'Delete Alliance';
                this.dom.toggleDeleteModeBtn.classList.toggle('active', this.state.isAllianceDeleteMode);
            }

            this.state.alliances.forEach(alliance => {
                const details = document.createElement('details');
                details.className = 'alliance-item';
                details.dataset.allianceId = alliance.id;
                details.style.borderLeftColor = alliance.color;

                const isSelected = alliance.id === this.state.activeAllianceId;
                if (isSelected) {
                    details.classList.add('is-active-builder');
                }

                const summary = document.createElement('summary');
                let controlsHTML = '';

                // Generate button HTML with data attributes instead of onclick listeners
                if (this.state.isAllianceDeleteMode) {
                    controlsHTML = `<button class="danger delete-confirm-btn" data-action="delete" data-id="${alliance.id}">Delete this alliance</button>`;
                } else {
                    const selectClass = isSelected ? 'warning' : 'primary';
                    controlsHTML = `
                        <button data-action="edit" data-id="${alliance.id}">Edit</button>
                        <button class="${selectClass}" data-action="select" data-id="${alliance.id}">${isSelected ? 'Selected' : 'Select'}</button>
                    `;
                }
                
                summary.innerHTML = `
                    <div class="color-swatch" style="background-color: ${alliance.color};"></div>
                    <div class="name">${alliance.name}</div>
                    <div class="tag">${alliance.tag}</div>
                    <div class="controls">${controlsHTML}</div>
                `;
                details.appendChild(summary);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'alliance-details-content';
                details.appendChild(contentDiv);

                details.addEventListener('toggle', () => {
                    if (details.open) {
                        this.renderAllianceDetails(contentDiv, alliance.id);
                    } else {
                        contentDiv.innerHTML = '';
                    }
                });

                this.dom.allianceList.appendChild(details);
            });
        },

        renderAllianceDetails(container, allianceId) {
            const alliance = this.state.alliances.find(a => a.id === allianceId);
            if (!alliance) {
                container.innerHTML = '<p>Alliance not found.</p>';
                return;
            }

            const allianceBuildings = this.state.buildModeBuildings.filter(b => b.allianceId === allianceId);
            const towerCount = allianceBuildings.filter(b => b.type === 'alliance_tower').length;
            const hqs = allianceBuildings.filter(b => b.type.startsWith('hq_'));
            const controlledResources = this.getControlledResources(allianceId);
            const controlledOutposts = this.getControlledOutposts(allianceId);

            // *** MODIFICATION START ***
            // For HQs, use the building's own displayText which now includes the formatted tag
            const hqHTML = hqs.length > 0 
                ? hqs.map(hq => this.createBookmarkHTML({ ...this.BUILDING_CATALOG[hq.type], x: hq.x, y: hq.y, displayName: hq.displayText })).join('')
                : '<span>No HQs placed.</span>';

            // For Outposts (default buildings), we still need to prepend the formatted tag
            const outpostHTML = controlledOutposts.length > 0
                ? controlledOutposts.map(op => {
                    const taggedDisplayName = `[${alliance.tag}] ${op.displayName}`;
                    return this.createBookmarkHTML({ ...op, displayName: taggedDisplayName });
                }).join('')
                : '<span>No outposts controlled.</span>';
            // *** MODIFICATION END ***

            container.innerHTML = `
                <h5>Headquarters</h5>
                <div class="hq-list">${hqHTML}</div>
                <h5>Statistics</h5>
                <div class="stats-grid">
                    <span>Towers Built:</span><strong>${towerCount}</strong>
                    <span>Food Controlled:</span><strong>${controlledResources.food}</strong>
                    <span>Wood Controlled:</span><strong>${controlledResources.wood}</strong>
                    <span>Stone Controlled:</span><strong>${controlledResources.stone}</strong>
                    <span>Iron Controlled:</span><strong>${controlledResources.iron}</strong>
                </div>
                <h5>Outposts Controlled</h5>
                <div class="outpost-list">${outpostHTML}</div>
            `;

            // Add event listeners to the newly created Go and Pin buttons
            container.querySelectorAll('.go-btn').forEach(btn => {
                btn.onclick = () => this.goToBookmark(parseInt(btn.dataset.x, 10), parseInt(btn.dataset.y, 10));
            });
            container.querySelectorAll('.pin-btn').forEach(btn => {
                const building = { x: parseInt(btn.dataset.x, 10), y: parseInt(btn.dataset.y, 10), displayName: btn.dataset.name };
                btn.onclick = () => this.pinBookmark(building);
            });
        },

        showEditAllianceModal(allianceId) {
            const alliance = this.state.alliances.find(a => a.id === allianceId);
            if (!alliance) return;
            this.dom.editAllianceIdInput.value = alliance.id;
            this.dom.editAllianceNameInput.value = alliance.name;
            this.dom.editAllianceTagInput.value = alliance.tag;
            this.dom.editAllianceColorInput.value = alliance.color;
            this.dom.modalOverlay.style.display = 'block';
            this.dom.editAllianceModal.style.display = 'block';
        },

        saveAllianceChanges() {
            const id = parseInt(this.dom.editAllianceIdInput.value, 10);
            const alliance = this.state.alliances.find(a => a.id === id);
            if (!alliance) return;
            const newName = this.dom.editAllianceNameInput.value.trim();
            const newTag = this.dom.editAllianceTagInput.value.trim().toUpperCase();
            if (!newName || !newTag || newTag.length === 0 || newTag.length > 3) {
                alert("Please provide a valid alliance name and a 3 character tag.");
                return;
            }
            alliance.name = newName;
            alliance.tag = newTag;
            alliance.color = this.dom.editAllianceColorInput.value;
            this.savePlanToLocalStorage();
            this.renderAlliancePanel();
            this.updateBanner();
            this.hideAllModals();
        },

        // New function to show the modal
        showPlacePlayerModal() {
            this.dom.modalOverlay.style.display = 'block';
            this.dom.placePlayerModal.style.display = 'block';
        },

        // New function to start the placement process
        startPlayerPlacement() {
            const name = this.dom.playerNameInput.value.trim();
            const power = this.dom.playerPowerInput.value.trim();
            const color = this.dom.playerColorInput.value;

            if (!name) {
                alert('Player name cannot be empty.');
                return;
            }
            if (power.length > 6) {
                alert('Rally Capacity must not be more than 6 characters (e.g., 420k, 1.23m).');
                return;
            }

            this.state.isPlacingPlayer = true;
            this.state.playerToPlace = { name, power, color };

            this.dom.canvas.classList.add('build-cursor');
            
            // Close the sidebar panel for better visibility during placement
            const panelInfo = { btn: this.dom.placePlayerToggleBtn, panel: this.dom.playerPanel };
            panelInfo.panel.classList.remove('open');
            panelInfo.btn.classList.remove('active');
            this.state.openPanel = null;
        },

        // New helper function to check for player collisions
        getPlayerAtCoords(x, y) {
            for (const p of this.state.placedPlayers) {
                if (x >= p.x && x < p.x + p.w && y >= p.y && y < p.y + p.h) {
                    return p;
                }
            }
            return null;
        },

        // New function to perform validity checks and add the player to the state
        placePlayer(x, y) {
            if (!this.state.playerToPlace) return;

            const def = this.PLAYER_CATALOG['player_castle'];

            for (let dx = 0; dx < def.w; dx++) {
                for (let dy = 0; dy < def.h; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    if (this.getBuildingAtCoords(checkX, checkY) || this.getPlayerAtCoords(checkX, checkY)) {
                        alert("Cannot place: Collision with another object.");
                        return;
                    }
                    if (this.state.specialTileMap.has(`${checkX},${checkY}`)) {
                        alert("Cannot place on Ruins or Forbidden Area tiles.");
                        return;
                    }
                }
            }

            const newPlayer = {
                id: Date.now(),
                type: 'player_castle',
                x, y,
                w: def.w, h: def.h,
                name: this.state.playerToPlace.name,
                power: this.state.playerToPlace.power,
                color: this.state.playerToPlace.color
            };

            this.state.placedPlayers.push(newPlayer);
            this.savePlanToLocalStorage();
            this.renderPlayerPanel(); // Re-render list to show the new player
        },

        renderPlayerPanel() {
            if (!this.dom.playerList) return;
            this.dom.playerList.innerHTML = ''; // Clear the list

            // Step 1: Decorate each player with their owning alliance
            const decoratedPlayers = this.state.placedPlayers.map(player => ({
                ...player,
                owningAlliance: this.getOwningAllianceForPlayer(player)
            }));

            // Step 2: Sort the decorated players
            decoratedPlayers.sort((a, b) => {
                const tagA = a.owningAlliance ? a.owningAlliance.tag : 'ZZZ'; // Unaffiliated players last
                const tagB = b.owningAlliance ? b.owningAlliance.tag : 'ZZZ';

                if (tagA < tagB) return -1;
                if (tagA > tagB) return 1;

                // If tags are the same, sort by player name
                return a.name.localeCompare(b.name);
            });

            // Step 3: Render the sorted list
            decoratedPlayers.forEach(player => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.style.borderLeftColor = player.color;

                const allianceTagHTML = player.owningAlliance ? `[${player.owningAlliance.tag}] ` : '';

                item.innerHTML = `
                    <div class="color-swatch" style="background-color: ${player.color};"></div>
                    <div class="info">
                        <div class="name">${allianceTagHTML}${player.name}</div>
                        <div class="power">${player.power}</div>
                    </div>
                    <div class="controls">
                        <button class="primary" data-action="go" data-id="${player.id}">Go</button>
                        <button data-action="edit" data-id="${player.id}">Edit</button>
                        <button class="danger" data-action="delete" data-id="${player.id}">Del</button>
                    </div>
                `;
                this.dom.playerList.appendChild(item);
            });
        },
        deletePlayer(id) {
            const player = this.state.placedPlayers.find(p => p.id === id);
            if (player && confirm(`Are you sure you want to delete player "${player.name}"?`)) {
                this.state.placedPlayers = this.state.placedPlayers.filter(p => p.id !== id);
                this.savePlanToLocalStorage();
                this.renderPlayerPanel(); // Re-render the list
            }
        },

        getOwningAllianceForPlayer(player) {
            if (!player) return null;
            // Check the top-left tile of the player's 2x2 footprint
            const coordStr = `${player.x},${player.y}`;
            const allianceId = this.state.globallyClaimedTiles.get(coordStr);

            if (allianceId) {
                return this.state.alliances.find(a => a.id === allianceId) || null;
            }
            return null;
        },

        showEditPlayerModal(id) {
            const player = this.state.placedPlayers.find(p => p.id === id);
            if (!player) return;

            this.dom.editPlayerIdInput.value = player.id;
            this.dom.editPlayerNameInput.value = player.name;
            this.dom.editPlayerPowerInput.value = player.power;
            this.dom.editPlayerColorInput.value = player.color;

            this.dom.modalOverlay.style.display = 'block';
            this.dom.editPlayerModal.style.display = 'block';
        },

        savePlayerChanges() {
            const id = parseInt(this.dom.editPlayerIdInput.value, 10);
            const player = this.state.placedPlayers.find(p => p.id === id);
            if (!player) return;

            const newName = this.dom.editPlayerNameInput.value.trim();
            const newPower = this.dom.editPlayerPowerInput.value.trim();

            if (!newName) {
                alert("Player name cannot be empty.");
                return;
            }
            if (newPower.length > 6) {
                alert("Rally Capacity must not be more than 6 characters (e.g., 420k, 1.23m).");
                return;
            }

            player.name = newName;
            player.power = newPower;
            player.color = this.dom.editPlayerColorInput.value;

            this.savePlanToLocalStorage();
            this.renderPlayerPanel(); // Re-render the list with the new info
            this.hideAllModals();
        },

        hideAllModals() {
            this.dom.modalOverlay.style.display = 'none';
            this.dom.patchNotesModal.style.display = 'none';
            this.dom.controlsModal.style.display = 'none';
            this.dom.editAllianceModal.style.display = 'none';
            this.dom.editPlayerModal.style.display = 'none';
        },

        // Add this as a new method to the main KingshotPlanner object
        togglePanel(panelName, forceClose = false) {
            const panelInfo = this.dom.panelMap[panelName];
            if (!panelInfo) return;

            const isCurrentlyOpen = panelInfo.panel.classList.contains('open');
            const shouldOpen = !isCurrentlyOpen && !forceClose;

            // Close any currently open panel
            if (this.state.openPanel && this.dom.panelMap[this.state.openPanel]) {
                const currentPanel = this.dom.panelMap[this.state.openPanel];
                currentPanel.panel.classList.remove('open');
                if (currentPanel.btn) currentPanel.btn.classList.remove('active');
            }

            // Open the new panel if required
            if (shouldOpen) {
                panelInfo.panel.classList.add('open');
                if (panelInfo.btn) panelInfo.btn.classList.add('active');
                this.state.openPanel = panelName;
            } else {
                // If we're closing the current panel or not opening a new one
                this.state.openPanel = null;
            }
        },

        // --- OVERWATCH SYSTEM ---
        buildOverwatchPanel() {
            this.dom.overwatchList.innerHTML = '';
            const categories = {
                'King\'s Castle': { parent: true, children: [] },
                'Fortress': { parent: true, children: [] },
                'Sanctuary': { parent: true, children: [] },
                'Outpost': { parent: true, children: [] },
                'Alliance Resource Buildings': { parent: true, children: [] }
            };
            this.state.allBuildings.forEach(b => {
                if (b.displayName.includes('King\'s Castle')) categories['King\'s Castle'].children.push(b);
                else if (b.displayName.includes('Fortress')) categories['Fortress'].children.push(b);
                else if (b.displayName.includes('Sanctuary')) categories['Sanctuary'].children.push(b);
                else if (b.isRss) categories['Alliance Resource Buildings'].children.push(b);
                else if (b.displayName.includes('Lv.')) categories['Outpost'].children.push(b);
            });
            
            const createCheckbox = (id, label, isChild = false, isChecked = true) => {
                const div = document.createElement('div');
                div.className = `overwatch-item ${isChild ? 'child' : ''}`;
                div.innerHTML = `<label><input type="checkbox" data-id="${id}" ${isChecked ? 'checked' : ''}> ${label}</label>`;
                return div;
            };
            for (const [category, data] of Object.entries(categories)) {
                if (data.children.length > 0 || category === 'Alliance Resource Buildings') {
                    const parentId = category.toLowerCase().replace(/\s/g, '_');
                    const parentChecked = this.state.overwatchSettings[parentId] !== false;
                    const details = document.createElement('details');
                    // Add a specific data attribute for CSS targeting
                    details.dataset.category = parentId; 
                    
                    const summary = document.createElement('summary');
                    
                    const parentCheckbox = document.createElement('input');
                    parentCheckbox.type = 'checkbox';
                    parentCheckbox.dataset.id = parentId;
                    parentCheckbox.checked = parentChecked;
                    
                    summary.appendChild(parentCheckbox);
                    summary.append(` ${category}`);
                    details.appendChild(summary);
                    if (category === 'Alliance Resource Buildings') {
                        Object.keys(this.config.ALLIANCE_RSS_STYLES).forEach(type => {
                            const childId = `resource_${type}`;
                            const childChecked = this.state.overwatchSettings[childId] !== false;
                            details.appendChild(createCheckbox(childId, this.config.ALLIANCE_RSS_STYLES[type].displayName, true, childChecked));
                        });
                    } else {
                        data.children.forEach(b => {
                            const childId = b.id || `${b.x},${b.y}`;
                            const childChecked = this.state.overwatchSettings[childId] !== false;
                            details.appendChild(createCheckbox(childId, b.displayName, true, childChecked));
                        });
                    }
                    this.dom.overwatchList.appendChild(details);
                }
            }
        },

        handleOverwatchChange(e) {
            const checkbox = e.target;
            const id = checkbox.dataset.id;
            const isChecked = checkbox.checked;
            this.state.overwatchSettings[id] = isChecked;
            const parentDetails = checkbox.closest('details');
            if (!parentDetails) return;
            // Check if the clicked checkbox is in the <summary> (a parent)
            if (checkbox.parentElement === parentDetails.querySelector('summary')) {
                // This is a parent checkbox, update all children within its <details> tag
                parentDetails.querySelectorAll('.overwatch-item input[type="checkbox"]').forEach(childCheckbox => {
                    childCheckbox.checked = isChecked;
                    this.state.overwatchSettings[childCheckbox.dataset.id] = isChecked;
                });
            }
            this.saveOverwatchSettings();
        },

        saveOverwatchSettings() {
            localStorage.setItem('kingshot_overwatch_settings', JSON.stringify(this.state.overwatchSettings));
        },

        loadOverwatchSettings() {
            const saved = localStorage.getItem('kingshot_overwatch_settings');
            if (saved) {
                try {
                    this.state.overwatchSettings = JSON.parse(saved);
                    console.log("Overwatch settings loaded.");
                } catch (e) {
                    console.error("Could not parse Overwatch settings:", e);
                    this.state.overwatchSettings = {};
                }
            }
        },
        
        selectBuildingToPlace(type) {
            const isDeselecting = this.state.selectedBuildingType === type;
            this.state.selectedBuildingType = isDeselecting ? null : type;

            this.dom.canvas.classList.toggle('build-cursor', !!this.state.selectedBuildingType);
            // *** Update to target the new building list ***
            this.dom.buildMenuBuildingList.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === this.state.selectedBuildingType);
            });
        },

        renderBuildMenu() {
            if (!this.dom.buildMenuPanel) return;

            const toggleContainer = this.dom.buildModeToggleContainer;
            const buildingList = this.dom.buildMenuBuildingList;
            toggleContainer.innerHTML = '';
            buildingList.innerHTML = '';

            const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);

            // Step 1: Handle the "Enter/Exit Build Mode" button area
            if (!alliance) {
                toggleContainer.innerHTML = `<div class="placeholder-text">Select an alliance first</div>`;
            } else {
                const btn = document.createElement('button');
                btn.textContent = this.state.isBuildMode ? 'Exit Build Mode' : 'Enter Build Mode';
                btn.className = this.state.isBuildMode ? 'danger' : 'primary';
                btn.onclick = () => this.setBuildModeActive();
                toggleContainer.appendChild(btn);
            }

            // Step 2: Render the building list
            const allianceBuildings = this.state.buildModeBuildings.filter(b => b.allianceId === this.state.activeAllianceId);
            const buildingCounts = allianceBuildings.reduce((acc, b) => {
                acc[b.type] = (acc[b.type] || 0) + 1;
                return acc;
            }, {});

            for (const [type, def] of Object.entries(this.BUILDING_CATALOG)) {
                const btn = document.createElement('button');
                btn.dataset.type = type;
                btn.innerHTML = `${def.name}<br><span>S: ${def.w}x${def.h} | R: ${def.coverage}x${def.coverage}</span>`;
                
                // Logic for disabling the button
                let isDisabled = false;
                let title = '';

                if (!this.state.isBuildMode) {
                    isDisabled = true;
                    title = 'Enter Build Mode to place buildings.';
                } else if (def.limit > 0) {
                    const currentCount = buildingCounts[type] || 0;
                    if (currentCount >= def.limit) {
                        isDisabled = true;
                        title = `Limit of ${def.limit} reached`;
                    }
                }
                
                btn.disabled = isDisabled;
                btn.title = title;

                if (this.state.selectedBuildingType === type) {
                    btn.classList.add('selected');
                }
                btn.onclick = () => this.selectBuildingToPlace(type);
                buildingList.appendChild(btn);
            }
        },

        savePlanToLocalStorage() {
            try {
                const planData = {
                    alliances: this.state.alliances,
                    buildings: this.state.buildModeBuildings,
                    placedPlayers: this.state.placedPlayers
                };
                localStorage.setItem('kingshot_build_plan', JSON.stringify(planData));
            } catch(e) {
                console.error("Could not save plan to local storage:", e);
            }
        },

        loadPlanFromLocalStorage() {
            try {
                const savedPlan = localStorage.getItem('kingshot_build_plan');
                if (savedPlan) {
                    const data = JSON.parse(savedPlan);
                    if (data && Array.isArray(data.alliances) && Array.isArray(data.buildings)) {
                        this.state.alliances = data.alliances;
                        this.state.buildModeBuildings = data.buildings;
                        this.state.placedPlayers = data.placedPlayers || [];
                        this.updateVisibleBuildingsList();
                        this.recalculateAllClaimedTerritory();
                        console.log("Backup plan loaded from browser storage.");
                    }
                }
            } catch (e) {
                console.error("Could not load plan from local storage:", e);
                localStorage.removeItem('kingshot_build_plan');
            }
        },

        clearPlan() {
            if (confirm("Are you sure you want to clear the entire plan? This will delete all alliances, buildings, and placed players and cannot be undone.")) {
                this.state.alliances = [];
                this.state.buildModeBuildings = [];
                this.state.placedPlayers = [];
                this.state.activeAllianceId = null;
                
                if(this.state.isBuildMode) {
                    this.setBuildModeActive();
                }
                
                this.updateVisibleBuildingsList();
                this.recalculateAllClaimedTerritory();
                localStorage.removeItem('kingshot_build_plan');
                
                if(this.dom.buildPanel.classList.contains('open')) {
                this.renderAlliancePanel();
                }
                if(this.dom.playerPanel.classList.contains('open')) {
                    this.renderPlayerPanel();
                }
                
                alert("Plan cleared.");
            }
        },

        exportPlan() {
            if (this.state.alliances.length === 0 && this.state.buildModeBuildings.length === 0 && this.state.placedPlayers.length === 0) {
                alert("Nothing to export. Create some alliances, buildings, or players first.");
                return;
            }
            const planData = {
                version: 1.1,
                alliances: this.state.alliances,
                buildings: this.state.buildModeBuildings,
                placedPlayers: this.state.placedPlayers
            };
            const jsonString = JSON.stringify(planData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kingshot-plan-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        },

        importPlan(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data && (data.version === 1 || data.version === 1.1) && Array.isArray(data.alliances) && Array.isArray(data.buildings)) {
                        if (!confirm("This will overwrite your current plan. Are you sure?")) {
                            this.dom.planFileInput.value = '';
                            return;
                        }
                        this.state.alliances = data.alliances;
                        this.state.buildModeBuildings = data.buildings;
                        this.state.placedPlayers = data.placedPlayers || [];
                        this.updateVisibleBuildingsList();
                        this.recalculateAllClaimedTerritory();
                        this.savePlanToLocalStorage();
                        if(this.state.isBuildMode) {
                        this.renderAlliancePanel();
                        }
                        alert("Plan imported successfully!");
                    } else {
                        throw new Error("Invalid or unsupported plan file format.");
                    }
                } catch (error) {
                    alert(`Error importing plan: ${error.message}`);
                    console.error(error);
                } finally {
                this.dom.planFileInput.value = '';
                }
            };
            reader.readAsText(file);
        },

        recalculateAllClaimedTerritory() {
            this.state.globallyClaimedTiles.clear();
            this.state.claimedTerritory.clear();
            this.state.alliances.forEach(a => this.state.claimedTerritory.set(a.id, new Set()));
            
            for (const b of this.state.buildModeBuildings) {
                const def = this.BUILDING_CATALOG[b.type];
                if (!def || def.coverage <= 0) continue;

                const allianceTerritory = this.state.claimedTerritory.get(b.allianceId);
                if (!allianceTerritory) continue;
                
                const radius = Math.floor(def.coverage / 2);
                const centerX = b.x + Math.floor(def.w / 2);
                const centerY = b.y + Math.floor(def.h / 2);

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const tileX = centerX + dx;
                        const tileY = centerY + dy;
                        const coordStr = `${tileX},${tileY}`;

                        // *** NEW: Prevent claiming special tiles ***
                        if (this.state.specialTileMap.has(coordStr)) {
                            continue;
                        }

                        // Prevent claiming over another alliance's territory
                        if (!this.state.globallyClaimedTiles.has(coordStr)) {
                            this.state.globallyClaimedTiles.set(coordStr, b.allianceId);
                            allianceTerritory.add(coordStr);
                        }
                    }
                }
            }
        },

        updateVisibleBuildingsList() {
            this.state.allVisibleBuildings = this.state.allBuildings.concat(this.state.buildModeBuildings);
        },

        isTileClaimedBy(x, y, allianceId) {
            const territory = this.state.claimedTerritory.get(allianceId);
            return territory ? territory.has(`${x},${y}`) : false;
        },
        
        getBuildingAtCoords(x, y) {
            const defaultBuilding = this.getBuildingAt(x, y);
            if (defaultBuilding) return defaultBuilding;
            
            for (const b of this.state.buildModeBuildings) {
                if (x >= b.x && x < b.x + b.w && y >= b.y && y < b.y + b.h) {
                    return b;
                }
            }
            return null;
        },

        checkPlacementValidity(type, x, y) {
            const def = this.BUILDING_CATALOG[type];
            const allianceId = this.state.activeAllianceId;
            if (!def || !allianceId) return { canPlace: false, message: "No building type or alliance selected." };

            if (def.limit > 0) {
                const count = this.state.buildModeBuildings.filter(b => b.allianceId === allianceId && b.type === type).length;
                if (count >= def.limit) {
                    return { canPlace: false, message: `Limit of ${def.limit} for ${def.name} reached for this alliance.` };
                }
            }

            // Check every tile the new building would occupy
            for (let dx = 0; dx < def.w; dx++) {
                for (let dy = 0; dy < def.h; dy++) {
                    const tileX = x + dx;
                    const tileY = y + dy;
                    const coordStr = `${tileX},${tileY}`;

                    // 1. Check for collision with another building
                    if (this.getBuildingAtCoords(tileX, tileY)) {
                        return { canPlace: false, message: "Collision with another building." };
                    }
                    
                    // NEW: Check for unoccupiable base tiles
                    if (this.state.unoccupiableTileSet.has(coordStr)) {
                        return { canPlace: false, message: "Cannot place on an unoccupiable tile." };
                    }

                    // *** FIX IS HERE: Check if the tile is a special biome tile ***
                    if (this.state.specialTileMap.has(coordStr)) {
                        return { canPlace: false, message: "Cannot place on Ruins or Forbidden Area tiles." };
                    }
                }
            }
            
            // Check for placing a tower in another alliance's territory
            if (type === 'alliance_tower') {
                const claimedBy = this.state.globallyClaimedTiles.get(`${x},${y}`);
                if (claimedBy && claimedBy !== allianceId) {
                    return { canPlace: false, message: "Cannot place a tower in another alliance's territory." };
                }
            }

            // Check for biome-specific rules (like HQs) or territory rules (like Statues)
            if (def.rule === 'claimed') {
                let isClaimed = false;
                for (let dx = 0; dx < def.w; dx++) {
                    for (let dy = 0; dy < def.h; dy++) {
                        if (this.isTileClaimedBy(x + dx, y + dy, allianceId)) {
                            isClaimed = true;
                            break;
                        }
                    }
                    if(isClaimed) break;
                }
                if (!isClaimed) return { canPlace: false, message: "Must be placed on own alliance territory." };
            } else if (def.rule !== 'any') {
                const biome = this.getBiomeForTile(x, y);
                if (biome !== def.rule) {
                    return { canPlace: false, message: `Must be placed in ${def.rule} biome.` };
                }
            }

            return { canPlace: true, message: "OK" };
        },

        placeBuilding(type, x, y) {
            if (!this.state.activeAllianceId) return;
            const def = this.BUILDING_CATALOG[type];
            if (!def) return;

            const { canPlace, message } = this.checkPlacementValidity(type, x, y);
            if (!canPlace) {
                alert(`Cannot place building: ${message}`);
                console.warn(`Cannot place building: ${message}`);
                return;
            }

            const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);
            
            // *** FIX IS HERE: Create the correct display text with brackets ***
            let text = def.text.replace('tag', `[${alliance.tag}]`);

            const newBuilding = {
                id: Date.now(),
                type, x, y,
                w: def.w, h: def.h,
                allianceId: this.state.activeAllianceId,
                displayText: text
            };
            
            this.state.buildModeBuildings.push(newBuilding);
            this.updateVisibleBuildingsList();
            this.recalculateAllClaimedTerritory();
            this.savePlanToLocalStorage();
        },

        deleteBuildModeBuilding(buildingId) {
            this.state.buildModeBuildings = this.state.buildModeBuildings.filter(b => b.id !== buildingId);
            this.updateVisibleBuildingsList();
            this.recalculateAllClaimedTerritory();
            this.savePlanToLocalStorage();
            this.renderBuildMenu(); // UX FIX: Re-render the build menu to update button states (e.g., for limited buildings).
        },

        renderZoomPresets() {
            if (!this.dom.zoomPresetsList) return;
            this.dom.zoomPresetsList.innerHTML = '';
            ['Fit', '5%', '10%', '20%', '40%', '60%', '80%', '100%'].forEach(p => {
                const btn = document.createElement('button'); btn.textContent = p;
                btn.onclick = () => {
                    if (p === 'Fit') { this.zoomToFit(); } 
                    else {
                        const zoomVal = parseInt(p, 10);
                        const targetScale = (zoomVal / 100) * this.config.baseScale;
                        this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 200);
                    }
                    if (this.state.openPanel) {
                        const panelMap = { 'zoomPresets': { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel }};
                        const current = panelMap[this.state.openPanel];
                        if(current) {
                            current.panel.classList.remove('open');
                            current.btn.classList.remove('active');
                            this.state.openPanel = null;
                        }
                    }
                };
                this.dom.zoomPresetsList.appendChild(btn);
            });
        },

        loadPinnedBookmarks() { 
            if (localStorage.getItem('pinnedBookmarks')) { 
                try { 
                    this.state.pinnedBookmarks = JSON.parse(localStorage.getItem('pinnedBookmarks')) || []; 
                } 
                catch(e) { 
                    this.state.pinnedBookmarks = []; 
                } 
            } 
        },

        savePinnedBookmarks() {
            localStorage.setItem('pinnedBookmarks', JSON.stringify(this.state.pinnedBookmarks));
        },

        pinBookmark(bookmark) {
            if (!this.state.pinnedBookmarks.some(p => p.x === bookmark.x && p.y === bookmark.y)) {
            this.state.pinnedBookmarks.push({ 
                x: bookmark.x, 
                y: bookmark.y, 
                displayName: bookmark.displayName 
            });
            this.savePinnedBookmarks(); 
            this.renderAllBookmarkUI();
            }
        },

        unpinBookmark(x, y) {
            this.state.pinnedBookmarks = this.state.pinnedBookmarks.filter(p => !(p.x === x && p.y === y));
            this.savePinnedBookmarks(); 
            this.renderAllBookmarkUI();
        },

        renderAllBookmarkUI() {
            this.renderPinnedBookmarks(); 
            this.renderAddBookmarksList();
        },

        createBookmarkItem(b, isPinned) {
            const item = document.createElement('div');
            item.className = 'bookmark-item';
            const nameSpan = document.createElement('span');
            nameSpan.textContent = b.displayName;
            
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'controls';
            const goBtn = document.createElement('button');
            goBtn.textContent = 'Go';
            goBtn.onclick = () => this.goToBookmark(b.x, b.y);
            if (isPinned) {
                const unpinBtn = document.createElement('button');
                unpinBtn.textContent = 'Unpin';
                unpinBtn.className = 'unpin-btn';
                unpinBtn.onclick = () => this.unpinBookmark(b.x, b.y);
                controlsDiv.append(goBtn, unpinBtn);
            } else {
                const pinBtn = document.createElement('button');
                pinBtn.textContent = 'Pin';
                pinBtn.onclick = () => this.pinBookmark(b);
                controlsDiv.append(goBtn, pinBtn);
            }
            item.append(nameSpan, controlsDiv);
            return item;
        },

        renderPinnedBookmarks() {
            if (!this.dom.pinnedBookmarksList) return;
            this.dom.pinnedBookmarksList.innerHTML = '';
            this.state.pinnedBookmarks.forEach(p => this.dom.pinnedBookmarksList.appendChild(this.createBookmarkItem(p, true)));
        },

        renderAddBookmarksList() {
            if (!this.dom.addBookmarksList || !this.state.baseMap.defaultBuildings) return;
            this.dom.addBookmarksList.innerHTML = '';
            const landmarkKeywords = ["King's Castle", "Fortress", "Sanctuary", "Outpost", "Altar", "Tower", "Grove", "Armory", "Arsenal", "Camp", "Lodge"];
            const allLandmarks = this.state.baseMap.defaultBuildings.filter(b => b.displayName && landmarkKeywords.some(kw => b.displayName.includes(kw)));
            const unpinned = allLandmarks.filter(landmark => !this.state.pinnedBookmarks.some(p => p.x === landmark.x && p.y === landmark.y));
            
            const getSortOrder = (name) => {
            if (name.includes("King's Castle")) return 0;
            if (name.includes("Fortress")) return 1;
            if (name.includes("Sanctuary")) return 2;
            if (name.includes("Lv.")) return 3 + parseInt(name.split('Lv.')[1], 10); // Sort by level
            return 10;
            };
            unpinned.sort((a, b) => {
            const orderA = getSortOrder(a.displayName);
            const orderB = getSortOrder(b.displayName);
            if (orderA !== orderB) return orderA - orderB;
            return a.displayName.localeCompare(b.displayName, undefined, { numeric: true });
            });
            unpinned.forEach(b => this.dom.addBookmarksList.appendChild(this.createBookmarkItem(b, false)));
        },

        goToBookmark(x, y) {
            // Check if a panel is open and if it's NOT a persistent one
            const persistentPanels = ['allianceMgt', 'buildMenu', 'devMode', 'nav'];
            if (this.state.openPanel && !persistentPanels.includes(this.state.openPanel)) {
                // This is a temporary, non-persistent panel, so we should close it.
                // To do this, we need a way to reference the panel and its button.
                const panelMap = {
                    'pinnedBookmarks': { btn: this.dom.pinnedBookmarksToggleBtn, panel: this.dom.pinnedBookmarksPanel },
                    'overwatch': { btn: this.dom.overwatchToggleBtn, panel: this.dom.overwatchPanel },
                    'zoomPresets': { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel },
                    'settings': { btn: this.dom.settingsToggleBtn, panel: this.dom.settingsPanel }
                };

                const current = panelMap[this.state.openPanel];
                if(current) {
                    current.panel.classList.remove('open');
                    current.btn.classList.remove('active');
                    this.state.openPanel = null;
                }
            }
            if (x >= 0 && y >= 0) {
                this.state.selection = this.getBuildingAtCoords(x, y) || { x, y };
                if (this.state.selection) this.state.selection.pingStart = performance.now();
                const targetScale = this.config.baseScale;
                const [screenX, screenY] = this.worldToScreen(x, y);
                this.animatePanZoom(targetScale, this.dom.canvas.width / 2 - screenX * targetScale, this.dom.canvas.height / 2 - screenY * targetScale);
            }
        },

        showPatchNotes() {
            if (!this.dom.modalOverlay || !this.dom.patchNotesModal) return;

            if (typeof marked !== 'undefined') { marked.setOptions({ gfm: true, breaks: true, sanitize: false }); } 
            let text = this.state.patchNotes || '';
            const idx = text.indexOf('## ['); 
            if (idx !== -1) { text = text.substring(idx); } 
            this.dom.patchNotesBody.innerHTML = marked.parse(text || 'No changelog available.');
            
            const headers = this.dom.patchNotesBody.querySelectorAll('h2');
            headers.forEach((header, index) => {
                const details = document.createElement('details');
                if (index === 0) {
                    details.open = true;
                }

                const summary = document.createElement('summary');
                summary.innerHTML = header.innerHTML;
                details.appendChild(summary);

                let sibling = header.nextElementSibling;
                while(sibling && sibling.tagName !== 'H2') {
                    const nextSibling = sibling.nextElementSibling;
                    details.appendChild(sibling); 
                    sibling = nextSibling;
                }
                
                header.parentNode.replaceChild(details, header);
            });

            this.dom.modalOverlay.style.display = 'block'; 
            this.dom.patchNotesModal.style.display = 'block'; 
        },

        hidePatchNotes() { 
            if (this.dom.modalOverlay && this.dom.patchNotesModal) { 
                if (this.dom.hidePatchNotesCheckbox && this.dom.hidePatchNotesCheckbox.checked) { 
                    localStorage.setItem('lastSeenVersion', this.config.CURRENT_VERSION); 
                } 
                this.dom.modalOverlay.style.display = 'none'; 
                this.dom.patchNotesModal.style.display = 'none'; 
            } 
        },

        showControlsModal() { 
            if (this.dom.modalOverlay && this.dom.controlsModal) { 
                this.dom.modalOverlay.style.display = 'block'; 
                this.dom.controlsModal.style.display = 'block'; 
            } 
        },

        hideControlsModal() { 
            if (this.dom.modalOverlay && this.dom.controlsModal) { 
                this.dom.modalOverlay.style.display = 'none'; 
                this.dom.controlsModal.style.display = 'none'; 
            } 
        },

        preProcessBuildings() {
            let buildings = [...(this.state.baseMap.defaultBuildings || [])];
            if (this.state.baseMap.allianceRssBuildings) {
            const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
                const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
                return { x: rss.x, y: rss.y, w: 2, h: 2, displayName: style.displayName, fillColor: style.fillColor, borderColor: style.borderColor, displayCoordinates: false, isRss: true, type: rss.type };
            });
            buildings = buildings.concat(formattedRssBuildings);
            }
            this.state.allBuildings = buildings;
            this.state.buildingMap.clear();
            for (const b of this.state.allBuildings) {
            if (typeof b.w === 'number' && typeof b.h === 'number') {
                for (let dx = 0; dx < b.w; dx++) {
                for (let dy = 0; dy < b.h; dy++) { this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b); }
                }
            }
            }
            // NEW: Update the combined building list after processing base map buildings
            this.updateVisibleBuildingsList();
        },

        // Add this new function to the KingshotPlanner object
        preProcessSpecialAreas() {
            this.state.specialTileMap.clear();
            if (!this.state.baseMap.defaultBuildings) return;

            for (const b of this.state.baseMap.defaultBuildings) {
                let areaSize = 0;
                let areaType = '';

                if (b.ruins) {
                    areaSize = b.ruins;
                    areaType = 'ruins';
                } else if (b.forbiddenArea) {
                    areaSize = b.forbiddenArea;
                    areaType = 'forbidden';
                }

                if (areaSize > 0) {
                    const radius = Math.floor(areaSize / 2);
                    // Calculate the center of the building's footprint
                    const centerX = b.x + Math.floor(b.w / 2);
                    const centerY = b.y + Math.floor(b.h / 2);
                    // Calculate the top-left corner of the special area
                    const startX = centerX - radius;
                    const startY = centerY - radius;

                    for (let dx = 0; dx < areaSize; dx++) {
                        for (let dy = 0; dy < areaSize; dy++) {
                            const tileX = startX + dx;
                            const tileY = startY + dy;
                            this.state.specialTileMap.set(`${tileX},${tileY}`, areaType);
                        }
                    }
                }
            }
            console.log(`Processed ${this.state.specialTileMap.size} special area tiles.`);
        },

        preProcessUnoccupiable() {
            this.state.unoccupiableTileSet.clear();
            if (this.state.baseMap.unoccupiableTiles) {
                for (const tile of this.state.baseMap.unoccupiableTiles) {
                    this.state.unoccupiableTileSet.add(`${tile[0]},${tile[1]}`);
                }
            }
        },

        preCalculateChunks() {
            const numLevels = 4; this.state.chunkLevels = [];
            for (let level = 0; level < numLevels; level++) {
            const chunkSize = Math.pow(2, level + 1); const levelMap = new Map();
            for (let x = 0; x < this.config.N; x += chunkSize) {
                for (let y = 0; y < this.config.N; y += chunkSize) {
                // *** FIX IS HERE: The 'true' flag tells it to ignore special biomes ***
                const biome = this.getBiomeForTile(x, y, true); 
                levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
                }
            }
            this.state.chunkLevels.push(levelMap);
            }
        },

        worldToScreen(x, y) { 
            return [(x - y) * (this.config.tileW / 2), -(x + y) * (this.config.tileH / 2)]; 
        },

        screenToWorld(sx, sy) {
            const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
            const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
            if (tileW_half === 0 || tileH_half === 0) { return [0, 0]; }
            const lx = (sx - this.state.cam.x) / scale; const ly = (sy - this.state.cam.y) / scale;
            const u = lx / tileW_half; const v = -ly / tileH_half;
            return [Math.round((u + v) / 2), Math.round((v - u) / 2)];
        },

        getBuildingAt(x, y) { 
            return this.state.buildingMap.get(`${x},${y}`) || null; 
        },

        getBiomeForTile(x, y, ignoreSpecialAreas = false) {
            const coordStr = `${x},${y}`;
            // When rendering individual tiles, check for special types in order of priority.
            // This is skipped for zoomed-out chunks to maintain performance and show the base biome.
            if (!ignoreSpecialAreas) {
                // 1. Unoccupiable tiles have the highest priority.
                if (this.state.unoccupiableTileSet.has(coordStr)) {
                    return 'unoccupiable';
                }
                // 2. Then check for Ruins or Forbidden areas.
                const specialType = this.state.specialTileMap.get(coordStr);
                if (specialType) {
                    return specialType; // Returns 'ruins' or 'forbidden'
                }
            }

            // 3. If no special type, calculate the base biome.
            const { fertile, plains } = this.config.biomeRegions;
            if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
            if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
            return 'badlands';
        },

        getChunkLevelForZoom(pct) {
            // This is the raw percentage, which might be a float
            if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100;
            
            // *** FIX: Round the percentage before comparing it to the integer threshold ***
            const roundedPct = Math.round(pct);
            const detailThreshold = this.state.currentTileDetailThreshold;

            if (roundedPct > detailThreshold) return -1; 
            if (roundedPct > detailThreshold / 2) return 0;
            if (roundedPct > detailThreshold / 5) return 1; 
            if (roundedPct > detailThreshold / 10) return 2;
            return 3;
        },

        clampCamera() {
            const s = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
            const canvasW = this.dom.canvas.width; const canvasH = this.dom.canvas.height;
            const N = this.config.N; const tileW = this.config.tileW; const tileH = this.config.tileH;
            const mapScreenW = (N - 1) * tileW * s;
            if (mapScreenW > canvasW) {
                const minCamX = canvasW - mapScreenW / 2; const maxCamX = mapScreenW / 2;
                this.state.cam.x = Math.max(minCamX, Math.min(maxCamX, this.state.cam.x));
            } else { this.state.cam.x = canvasW / 2; }
            const mapScreenH = (N - 1) * tileH * s;
            if (mapScreenH > canvasH) {
                const topOfMapY = mapScreenH; const bottomOfMapY = canvasH;
                this.state.cam.y = Math.max(bottomOfMapY, Math.min(topOfMapY, this.state.cam.y));
            } else {
                this.state.cam.y = canvasH / 2 + mapScreenH / 2;
            }
            if (isNaN(this.state.cam.x)) this.state.cam.x = canvasW / 2;
            if (isNaN(this.state.cam.y)) this.state.cam.y = canvasH / 2;

            this.requestSaveCameraState();
        },

        changeZoomBy(delta) {
            let currentPct = Math.round((this.state.cam.scale / this.config.baseScale) * 100);
            if (isNaN(currentPct)) { currentPct = Math.round((this.state.minFitScale / this.config.baseScale) * 100); }
            const targetPct = currentPct + delta;
            let targetScale = (targetPct / 100) * this.config.baseScale;
            const minScale = this.state.minFitScale;
            const maxScale = (this.config.maxPct / 100) * this.config.baseScale;
            targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
            if (!isNaN(targetScale)) { this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 150); }
        },

        animateZoom(targetScale, anchorX, anchorY, duration = 150) {
            if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
            const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
            const startX = this.state.cam.x; const startY = this.state.cam.y;
            const start = performance.now();
            if (startScale === 0) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
            const wx = (anchorX - startX) / startScale; const wy = (anchorY - startY) / startScale;
            if (isNaN(wx) || isNaN(wy)) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
            const step = (now) => {
            const t = duration === 0 ? 1 : Math.min(1, (now - start) / duration);
            const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            this.state.cam.scale = startScale + (targetScale - startScale) * k;
            this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
            if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
            this.state.cam.x = anchorX - wx * this.state.cam.scale;
            this.state.cam.y = anchorY - wy * this.state.cam.scale;
            this.clampCamera();
            if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
            else { this.state.animationId = null; }
            };
            this.state.animationId = requestAnimationFrame(step);
        },

        animatePanZoom(targetScale, targetX, targetY, duration = 300) {
            if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
            const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
            const startX = this.state.cam.x; const startY = this.state.cam.y;
            const start = performance.now();
            const step = (now) => {
            const t = Math.min(1, (now - start) / duration);
            const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            this.state.cam.scale = startScale + (targetScale - startScale) * k;
            this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
            if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
            this.state.cam.x = startX + (targetX - startX) * k;
            this.state.cam.y = startY + (targetY - startY) * k;
            this.clampCamera();
            if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
            else { this.state.animationId = null; }
            };
            this.state.animationId = requestAnimationFrame(step);
        },

        zoomToFit() {
            const targetScale = this.state.minFitScale;
            const targetCamX = this.dom.canvas.width / 2;
            const targetCamY = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * targetScale;
            this.animatePanZoom(targetScale, targetCamX, targetCamY, 200);
        },

        handleMinimapMouseDown(e) { 
            this.state.isMinimapDragging = true; 
            this.state.minimapClickStartPos = { x: e.clientX, y: e.clientY }; 
            this.state.startCamX = this.state.cam.x; 
            this.state.startCamY = this.state.cam.y; 
        },

        handleMinimapMouseMove(e) {
            if (!this.state.isMinimapDragging) return; if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
            const rect = this.dom.minimapCanvas.getBoundingClientRect(); const minimapCam = this.state.minimapCam;
            const clickScreenX = (e.clientX - rect.left); const clickScreenY = (e.clientY - rect.top);
            const lx = (clickScreenX - minimapCam.x) / minimapCam.scale; const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
            const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
            const u = lx / tileW_half; const v = -ly / tileH_half; const world_x = (u + v) / 2; const world_y = (v - u) / 2;
            const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
            this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale; this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
            this.clampCamera();
        },

        handleMinimapMouseUp(e) {
            if (!this.state.isMinimapDragging) return;
            this.state.isMinimapDragging = false;
            
            const dist = Math.hypot(e.clientX - this.state.minimapClickStartPos.x, e.clientY - this.state.minimapClickStartPos.y);
            if (dist < 5) {
                const rect = this.dom.minimapCanvas.getBoundingClientRect(); 
                const minimapCam = this.state.minimapCam;
                const clickScreenX = (e.clientX - rect.left); 
                const clickScreenY = (e.clientY - rect.top);
                
                const lx = (clickScreenX - minimapCam.x) / minimapCam.scale; 
                const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
                
                const tileW_half = this.config.tileW / 2; 
                const tileH_half = this.config.tileH / 2;
                const u = lx / tileW_half; 
                const v = -ly / tileH_half; 
                const world_x = (u + v) / 2; 
                const world_y = (v - u) / 2;
                
                const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
                
                this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale; 
                this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
                this.clampCamera();
            }
        },

        handleMouseDown(e) {
            if (e.button === 0) {
                this.state.clickStartX = e.clientX;
                this.state.clickStartY = e.clientY;
                this.state.lastX = e.clientX;
                this.state.lastY = e.clientY;

                if (!(this.state.isBuildMode && this.state.selectedBuildingType)) {
                    this.state.dragging = true;
                }
            }
        },

        handleMouseMove(e) { 
            const [wx, wy] = this.screenToWorld(e.offsetX, e.offsetY);
            this.state.mouseWorldPos = {x: wx, y: wy};

            if (!this.state.dragging) return; 
            this.state.cam.x += e.clientX - this.state.lastX; 
            this.state.cam.y += e.clientY - this.state.lastY; 
            this.state.lastX = e.clientX; 
            this.state.lastY = e.clientY; 
            this.clampCamera(); 
        },

        handleCanvasClick(e) {
            const dist = Math.hypot(e.clientX - this.state.clickStartX, e.clientY - this.state.clickStartY);
            if (dist > 5) return; // This was a drag, not a click

            const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);

            if (this.state.isPlacingPlayer) {
                this.placePlayer(worldX, worldY);
                // Exit placement mode
                this.state.isPlacingPlayer = false;
                this.state.playerToPlace = null;
                this.dom.canvas.classList.remove('build-cursor');
                
                // BUG FIX: Re-open the player panel after placement is complete
                this.togglePanel('playerMgt');
                
                return; // Important to stop further click processing
            }

            // --- DEV MODE CLICK LOGIC ---
            if (this.state.isDevMode && this.state.activeDevTool) {
                if (this.getBuildingAtCoords(worldX, worldY)) {
                    alert("Cannot place: A building already exists at this location.");
                    return;
                }

                const { tool, type } = this.state.activeDevTool;
                switch (tool) {
                    case 'unoccupiable':
                        this.state.baseMap.unoccupiableTiles.push([worldX, worldY]);
                        this.preProcessUnoccupiable(); 
                        break;
                    case 'rss':
                        this.state.baseMap.allianceRssBuildings.push({ type: type, x: worldX, y: worldY });
                        break;
                    case 'outpost':
                        const def = this.BUILDING_CATALOG[type];
                        if (def) {
                            this.state.baseMap.defaultBuildings.push({
                                x: worldX, y: worldY,
                                w: def.w, h: def.h,
                                displayName: def.name,
                                displayCoordinates: true,
                                hideCoordinates: true,
                                fillColor: "rgba(128, 128, 128, 1)", // Default color for new outposts
                                borderColor: "rgba(102, 102, 102, 1)",
                                forbiddenArea: 15 // Default forbidden area
                            });
                        }
                        break;
                }
                // Re-process buildings to make the new object active on the map immediately
                this.preProcessBuildings();
                this.preProcessSpecialAreas();
                this.saveDevMapToLocalStorage();
                return; 
            }

            // --- NORMAL CLICK LOGIC ---
            if (this.state.isBuildMode) {
                if (this.state.selectedBuildingType) {
                    this.placeBuilding(this.state.selectedBuildingType, worldX, worldY);
                }
                return;
            }

            if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
                const building = this.getBuildingAtCoords(worldX, worldY);
                const player = this.getPlayerAtCoords(worldX, worldY);
                this.state.selection = player || building || { x: worldX, y: worldY };
                if (this.state.selection) this.state.selection.pingStart = performance.now();
                if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
                if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
            }
        },

        handleRightClick(e) {
            e.preventDefault();

            // Dev Mode Right-Click for Deletion
            if (this.state.isDevMode && !this.state.activeDevTool) {
                const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
                let found = false;

                // Check for unoccupiable tiles
                const unoccupiableIndex = this.state.baseMap.unoccupiableTiles.findIndex(t => t[0] === worldX && t[1] === worldY);
                if (unoccupiableIndex > -1) {
                    if (confirm(`Delete Unoccupiable tile at (${worldX}, ${worldY})?`)) {
                        this.state.baseMap.unoccupiableTiles.splice(unoccupiableIndex, 1);
                        this.preProcessUnoccupiable(); 
                        found = true;
                    }
                }
                
                // Check for RSS buildings
                if (!found) {
                    const rssIndex = this.state.baseMap.allianceRssBuildings.findIndex(b => b.x === worldX && b.y === worldY);
                    if (rssIndex > -1) {
                        const rss = this.state.baseMap.allianceRssBuildings[rssIndex];
                        if (confirm(`Delete ${rss.type} RSS at (${worldX}, ${worldY})?`)) {
                            this.state.baseMap.allianceRssBuildings.splice(rssIndex, 1);
                            found = true;
                        }
                    }
                }

                // Check for default buildings
                if (!found) {
                    const building = this.getBuildingAt(worldX, worldY);
                    if (building && !building.allianceId) { // Ensure it's a default building
                        if (confirm(`Delete ${building.displayName} at (${building.x}, ${building.y})?`)) {
                            this.state.baseMap.defaultBuildings = this.state.baseMap.defaultBuildings.filter(b => !(b.x === building.x && b.y === building.y));
                            found = true;
                        }
                    }
                }

                if (found) {
                    this.preProcessBuildings();
                    this.preProcessSpecialAreas();
                    this.saveDevMapToLocalStorage();
                    return; // BUG FIX: The return is now INSIDE this block.
                }
                // BUG FIX: MOVED a return from here to the block above.
            }
            
            // Normal Build Mode Right-Click
            if (this.state.isBuildMode) {
                if (this.state.selectedBuildingType) {
                    this.selectBuildingToPlace(this.state.selectedBuildingType); // Deselects the tool
                } else {
                    const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
                    const building = this.getBuildingAtCoords(worldX, worldY);
                    if (building && building.allianceId) {
                        if(confirm(`Delete ${building.displayText}?`)) {
                            this.deleteBuildModeBuilding(building.id);
                        }
                    }
                }
            }

            // Add logic for deleting players in normal mode
            if (!this.state.isBuildMode && !this.state.isDevMode) {
                const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
                const playerToDelete = this.getPlayerAtCoords(worldX, worldY);
                if (playerToDelete) {
                    if (confirm(`Delete player ${playerToDelete.name}?`)) {
                        this.state.placedPlayers = this.state.placedPlayers.filter(p => p.id !== playerToDelete.id);
                        this.savePlanToLocalStorage();
                        this.renderPlayerPanel();
                    }
                    return; // Exit after handling
                }
            }
        },
        handleWheel(e) { 
            e.preventDefault(); 
            const factor = e.deltaY < 0 ? 1.2 : 0.8; 
            let targetScale = this.state.cam.scale * factor; 
            targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale)); 
            this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
        },

        handleDblClick(e) { 
            e.preventDefault(); 
            const factor = e.button === 2 ? 0.5 : 2.0; 
            let targetScale = this.state.cam.scale * factor; 
            targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale)); 
            this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
        },

        handleZoomSlider() {
            if (!this.dom.zoomSlider) return; const pct = Number(this.dom.zoomSlider.value);
            let targetScale = (pct / 100) * this.config.baseScale;
            targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
            this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 0);
        },

        handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                this.state.touchMode = 'pan'; const t = e.touches[0]; this.state.lastX = t.clientX; this.state.lastY = t.clientY;
                this.state.clickStartX = t.clientX; this.state.clickStartY = t.clientY; this.state.touchStartTime = performance.now();
            } else if (e.touches.length === 2) {
                this.state.touchMode = 'pinch'; const [a, b] = e.touches;
                this.state.startDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
                this.state.startScale = this.state.cam.scale; this.state.pinchCenter = { x: (a.clientX + b.clientX) / 2, y: (a.clientY + b.clientY) / 2 };
                this.state.startCamX = this.state.cam.x; this.state.startCamY = this.state.cam.y;
            }
        },

        handleTouchMove(e) {
            e.preventDefault(); if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
            if (this.state.touchMode === 'pan' && e.touches.length === 1) {
                const t = e.touches[0]; 
                this.state.cam.x += t.clientX - this.state.lastX; 
                this.state.cam.y += t.clientY - this.state.lastY;
                this.state.lastX = t.clientX; this.state.lastY = t.clientY; this.clampCamera();
            } else if (this.state.touchMode === 'pinch' && e.touches.length === 2) {
                const [a, b] = e.touches; const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
                if (this.state.startDist === 0) return; let newScale = this.state.startScale * (dist / this.state.startDist);
                this.state.cam.scale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, newScale));
                if (isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.startScale;
                const safeStartScale = (this.state.startScale === 0 || isNaN(this.state.startScale)) ? this.state.minFitScale : this.state.startScale;
                const wx = (this.state.pinchCenter.x - this.state.startCamX) / safeStartScale; const wy = (this.state.pinchCenter.y - this.state.startCamY) / safeStartScale;
                if (isNaN(wx) || isNaN(wy)) { this.state.cam.x = this.state.startCamX; this.state.cam.y = this.state.startCamY; } 
                else { this.state.cam.x = this.state.pinchCenter.x - wx * this.state.cam.scale; this.state.cam.y = this.state.pinchCenter.y - wy * this.state.cam.scale; }
                this.clampCamera();
            }
        },

        handleTouchEnd(e) {
            if (this.state.touchMode === 'pan' && e.changedTouches.length === 1) {
                const t = e.changedTouches[0]; const dist = Math.hypot(t.clientX - this.state.clickStartX, t.clientY - this.state.clickStartY);
                const duration = performance.now() - this.state.touchStartTime;
                if (duration < 200 && dist < 10) {
                    const [worldX, worldY] = this.screenToWorld(t.clientX, t.clientY);
                
                    if (this.state.isBuildMode && this.state.selectedBuildingType) {
                        this.placeBuilding(this.state.selectedBuildingType, worldX, worldY);
                        return;
                    }

                    if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
                        const building = this.getBuildingAtCoords(worldX, worldY); 
                        this.state.selection = building || { x: worldX, y: worldY };
                        if (this.state.selection) this.state.selection.pingStart = performance.now();
                        if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
                        if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
                    }
                }
            }
            if (e.touches.length < 2) this.state.touchMode = null;
        },

        resize() {
            this.dom.canvas.width = window.innerWidth; this.dom.canvas.height = window.innerHeight;
            if (this.dom.minimapCanvas && this.config.minimap) {
            const dpr = window.devicePixelRatio || 1;
            this.dom.minimapCanvas.width = this.config.minimap.width * dpr; this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
            }
            const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
            const mapTotalHeight = (this.config.N - 1) * this.config.tileH;
            const scaleX = this.dom.canvas.width / mapTotalWidth;
            const scaleY = this.dom.canvas.height / mapTotalHeight;
            this.state.minFitScale = Math.max(0.1, Math.min(scaleX, scaleY) * 0.95);
            if (isNaN(this.state.minFitScale)) { this.state.minFitScale = 0.1; }
            
            if (this.state.isInitialLoad) {
                this.state.isInitialLoad = false;
                // Try to load the saved state. If it fails, zoom to fit.
                const loaded = this.loadCameraState();
                if (!loaded) {
                this.zoomToFit();
                } else {
                this.clampCamera(); // Ensure loaded values are valid
                }
            } else {
                this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
                if (isNaN(this.state.cam.scale)) { this.state.cam.scale = this.state.minFitScale; }
                this.clampCamera();
            }
        },

        doSearch() {
            if (!this.dom.inpX || !this.dom.inpY) return;
            this.goToBookmark(+this.dom.inpX.value, +this.dom.inpY.value);
        },

        drawIsometricMinimap(viewportCorners) {
            if (!this.dom.minimapCtx || !this.dom.minimapContainer.classList.contains('visible') || !this.config.minimap) return;
            const mmCtx = this.dom.minimapCtx; const { minimap, N, tileW, tileH, baseScale, maxPct } = this.config;
            const canvasWidth = this.dom.minimapCanvas.width; const canvasHeight = this.dom.minimapCanvas.height;
            mmCtx.save(); mmCtx.setTransform(1, 0, 0, 1, 0, 0); mmCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            mmCtx.fillStyle = minimap.bgColor; mmCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            const worldIsoWidth = N * tileW; const worldIsoHeight = N * tileH;
            const drawableWidth = canvasWidth - (minimap.padding * 2); const drawableHeight = canvasHeight - (minimap.padding * 2);
            const baseMinimapScale = Math.min(drawableWidth / worldIsoWidth, drawableHeight / worldIsoHeight);
            
            const mainMapCurrentScale = this.state.cam.scale; 
            const mainMapMaxScale = (maxPct / 100) * baseScale;
            const mainMapMinScale = this.state.minFitScale;
            let zoomFactor, focalPointX, focalPointY;
            const mapVisualCenterX_iso = 0; 
            const mapVisualCenterY_iso = -((N - 1) * tileH / 2);
            const mainMapZoomPct = mainMapCurrentScale / baseScale;

            if (mainMapZoomPct < minimap.mainMapZoomThresholdForMinimapZoom) {
                // STATIC OVERVIEW MODE: Stays zoomed out and centered.
                zoomFactor = minimap.zoomFactorMin;
                focalPointX = mapVisualCenterX_iso;
                focalPointY = mapVisualCenterY_iso;
            } else {
                // DYNAMIC CONTEXT MODE
                let normalizedZoom = 0;
                if (mainMapMaxScale > mainMapMinScale) {
                    normalizedZoom = Math.max(0, Math.min(1, (mainMapCurrentScale - mainMapMinScale) / (mainMapMaxScale - mainMapMinScale)));
                }
                
                // *** FIX PART 1: Use LINEAR progress for a smooth ZOOM factor ***
                zoomFactor = minimap.zoomFactorMin + (minimap.zoomFactorMax - minimap.zoomFactorMin) * normalizedZoom;

                // *** FIX PART 2: Use EASED (non-linear) progress for an aggressive PAN ***
                const easedPanProgress = Math.pow(normalizedZoom, 0.1); 

                const [mainViewCenterX, mainViewCenterY] = this.screenToWorld(this.dom.canvas.width / 2, this.dom.canvas.height / 2);
                const [viewportCenterX_iso, viewportCenterY_iso] = this.worldToScreen(mainViewCenterX, mainViewCenterY);
                
                // Apply the separate eased progress ONLY to the panning calculation
                focalPointX = mapVisualCenterX_iso + (viewportCenterX_iso - mapVisualCenterX_iso) * easedPanProgress; 
                focalPointY = mapVisualCenterY_iso + (viewportCenterY_iso - mapVisualCenterY_iso) * easedPanProgress;
            }

            const finalMinimapScale = baseMinimapScale * zoomFactor;
            const translateX = (canvasWidth / 2) - (focalPointX * finalMinimapScale); 
            const translateY = (canvasHeight / 2) - (focalPointY * finalMinimapScale);
            this.state.minimapCam = { x: translateX, y: translateY, scale: finalMinimapScale };

            mmCtx.setTransform(finalMinimapScale, 0, 0, finalMinimapScale, translateX, translateY);
            const chunksToDraw = this.state.chunkLevels[3];
            chunksToDraw.forEach(chunk => { this.drawChunk(chunk, false, mmCtx); });

            (this.state.baseMap.defaultBuildings || []).forEach(b => {
                let buildingFillStyle = null;
                if (b.displayName === "King's Castle") buildingFillStyle = minimap.kingCastleColor;
                else if (b.displayName.startsWith("Fortress")) buildingFillStyle = minimap.fortressColor;
                else if (b.displayName.startsWith("Sanctuary")) buildingFillStyle = minimap.sanctuaryColor;
                else if (b.displayName.includes("Builder's Guild")) buildingFillStyle = minimap.buildersGuildOutpostColor;
                else if (b.displayName.includes("Forager Grove")) buildingFillStyle = minimap.foragerGroveOutpostColor;
                else if (b.displayName.includes("Harvest Altar")) buildingFillStyle = minimap.harvestAltarOutpostColor;
                else if (b.displayName.includes("Scholar's Tower")) buildingFillStyle = minimap.scholarsTowerOutpostColor;
                else if (b.displayName.includes("Arsenal")) buildingFillStyle = minimap.arsenalOutpostColor;
                else if (b.displayName.includes("Armory")) buildingFillStyle = minimap.armoryOutpostColor;
                else if (b.displayName.includes("Drill Camp")) buildingFillStyle = minimap.drillCampOutpostColor;
                else if (b.displayName.includes("Frontier Lodge")) buildingFillStyle = minimap.frontierLodgeOutpostColor;
                if (buildingFillStyle) { const originalFill = b.fillColor; b.fillColor = buildingFillStyle; this.drawBuildingFootprint(b, null, false, mmCtx); b.fillColor = originalFill; }
            });
            if (viewportCorners) {
                const p1 = this.worldToScreen(viewportCorners.tl.x, viewportCorners.tl.y); const p2 = this.worldToScreen(viewportCorners.tr.x, viewportCorners.tr.y);
                const p3 = this.worldToScreen(viewportCorners.br.x, viewportCorners.br.y); const p4 = this.worldToScreen(viewportCorners.bl.x, viewportCorners.bl.y);
                mmCtx.fillStyle = minimap.viewportFillColor; mmCtx.strokeStyle = minimap.viewportBorderColor;
                mmCtx.lineWidth = 2 / finalMinimapScale; mmCtx.beginPath();
                mmCtx.moveTo(p1[0], p1[1]); mmCtx.lineTo(p2[0], p2[1]); mmCtx.lineTo(p3[0], p3[1]); mmCtx.lineTo(p4[0], p4[1]);
                mmCtx.closePath(); mmCtx.fill(); mmCtx.stroke();
            }
            mmCtx.restore();
        },

        drawTile(x, y, drawBorder = true) {
            this.state.tileCount++; 
            const [sx, sy] = this.worldToScreen(x, y); 
            const { config, dom, state } = this; 
            const ctx = dom.ctx;
            
            ctx.beginPath(); 
            ctx.moveTo(sx, sy - config.tileH / 2); 
            ctx.lineTo(sx + config.tileW / 2, sy); 
            ctx.lineTo(sx, sy + config.tileH / 2); 
            ctx.lineTo(sx - config.tileW / 2, sy);
            ctx.closePath(); 
            ctx.fillStyle = config.biomeColors[this.getBiomeForTile(x, y)]; 
            ctx.fill();
            
            if (drawBorder) {
                ctx.stroke();
            }

            const building = this.getBuildingAt(x, y);
            if (building && building.hideCoordinates) return;

            const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
            const pct = Math.round((currentCamScale / config.baseScale) * 100);
            const showCoords = dom.coordsToggle ? dom.coordsToggle.checked : false;
            const showThreshold = showCoords ? 80 : 200;

            if (pct < showThreshold) return;

            const text = `${x}, ${y}`; 
            
            // Dynamically fit text based on tile width, with a max size based on tile height.
            let optimalFontSize = Math.min(config.tileH * 0.4, (config.tileW * 0.9 / text.length) * 1.5);
            
            // Don't render if the text would be unreadably small on screen
            if ((optimalFontSize * currentCamScale) < 6) return;
            
            // --- NEW COLOR LOGIC BASED ON X-COORDINATE ---
            const isHighlightedColumn = x % 2 === 0;
            ctx.fillStyle = isHighlightedColumn ? config.textColor : config.textColorAlt;

            ctx.font = `${optimalFontSize}px sans-serif`;
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle'; 
            ctx.fillText(text, sx, sy);
        },

        drawChunk(chunk, drawBorder = true, overrideCtx = null) {
            this.state.tileCount++; const ctx = overrideCtx || this.dom.ctx;
            const { x, y, size, biome } = chunk; const { config } = this;
            const currentCamScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
            const inflation = drawBorder || currentCamScale === 0 ? 0 : (1 / currentCamScale);
            const x0 = x; const y0 = y; const w = size; const h = size;
            const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
            const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
            const p_bottom = { x: sbx, y: sby + config.tileH / 2 + inflation }; const p_right = { x: srx + config.tileW / 2 + inflation, y: sry };
            const p_top = { x: stx, y: sty - config.tileH / 2 - inflation }; const p_left = { x: slx - config.tileW / 2 - inflation, y: sly };
            ctx.beginPath(); ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
            ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath();
            
            // *** FIX IS HERE: Directly use the chunk's pre-calculated base biome ***
            ctx.fillStyle = config.biomeColors[biome]; 
            ctx.fill(); 
            if (drawBorder) ctx.stroke();
        },

        drawBuildingFootprint(b, highlightStyle = null, drawBorder = true, overrideCtx = null) {
            const { config, state } = this; const ctx = overrideCtx || this.dom.ctx;
            
            const isPlayerCastle = b.type === 'player_castle';
            let buildingDisplayName = b.displayName;
            let isBuildModeBuilding = !!b.allianceId;
            
            // Set colors for build mode buildings first
            if (isBuildModeBuilding) {
                const alliance = state.alliances.find(a => a.id === b.allianceId);
                if (!alliance) return;
                b.fillColor = alliance.color;
                b.borderColor = this.darkenColor(alliance.color, 40);
                buildingDisplayName = b.displayText; 
            }

            // Then, set colors for player castles, using their custom color
            if (isPlayerCastle) {
                b.fillColor = b.color || this.PLAYER_CATALOG.player_castle.fillColor;
                b.borderColor = this.darkenColor(b.fillColor, 40);
            }

            const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
            const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
            const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
            const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
            const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
            const p_bottom = { x: sbx, y: sby + config.tileH / 2 }; const p_right = { x: srx + config.tileW / 2, y: sry };
            const p_top = { x: stx, y: sty - config.tileH / 2 }; const p_left = { x: slx - config.tileW / 2, y: sly };
            
            const currentZoomPct = (state.cam.scale / config.baseScale) * 100;
            
            if (isBuildModeBuilding && (this.state.userBuildingRenderThreshold === -1 || currentZoomPct < this.state.userBuildingRenderThreshold)) {
                return;
            }

            ctx.beginPath(); 
            ctx.moveTo(p_bottom.x, p_bottom.y); 
            ctx.lineTo(p_right.x, p_right.y);
            ctx.lineTo(p_top.x, p_top.y); 
            ctx.lineTo(p_left.x, p_left.y); 
            ctx.closePath();
            
            ctx.fillStyle = isBuildModeBuilding ? this.hexToRgba(fill, 0.4) : fill;
            ctx.fill();

            if(drawBorder) {
                ctx.strokeStyle = border; 
                
                // THE BUG FIX IS HERE:
                // The incorrect division by 'currentScale' has been removed.
                // This sets a proper world-space thickness that scales correctly with zoom.
                ctx.lineWidth = highlightStyle ? config.strokeW * 2 : config.strokeW;
                
                ctx.stroke();
            }

            if (b.imageKey && state.buildingImages.has(b.imageKey) && !overrideCtx && currentZoomPct >= config.imageBreakpoints.imageRenderThreshold) {
                const image = state.buildingImages.get(b.imageKey);
                let dynamicScale = b.imageScale || 1.0;
                if (b.imageScaleBreakpoint_1 && b.imageScaleBreakpoint_2 && config.imageBreakpoints) {
                    const { highZoom, midZoom, lowZoom } = config.imageBreakpoints;
                    if (currentZoomPct >= highZoom) {
                        dynamicScale = b.imageScale;
                    } else if (currentZoomPct >= midZoom) {
                        const progress = (highZoom - currentZoomPct) / (highZoom - midZoom);
                        dynamicScale = b.imageScale + (b.imageScaleBreakpoint_1 - b.imageScale) * progress;
                    } else if (currentZoomPct >= lowZoom) {
                        const progress = (midZoom - currentZoomPct) / (midZoom - lowZoom);
                        dynamicScale = b.imageScaleBreakpoint_1 + (b.imageScaleBreakpoint_2 - b.imageScaleBreakpoint_1) * progress;
                    } else {
                        dynamicScale = b.imageScaleBreakpoint_2;
                    }
                }
                const renderWidth = image.naturalWidth * dynamicScale;
                const renderHeight = image.naturalHeight * dynamicScale;
                let drawX, drawY;
                if (b.anchorTile && typeof b.anchorTile.x === 'number' && typeof b.anchorTile.y === 'number') {
                    const [tileScreenX, tileScreenY] = this.worldToScreen(b.anchorTile.x, b.anchorTile.y);
                    const mapAnchorX = tileScreenX;
                    const mapAnchorY = tileScreenY + (this.config.tileH / 2);
                    const imageAnchorX = renderWidth / 2;
                    const imageAnchorY = renderHeight / 2;
                    drawX = mapAnchorX - imageAnchorX;
                    drawY = mapAnchorY - imageAnchorY;
                } else {
                    const footprintCenterX = (p_left.x + p_right.x) / 2;
                    const footprintCenterY = (p_top.y + p_bottom.y) / 2;
                    drawX = footprintCenterX - (renderWidth / 2);
                    drawY = footprintCenterY - (renderHeight / 2);
                }
                ctx.drawImage(image, drawX, drawY, renderWidth, renderHeight);
                return; 
            }

            if (overrideCtx || highlightStyle) return;
            
            const textZoomThreshold = isPlayerCastle ? 30 : (b.allianceId ? 30 : 40);
            
            if (currentZoomPct > textZoomThreshold && (buildingDisplayName || isPlayerCastle)) {
                const availableWidth = (p_right.x - p_left.x) * 0.8; 
                const availableHeight = p_bottom.y - p_top.y;
                if (availableWidth < 1 || availableHeight < 1) return;

                const centerX = (p_left.x + p_right.x) / 2;
                const centerY = (p_top.y + p_bottom.y) / 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (isPlayerCastle) {
                    ctx.fillStyle = this.getContrastingTextColor(b.fillColor);
                    
                    let nameFontSize = Math.min(config.tileH * 0.7, (availableWidth / (b.name.length || 1)) * 1.5);
                    ctx.font = `bold ${nameFontSize * 0.8}px sans-serif`;
                    ctx.fillText(b.name, centerX, centerY - nameFontSize * 0.45);
                    
                    let powerFontSize = Math.min(config.tileH * 0.6, (availableWidth / (b.power.length || 1)) * 1.5);
                    ctx.font = `${powerFontSize * 0.8}px sans-serif`;
                    ctx.fillText(b.power, centerX, centerY + powerFontSize * 0.55);

                } else if (buildingDisplayName) {
                    const words = buildingDisplayName.split(' ');
                    const isSmallBuilding = b.w <= 1 && b.h <= 1;
                    ctx.font = `bold ${100}px sans-serif`; 
                    const textMetrics = ctx.measureText(buildingDisplayName);
                    const displayNameWidth = textMetrics.width || 1; 
                    const fontSizeBasedOnWidth = (availableWidth / displayNameWidth) * 100;
                    
                    let lineCount = words.length;
                    if(b.displayCoordinates) lineCount += 1;
                    const fontSizeBasedOnHeight = (availableHeight / lineCount) * 0.9;
                    let optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);
                    if(isSmallBuilding && optimalFontSize * currentZoomPct < 10) optimalFontSize = 10 / currentZoomPct;
                    if (optimalFontSize * currentZoomPct < 7 && !isSmallBuilding) return;

                    const unadjustedCenterY = (p_top.y + p_bottom.y) / 2;
                    const lineHeight = optimalFontSize * 1.1;
                    let totalBlockHeight = words.length * lineHeight;
                    if (b.displayCoordinates) {
                        totalBlockHeight += lineHeight * 0.8; 
                    }
                    let currentY = unadjustedCenterY - (totalBlockHeight / 2);
                    
                    ctx.fillStyle = this.getContrastingTextColor(b.fillColor || '#000000');
                    
                    const slightlyAdjustedOptimalFontSize = optimalFontSize * 0.8;
                    ctx.font = `bold ${slightlyAdjustedOptimalFontSize}px sans-serif`;

                    words.forEach(word => {
                        ctx.fillText(word, centerX, currentY + lineHeight / 2);
                        currentY += lineHeight;
                    });
                    if (b.displayCoordinates) {
                        const coordFontSize = optimalFontSize * 0.7;
                        ctx.font = `${coordFontSize}px sans-serif`;
                        ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, currentY + (lineHeight * 0.8) / 2);
                    }
                }
            }
        },
        
        // The entire drawBuildModeOverlays function, rewritten for clarity and performance
        drawBuildModeOverlays(viewBounds) {
            const currentZoomPct = (this.state.cam.scale / this.config.baseScale) * 100;

            if (this.state.userTerritoryRenderThreshold === -1 || currentZoomPct < this.state.userTerritoryRenderThreshold) {
            return;
            }
            
            const ctx = this.dom.ctx;
            
            for (const [allianceId, territorySet] of this.state.claimedTerritory.entries()) {
                const alliance = this.state.alliances.find(a => a.id === allianceId);
                if (!alliance || territorySet.size === 0) continue;

                const territoryInView = [];
                for (const coordStr of territorySet) {
                    const [x, y] = coordStr.split(',').map(Number);
                    if (x >= viewBounds.minX && x <= viewBounds.maxX && y >= viewBounds.minY && y <= viewBounds.maxY) {
                        territoryInView.push({x, y});
                    }
                }
                if (territoryInView.length === 0) continue;

                // Pass 1: Draw the semi-transparent fill for all tiles in view
                // MODIFICATION: Alpha value increased from 0.15 to 0.2 for less transparency
                ctx.fillStyle = this.hexToRgba(alliance.color, 0.2);
                ctx.beginPath();
                for (const tile of territoryInView) {
                    const [sx, sy] = this.worldToScreen(tile.x, tile.y);
                    ctx.moveTo(sx, sy - this.config.tileH / 2); // Use moveTo to start a new sub-path
                    ctx.lineTo(sx + this.config.tileW / 2, sy);
                    ctx.lineTo(sx, sy + this.config.tileH / 2);
                    ctx.lineTo(sx - this.config.tileW / 2, sy);
                    ctx.closePath();
                }
                ctx.fill();

                // Pass 2: Draw the external borders in a single batched call
                ctx.strokeStyle = this.hexToRgba(this.darkenColor(alliance.color, 40), 0.9);
                ctx.lineWidth = this.config.strokeW * 1.5;
                ctx.beginPath();
                for (const tile of territoryInView) {
                    const { x, y } = tile;
                    const [sx, sy] = this.worldToScreen(x, y);
                    const T = { x: sx, y: sy - this.config.tileH / 2 };
                    const R = { x: sx + this.config.tileW / 2, y: sy };
                    const B = { x: sx, y: sy + this.config.tileH / 2 };
                    const L = { x: sx - this.config.tileW / 2, y: sy };
                    
                    // Check neighbors and add the required border segment to the path
                    if (!territorySet.has(`${x},${y+1}`))   { ctx.moveTo(L.x, L.y); ctx.lineTo(T.x, T.y); }
                    if (!territorySet.has(`${x+1},${y}`))   { ctx.moveTo(T.x, T.y); ctx.lineTo(R.x, R.y); }
                    if (!territorySet.has(`${x},${y-1}`))   { ctx.moveTo(R.x, R.y); ctx.lineTo(B.x, B.y); }
                    if (!territorySet.has(`${x-1},${y}`))   { ctx.moveTo(B.x, B.y); ctx.lineTo(L.x, L.y); }
                }
                ctx.stroke(); // A single draw call for all border segments of the alliance
            }
            ctx.lineWidth = this.config.strokeW; // Reset line width
        },
        updateInfoBanner() {
            const { config, state, dom } = this;

            // *** NEW LOGIC to add/remove class based on build mode state ***
            if (state.isBuildMode) {
                dom.infoBanner.classList.add('with-build-banner');
            } else {
                dom.infoBanner.classList.remove('with-build-banner');
            }

            const [centerX, centerY] = this.screenToWorld(dom.canvas.width / 2, dom.canvas.height / 2);
            const currentZoomPct = (state.cam.scale / config.baseScale) * 100;

            if (currentZoomPct < 20) {
                dom.infoBanner.style.display = 'none';
                return;
            }

            const trackedBuildings = state.allBuildings.filter(b => {
                const parentId = b.displayName.includes('King\'s Castle') ? 'king\'s_castle' 
                            : b.displayName.includes('Fortress') ? 'fortress' 
                            : b.displayName.includes('Sanctuary') ? 'sanctuary'
                            : b.isRss ? 'alliance_resource_buildings'
                            : b.displayName.includes('Lv.') ? 'outpost' : null;
                
                if (!parentId) return false;
                if (state.overwatchSettings[parentId] === false) return false;
                const childId = b.isRss ? `resource_${b.type}` : (b.id || `${b.x},${b.y}`);
                return state.overwatchSettings[childId] !== false;
            });

            let closestBuilding = null;
            let minDist = Infinity;

            for (const b of trackedBuildings) {
                const buildingCenterX = b.x + (b.w - 1) / 2;
                const buildingCenterY = b.y + (b.h - 1) / 2;
                const dist = Math.hypot(centerX - buildingCenterX, centerY - buildingCenterY);
                if (dist < minDist) {
                    minDist = dist;
                    closestBuilding = b;
                }
            }

            if (closestBuilding && minDist <= config.infoBannerThreshold) {
                const buildingId = closestBuilding.id || `${closestBuilding.x},${closestBuilding.y}`;
                
                if (state.infoBannerBuildingId !== buildingId) {
                    dom.infoBannerName.textContent = closestBuilding.displayText || closestBuilding.displayName;
                    dom.infoBannerCoords.textContent = `(X${closestBuilding.x}, Y${closestBuilding.y})`;
                    const bannerColor = closestBuilding.fillColor || 'var(--panel-bg)';
                    const bannerBorderColor = this.darkenColor(bannerColor, 40) || 'var(--border-color)';
                    dom.infoBanner.style.backgroundColor = bannerColor;
                    dom.infoBanner.style.border = `1px solid ${bannerBorderColor}`;
                    dom.infoBanner.style.color = this.getContrastingTextColor(bannerColor);
                }
                dom.infoBanner.style.display = 'block';
                state.infoBannerBuildingId = buildingId;
            } else {
                dom.infoBanner.style.display = 'none';
                state.infoBannerBuildingId = null;
            }
        },

        // Add this new function
        renderDevModePanel() {
            const toolsContainer = this.dom.devModeTools;
            toolsContainer.innerHTML = ''; // Clear existing tools

            const createToolButton = (tool, type, text) => {
                const btn = document.createElement('button');
                btn.dataset.tool = tool;
                if (type) btn.dataset.type = type;
                btn.textContent = text;
                if (this.state.activeDevTool && this.state.activeDevTool.tool === tool && this.state.activeDevTool.type === type) {
                    btn.classList.add('active');
                }
                return btn;
            };

            // Unoccupiable Tile Tool
            toolsContainer.appendChild(createToolButton('unoccupiable', null, 'Place Unoccupiable'));

            // RSS Tools
            for (const [type, style] of Object.entries(this.config.ALLIANCE_RSS_STYLES)) {
                toolsContainer.appendChild(createToolButton('rss', type, `Place ${style.displayName} RSS`));
            }
            
            // Outpost Tools
            for (const [type, def] of Object.entries(this.BUILDING_CATALOG)) {
                if (type.startsWith('hq_') || type === 'alliance_tower' || type === 'pitfall' || type.startsWith('statue')) continue; // Skip alliance-specific and unwanted dev buildings
                toolsContainer.appendChild(createToolButton('outpost', type, `Place ${def.name}`));
            }
        },

        // Add this new function
        selectDevTool(tool, type) {
            const isDeselecting = this.state.activeDevTool && this.state.activeDevTool.tool === tool && this.state.activeDevTool.type === type;
            
            if (isDeselecting) {
                this.state.activeDevTool = null;
                this.dom.canvas.classList.remove('build-cursor');
            } else {
                this.state.activeDevTool = { tool, type };
                this.dom.canvas.classList.add('build-cursor');
            }

            this.renderDevModePanel(); // Re-render to update active button styles
        },

        // Add this new function
        exportDevMap() {
            const mapData = {
                size: this.config.N,
                unoccupiableTiles: this.state.baseMap.unoccupiableTiles,
                defaultBuildings: this.state.baseMap.defaultBuildings,
                allianceRssBuildings: this.state.baseMap.allianceRssBuildings,
            };
            const jsonString = JSON.stringify(mapData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `baseMap-dev-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('Map data has been exported! Check your downloads.');
        },

        // The entire mainLoop function, for context
        mainLoop(now) {
            const { dom, state, config } = this; const ctx = dom.ctx;
            try {
                ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
                const [centerX, centerY] = this.screenToWorld(dom.canvas.width / 2, dom.canvas.height / 2);
                if (dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
                const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
                const pct = Math.round((currentCamScale / config.baseScale) * 100);
                if (dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
                if (dom.zoomSlider) {
                    const minScalePct = Math.round((state.minFitScale / config.baseScale) * 100);
                    const maxScalePct = Math.round((config.maxPct / 100 * config.baseScale / config.baseScale) * 100);
                    dom.zoomSlider.min = minScalePct; dom.zoomSlider.max = maxScalePct;
                    if (document.activeElement !== dom.zoomSlider) dom.zoomSlider.value = pct;
                }
                state.tileCount = 0; ctx.save();
                ctx.setTransform(currentCamScale, 0, 0, currentCamScale, state.cam.x, state.cam.y);
                ctx.strokeStyle = config.borderColor; ctx.lineWidth = config.strokeW;
                const [tl_x, tl_y] = this.screenToWorld(0, 0); const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
                const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height); const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
                const viewBounds = {
                    minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2, maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
                    minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2, maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
                };
                const viewportCorners = { tl: { x: tl_x, y: tl_y }, tr: { x: tr_x, y: tr_y }, bl: { x: bl_x, y: bl_y }, br: { x: br_x, y: br_y } };
                if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
                    ctx.restore(); this.drawIsometricMinimap(null); requestAnimationFrame(this.mainLoop.bind(this)); return;
                }
                const chunkLevel = this.getChunkLevelForZoom(pct);
                const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
                const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
                const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;

                // --- Pass 1: Draw Base Map Layer ---
                if (chunkLevel === -1) {
                    const shouldDrawBorders = showGrid && pct > 50;
                    for (let x = viewBounds.minX; x <= viewBounds.maxX; x++) {
                        for (let y = viewBounds.minY; y <= viewBounds.maxY; y++) {
                            if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue;
                            if (this.getBuildingAt(x, y)) {
                                continue;
                            }
                            this.drawTile(x, y, shouldDrawBorders);
                        }
                    }
                } else {
                    if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
                        const chunksToDraw = state.chunkLevels[chunkLevel];
                        const chunkSize = Math.pow(2, chunkLevel + 1);
                        const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize;
                        const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
                        const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize;
                        const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
                        for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
                            for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
                                const chunk = chunksToDraw.get(`${x},${y}`);
                                if (chunk) this.drawChunk(chunk, false);
                            }
                        }
                    }
                }
                
                // --- Pass 2: Draw Buildings ---
                state.allVisibleBuildings
                    .filter(b => !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
                    .filter(b => { 
                        if (!b.isRss) return true;
                        return showRss && (alwaysShowRss || chunkLevel === -1);
                    })
                    .forEach(b => this.drawBuildingFootprint(b, null, chunkLevel === -1 && showGrid && pct > 50));
                
                // --- Pass 3: Draw Players ---
                state.placedPlayers
                    .filter(p => !(p.x > viewBounds.maxX || p.x + p.w - 1 < viewBounds.minX || p.y > viewBounds.maxY || p.y + p.h - 1 < viewBounds.minY))
                    .forEach(p => {
                        // THE FIX IS HERE: We simply pass a copy of the player object.
                        // The drawing function will handle deriving all colors from the custom 'p.color'.
                        const buildingLikeObject = { ...p };
                        this.drawBuildingFootprint(buildingLikeObject, null, true);
                    });
                    
                // --- Pass 4: Draw Territory Overlays ---
                this.drawBuildModeOverlays(viewBounds);

                // --- Pass 5: Draw Build Placement Ghost & Coverage Preview ---
                if (state.isBuildMode && state.selectedBuildingType) {
                    const def = this.BUILDING_CATALOG[state.selectedBuildingType];
                    const { canPlace } = this.checkPlacementValidity(state.selectedBuildingType, state.mouseWorldPos.x, state.mouseWorldPos.y);
                    if (def) {
                        if (def.coverage > 0) {
                            const radius = Math.floor(def.coverage / 2);
                            const centerX = state.mouseWorldPos.x + Math.floor(def.w / 2);
                            const centerY = state.mouseWorldPos.y + Math.floor(def.h / 2);
                            const coverageX = centerX - radius;
                            const coverageY = centerY - radius;
                            const coverageSize = def.coverage;
                            const [sbx, sby] = this.worldToScreen(coverageX, coverageY);
                            const [srx, sry] = this.worldToScreen(coverageX + coverageSize - 1, coverageY);
                            const [stx, sty] = this.worldToScreen(coverageX + coverageSize - 1, coverageY + coverageSize - 1);
                            const [slx, sly] = this.worldToScreen(coverageX, coverageY + coverageSize - 1);
                            const p_bottom = { x: sbx, y: sby + config.tileH / 2 };
                            const p_right = { x: srx + config.tileW / 2, y: sry };
                            const p_top = { x: stx, y: sty - config.tileH / 2 };
                            const p_left = { x: slx - config.tileW / 2, y: sly };
                            ctx.beginPath();
                            ctx.moveTo(p_bottom.x, p_bottom.y);
                            ctx.lineTo(p_right.x, p_right.y);
                            ctx.lineTo(p_top.x, p_top.y);
                            ctx.lineTo(p_left.x, p_left.y);
                            ctx.closePath();
                            ctx.fillStyle = canPlace ? this.hexToRgba('#28a745', 0.15) : this.hexToRgba('#dc3545', 0.15);
                            ctx.fill();
                        }
                        const ghostBuilding = {
                            x: state.mouseWorldPos.x, y: state.mouseWorldPos.y,
                            w: def.w, h: def.h,
                            fillColor: canPlace ? this.hexToRgba('#28a745', 0.6) : this.hexToRgba('#dc3545', 0.6),
                            borderColor: canPlace ? this.darkenColor('#28a745', 40) : this.darkenColor('#dc3545', 40)
                        };
                        this.drawBuildingFootprint(ghostBuilding, null, true);
                    }
                }
                
                if (state.isPlacingPlayer && state.playerToPlace) {
                    const def = this.PLAYER_CATALOG['player_castle'];
                    let canPlace = true;
                    for (let dx = 0; dx < def.w; dx++) {
                        for (let dy = 0; dy < def.h; dy++) {
                            if (this.state.specialTileMap.has(`${state.mouseWorldPos.x + dx},${state.mouseWorldPos.y + dy}`) ||
                                this.getBuildingAtCoords(state.mouseWorldPos.x + dx, state.mouseWorldPos.y + dy) ||
                                this.getPlayerAtCoords(state.mouseWorldPos.x + dx, state.mouseWorldPos.y + dy) ) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (!canPlace) break;
                    }

                    const ghostPlayer = {
                        x: state.mouseWorldPos.x, y: state.mouseWorldPos.y,
                        w: def.w, h: def.h,
                        type: 'player_castle',
                        fillColor: canPlace ? this.hexToRgba(state.playerToPlace.color, 0.6) : this.hexToRgba('#dc3545', 0.6),
                        borderColor: canPlace ? this.darkenColor(state.playerToPlace.color, 40) : this.darkenColor('#dc3545', 40),
                        name: state.playerToPlace.name,
                        power: state.playerToPlace.power,
                        color: state.playerToPlace.color
                    };
                    this.drawBuildingFootprint(ghostPlayer, null, true);
                }

                if (now - state.infoBannerUpdateTime > 100) {
                    this.updateInfoBanner();
                    state.infoBannerUpdateTime = now;
                }

                // --- Draw Selection ---
                if (state.selection && !state.isBuildMode) {
                    let highlightColor = config.selectionColor;
                    if (state.selection.pingStart && now - state.selection.pingStart < config.pingDuration) { if (Math.floor((now - state.selection.pingStart) / 100) % 2 === 0) { highlightColor = config.pingColor; } }
                    if (state.selection.w) { this.drawBuildingFootprint(state.selection, highlightColor, true); } 
                    else { const [sx, sy] = this.worldToScreen(state.selection.x, state.selection.y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.strokeStyle = highlightColor; ctx.lineWidth = config.strokeW * 1.5; ctx.stroke(); }
                }
                ctx.restore();
                this.drawIsometricMinimap(viewportCorners);
                const dt = now - state.lastFrame; state.lastFrame = now;
                if (dt > 0) { state.lastFPS = Math.round(1000 / dt); }
                state.lastTiles = state.tileCount;
                if (now - state.statsUpdateTime > 500) {
                    if (dom.statsFPSEl) dom.statsFPSEl.textContent = `FPS:   ${state.lastFPS}`;
                    if (dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
                    state.statsUpdateTime = now;
                }
            } catch (error) { console.error("Error in mainLoop:", error); }
            requestAnimationFrame(this.mainLoop.bind(this));
        },
    
    };
    KingshotPlanner.init();
  </script>
</body>
</html>