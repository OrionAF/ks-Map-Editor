<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>

/* --- BASE & LAYOUT --- */
:root {
	--toolbar-height: 55px;
	--toolbar-bg: rgba(25, 28, 32, 0.75);
	--panel-bg: rgba(35, 38, 43, 0.9);
	--text-color: #e0e0e0;
	--highlight-color: #2a9fd6;
	--border-color: #444;
	/* -- NEW COLORS -- */
	--build-mode-bg: rgba(214, 102, 43, 0.9);
	--success-color: #28a745;
	--danger-color: #dc3545;
}

body {
	margin: 0;
	background: #111;
	overflow: hidden;
	user-select: none;
	-webkit-user-select: none;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
	color: var(--text-color);
}

canvas#map {
	display: block;
	cursor: grab;
}

canvas#map:active {
	cursor: grabbing;
}
canvas#map.build-cursor {
	cursor: crosshair;
}

/* --- NEW BUILD MODE BANNER --- */
#buildModeBanner {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background-color: var(--build-mode-bg);
    color: white;
    text-align: center;
    padding: 8px 0;
    font-size: 14px;
    font-weight: bold;
    z-index: 1001; /* Above toolbar */
    display: none; /* Toggled by JS */
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

#versionDisplay {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 5px);
	left: 10px;
	color: rgba(255, 255, 255, 0.4);
	font-size: 11px;
	user-select: none;
	z-index: 5;
}

#centerTile {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 5px);
	left: 50%;
	transform: translateX(-50%);
	background: rgba(0, 0, 0, 0.5);
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 13px;
	user-select: none;
	z-index: 5;
}

#minimapContainer {
	position: absolute;
	top: 10px;
	right: 10px;
	z-index: 900;
	width: 352px;
	background-color: var(--panel-bg);
	border: 1px solid var(--border-color);
	border-radius: 6px;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	display: none;
	/* Controlled by JS */
}

#minimapContainer.visible {
	display: block;
}

#minimapCanvas {
	width: 350px;
	height: 300px;
	display: block;
	border-radius: 0 0 6px 6px;
}

/* --- NEW BOTTOM TOOLBAR --- */
#bottomToolbar {
	position: fixed;
	bottom: 0;
	left: 0;
	width: 100%;
	height: var(--toolbar-height);
	background: var(--toolbar-bg);
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
	border-top: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 10px;
	box-sizing: border-box;
	z-index: 1000;
}

.toolbar-group {
	display: flex;
	align-items: center;
	gap: 5px;
}

.toolbar-group.center {
	flex-grow: 1;
	justify-content: center;
	min-width: 200px;
	padding: 0 10px;
}

#bottomToolbar button {
	background: none;
	border: none;
	color: var(--text-color);
	font-size: 24px;
	padding: 8px;
	border-radius: 8px;
	cursor: pointer;
	transition: background-color 0.2s;
	line-height: 1;
}

#bottomToolbar button:hover {
	background-color: rgba(255, 255, 255, 0.1);
}

#bottomToolbar button.active {
	background-color: var(--highlight-color);
	color: white;
}
/* -- NEW -- */
#bottomToolbar button#buildModeToggleBtn.active {
	background-color: var(--build-mode-bg);
}


#bottomToolbar #zoomLevel {
	font-size: 14px;
	min-width: 90px;
	text-align: center;
	user-select: none;
}

#zoomSlider {
	flex-grow: 1;
	-webkit-appearance: none;
	appearance: none;
	width: 100%;
	height: 5px;
	background: rgba(255, 255, 255, 0.2);
	border-radius: 5px;
	outline: none;
	margin: 0 10px;
}

#zoomSlider::-webkit-slider-thumb {
	-webkit-appearance: none;
	appearance: none;
	width: 18px;
	height: 18px;
	background: #f1f1f1;
	border-radius: 50%;
	cursor: pointer;
}

#zoomSlider::-moz-range-thumb {
	width: 18px;
	height: 18px;
	background: #f1f1f1;
	border-radius: 50%;
	cursor: pointer;
	border: none;
}

/* --- TOOLBAR PANELS --- */
.toolbar-panel {
	position: absolute;
	bottom: calc(var(--toolbar-height) + 10px);
	background: var(--panel-bg);
	backdrop-filter: blur(10px);
	-webkit-backdrop-filter: blur(10px);
	border: 1px solid var(--border-color);
	border-radius: 8px;
	box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
	padding: 15px;
	z-index: 999;
	display: none;
	/* Toggled by JS */
	opacity: 0;
	transform: translateY(10px);
	transition: opacity 0.2s ease-out, transform 0.2s ease-out;
	width: 320px;
    max-height: calc(100vh - 80px - var(--toolbar-height));
    overflow-y: auto;
	box-sizing: border-box;
}

.toolbar-panel.open {
	display: block;
	opacity: 1;
	transform: translateY(0);
}

.toolbar-panel h4 {
	margin: 0 0 10px 0;
	font-size: 13px;
	color: #aaa;
	text-transform: uppercase;
	font-weight: 600;
	border-bottom: 1px solid var(--border-color);
	padding-bottom: 8px;
}

.panel-section {
	margin-bottom: 15px;
}

.panel-section:last-child {
	margin-bottom: 0;
}
/* General button style inside panels */
.panel-section button, .toolbar-panel button {
    background-color: #4f5358;
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.panel-section button:hover, .toolbar-panel button:hover {
    background-color: #5f6368;
}
.panel-section button.primary, .toolbar-panel button.primary {
    background-color: var(--highlight-color);
}
.panel-section button.danger, .toolbar-panel button.danger {
    background-color: var(--danger-color);
}
.panel-section button:disabled {
    background-color: #333;
    color: #888;
    cursor: not-allowed;
}

/* General input style */
.panel-section input[type="text"],
.panel-section input[type="number"],
.panel-section input[type="color"] {
    background-color: #222;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 6px;
    border-radius: 4px;
    box-sizing: border-box;
}

.bookmarks-list {
	max-height: 250px;
	overflow-y: auto;
	margin-right: -5px;
	padding-right: 5px;
}

.bookmark-item {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 8px 5px;
	font-size: 14px;
	border-bottom: 1px solid #3a3a3a;
}

.bookmark-item:last-child {
	border-bottom: none;
}

.bookmark-item>span {
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	flex-grow: 1;
	padding-right: 10px;
}

.bookmark-item .controls button {
	padding: 2px 6px;
	font-size: 12px;
	margin-left: 5px;
	cursor: pointer;
}

.bookmark-item .unpin-btn {
	color: #fdd;
	background: #5a3838;
}

#pinnedBookmarksPanel {
	left: 10px;
}

#navPanel {
	left: 65px;
}

/* Navigation Panel (Go To & Available Landmarks) */
#navPanel .tab-buttons {
	display: flex;
	margin-bottom: 15px;
	border-radius: 6px;
	overflow: hidden;
	border: 1px solid var(--border-color);
}

#navPanel .tab-button {
	flex: 1;
	padding: 8px;
	background: rgba(0, 0, 0, 0.2);
	border: none;
	color: var(--text-color);
	cursor: pointer;
	font-size: 14px;
}

#navPanel .tab-button.active {
	background: var(--highlight-color);
}

#navPanel .tab-content {
	display: none;
}

#navPanel .tab-content.active {
	display: block;
}

#navPanel #goToContent div {
	display: flex;
	gap: 10px;
	align-items: center;
}

/* Settings Panel */
#settingsPanel {
	right: 10px;
}

#settingsPanel label {
	font-size: 14px;
	user-select: none;
	vertical-align: middle;
}

#settingsPanel>.panel-section>div {
	margin-bottom: 8px;
}

#settingsPanel .info-buttons {
	display: flex;
	gap: 10px;
	margin-top: 10px;
}
#settingsPanel .plan-buttons {
    display: flex;
    gap: 10px;
}

#settingsPanel .info-buttons button, #settingsPanel .plan-buttons button {
	flex: 1;
	cursor: pointer;
}

/* Zoom Presets Panel */
#zoomPresetsPanel {
	right: 65px;
	width: 120px;
	padding: 5px;
}

#zoomPresetsPanel .preset-list {
	display: flex;
	flex-direction: column;
	gap: 4px;
}

/* --- NEW FLOATING BUTTON & PALETTE --- */
#floatingBuildingsBtn {
    position: fixed;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    z-index: 998;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    padding: 15px 8px;
    border-radius: 8px 0 0 8px;
    background-color: var(--panel-bg);
    display: none; /* Toggled by JS */
    border-left: none;
    border-top: 1px solid var(--border-color);
    border-right: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
    /* Add transition for smooth movement */
    transition: transform 0.3s ease-in-out, background-color 0.2s;
}

#floatingBuildingsBtn.active { /* Changed from .open to match JS */
    background-color: var(--highlight-color);
    /* Move left by the width of the panel to look attached */
    transform: translate(-280px, -50%);
}

#buildingPalettePanel {
    top: 50%; /* Center vertically */
    right: 0;
    bottom: unset; /* Override default panel position */
    height: auto; /* Let height be determined by content */
    /* Hide off-screen to the right and center vertically */
    transform: translate(100%, -50%);
    border-radius: 8px 0 0 8px;
    border-right: none;
    transition: transform 0.3s ease-in-out;
    width: 280px; /* Make it a bit smaller */
    max-height: calc(100vh - 40px); /* Add some viewport padding */
    overflow-y: auto;
}

#buildingPalettePanel.open {
    /* Slide into view and stay centered */
    transform: translate(0, -50%);
    opacity: 1; /* Ensure it's visible */
}

/* --- ADD these new rules for the palette's internal layout --- */
#buildingPalettePanel .building-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
}

#buildingPalettePanel .building-list button {
    text-align: center;
}

#buildPanel {
    right: 120px; /* Adjust position */
}
#buildPanel .form-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 8px;
    align-items: center;
    margin-bottom: 12px;
}
#buildPanel .form-grid input[type="color"] {
    padding: 0;
    height: 30px;
    width: 50px;
}
#buildPanel #createAllianceBtn {
    width: 100%;
    margin-top: 5px;
}
#buildPanel .alliance-list {
    display: flex;
    flex-direction: column;
    gap: 5px;
    max-height: 150px;
    overflow-y: auto;
    margin-bottom: 15px;
}
#buildPanel .alliance-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background: rgba(0,0,0,0.2);
    border-radius: 4px;
    border-left: 5px solid transparent; /* Set by JS */
}
#buildPanel .alliance-item.selected {
    background: rgba(42, 159, 214, 0.2);
    border-left-color: var(--highlight-color);
}
#buildPanel .alliance-item .color-swatch {
    width: 16px;
    height: 16px;
    border-radius: 3px;
    flex-shrink: 0;
}
#buildPanel .alliance-item .name {
    flex-grow: 1;
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
#buildPanel .alliance-item .tag {
    font-weight: bold;
    font-size: 13px;
    background: #555;
    padding: 2px 5px;
    border-radius: 3px;
}
#buildPanel .alliance-item .controls {
    display: flex;
    gap: 4px;
}
#buildPanel .alliance-item .controls button {
    font-size: 12px;
    padding: 3px 6px;
}
#buildPanel #buildingMenu {
    display: none; /* Shown by JS when an alliance is selected */
}
#buildPanel .building-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 8px;
}
#buildPanel .building-list button {
    padding: 8px;
    text-align: left;
    font-size: 13px;
    display: flex;
    flex-direction: column;
}
#buildPanel .building-list button span {
    font-size: 11px;
    opacity: 0.7;
}
#buildPanel .building-list button.selected {
    background-color: var(--highlight-color);
}
#buildPanel .building-list button:disabled {
    opacity: 0.5;
}


/* --- OTHER UI ELEMENTS --- */
#statsPanel {
	position: absolute;
	top: 10px;
	left: 10px;
	z-index: 100;
	background: rgba(0, 0, 0, 0.6);
	padding: 6px 10px;
	border-radius: 4px;
	font-size: 13px;
}

/* MODAL STYLES (Unchanged) */
.modal-overlay {
	display: none;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(0, 0, 0, 0.7);
	z-index: 1001;
}

.modal {
	display: none;
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	width: 90%;
	max-width: 500px;
	background: #2c2c2c;
	color: #eee;
	border-radius: 8px;
	z-index: 1002;
	box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
}

.modal-header {
	padding: 15px;
	border-bottom: 1px solid #444;
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.modal-header h3 {
	margin: 0;
}

.modal-header .close-btn {
	background: none;
	border: none;
	color: #ccc;
	font-size: 24px;
	cursor: pointer;
}

.modal-body {
	padding: 15px;
	max-height: 60vh;
	overflow-y: auto;
}

.modal-body ul {
	padding-left: 20px;
	margin: 0;
}

.modal-body li {
	margin-bottom: 8px;
}

/* NEW: Styles for collapsible changelog */
.modal-body details {
    border-bottom: 1px solid #4a4a4a;
    margin-bottom: 5px;
}
.modal-body details:last-of-type {
    border-bottom: none;
}
.modal-body summary {
    cursor: pointer;
    list-style: none; /* Remove default marker */
    padding: 10px 0;
    font-weight: bold;
    font-size: 1.1em;
    position: relative;
}
.modal-body summary::-webkit-details-marker {
    display: none; /* Hide for Safari */
}
.modal-body summary:before {
    content: '‚ñ∂';
    position: absolute;
    left: -15px;
    font-size: 0.8em;
    transition: transform 0.2s;
    transform: rotate(0deg);
}
.modal-body details[open] > summary:before {
    transform: rotate(90deg);
}
.modal-body details > :not(summary) {
    padding-bottom: 10px;
    padding-left: 5px;
}


.modal-footer {
	padding: 10px 15px;
	border-top: 1px solid #444;
	background: #333;
	border-radius: 0 0 8px 8px;
}

.modal-footer label {
	user-select: none;
	font-size: 14px;
}

/* --- RESPONSIVE STYLES --- */
@media (max-width: 768px) {
	.toolbar-group.center {
		padding: 0 5px;
	}

	.toolbar-panel {
		width: calc(100vw - 20px);
		max-width: 400px;
	}

	#pinnedBookmarksPanel,
	#navPanel,
	#settingsPanel,
	#zoomPresetsPanel,
    #buildPanel {
		left: 10px;
		right: 10px;
		width: auto;
	}
}

@media (max-width: 480px) {
	:root {
		--toolbar-height: 50px;
	}

	#bottomToolbar {
		padding: 0 5px;
	}

	.toolbar-group {
		gap: 0;
	}

	.toolbar-group.center {
		min-width: 0;
		flex: 1;
	}

	#bottomToolbar button {
		font-size: 20px;
		padding: 6px;
	}

	#zoomLevel {
		display: none;
	}

	#statsPanel,
	#centerTile,
	#versionDisplay {
		display: none;
	}
}
</style>
</head>
<body>
  <!-- TOP UI ELEMENTS -->
  <div id="statsPanel">
    <div id="statsFPS">FPS: ‚Äì</div>
    <div id="statsTiles">Tiles: ‚Äì</div>
  </div>
  
  <!-- NEW BUILD MODE BANNER -->
  <div id="buildModeBanner">Build Mode Enabled</div>

  <div id="minimapContainer">
      <canvas id="minimapCanvas"></canvas>
  </div>
  
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>
  
  <!-- MAIN CANVAS -->
  <canvas id="map"></canvas>

  <!-- NEW FLOATING BUILDINGS BUTTON & PALETTE -->
  <button id="floatingBuildingsBtn">Buildings</button>

  <div id="buildingPalettePanel" class="toolbar-panel">
      <h4>Buildings</h4>
      <div id="buildingPaletteList" class="building-list">
          <!-- Populated by JS -->
      </div>
  </div>

  <!-- NEW BOTTOM TOOLBAR & PANELS -->
  <div id="bottomToolbar">
    <div class="toolbar-group left">
      <button id="pinnedBookmarksToggleBtn" title="Pinned Landmarks">üìå</button>
      <button id="navPanelToggleBtn" title="Navigation">üß≠</button>
    </div>
    
    <div class="toolbar-group center">
      <button id="zoomDecBtn" title="Zoom Out">-</button>
      <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
      <button id="zoomIncBtn" title="Zoom In">+</button>
      <div id="zoomLevel">Zoom: 100%</div>
    </div>
    
    <div class="toolbar-group right">
      <button id="zoomPresetsToggleBtn" title="Zoom Presets">üéØ</button>
      <button id="buildModeToggleBtn" title="Build Mode">üõ†Ô∏è</button> <!-- NEW -->
      <button id="minimapToggleBtn" title="Toggle Minimap">üó∫Ô∏è</button>
      <button id="settingsToggleBtn" title="Settings">‚öôÔ∏è</button>
    </div>
  </div>

  <div id="pinnedBookmarksPanel" class="toolbar-panel">
      <h4>Pinned Landmarks</h4>
      <div id="pinnedBookmarksList" class="bookmarks-list"><!-- Populated by JS --></div>
  </div>

  <!-- Navigation Panel -->
  <div id="navPanel" class="toolbar-panel">
      <div class="tab-buttons">
          <button class="tab-button active" data-tab="goToContent">Go To</button>
          <button class="tab-button" data-tab="landmarksContent">Landmarks</button>
      </div>
      <div id="goToContent" class="tab-content active">
          <h4>Go To Coordinates</h4>
          <div>
            X: <input id="inpX" type="number" min="0" max="1199" value="0">
            Y: <input id="inpY" type="number" min="0" max="1199" value="0">
            <button id="btnGo">Go</button>
        </div>
      </div>
      <div id="landmarksContent" class="tab-content">
          <h4>Available Landmarks</h4>
          <div id="addBookmarksList" class="bookmarks-list"><!-- Populated by JS --></div>
      </div>
  </div>

  <!-- Settings Panel -->
  <div id="settingsPanel" class="toolbar-panel">
    <div class="panel-section">
      <h4>Display</h4>
      <div><input type="checkbox" id="gridlinesToggle"><label for="gridlinesToggle"> Show Gridlines</label></div>
      <div><input type="checkbox" id="coordsToggle"><label for="coordsToggle"> Show Coords >80%</label></div>
      <div><input type="checkbox" id="allianceRssToggle"><label for="allianceRssToggle"> Show Alliance RSS</label></div>
      <div><input type="checkbox" id="allianceRssAlwaysVisibleToggle"><label for="allianceRssAlwaysVisibleToggle"> Always Show RSS</label></div>
    </div>
    <div class="panel-section">
      <h4>Build Overlays</h4>
      <div><input type="checkbox" id="alwaysShowClaimedToggle"><label for="alwaysShowClaimedToggle"> Always Show Claimed Area</label></div>
    </div>
    <div class="panel-section">
      <h4>Performance</h4>
      <label for="tileDetailSelect">Merge tiles at zoom:</label>
      <select id="tileDetailSelect">
        <option value="19">20% (Ultra)</option>
        <option value="39">40% (Super)</option>
        <option value="49">50% (High)</option>
        <option value="59">60% (Medium)</option>
        <option value="69">70% (Low)</option>
        <option value="79">80% (Very Low)</option>
      </select>
    </div>
    <!-- NEW: Plan Import/Export -->
    <div class="panel-section">
        <h4>Build Plan</h4>
        <div class="plan-buttons">
            <button id="importPlanBtn">Import</button>
            <button id="exportPlanBtn">Export</button>
            <button id="clearPlanBtn" class="danger">Clear Plan</button> 
            <input type="file" id="planFileInput" accept=".json" style="display: none;">
        </div>
    </div>
    <div class="panel-section info-buttons">
        <button id="infoBtn">Controls</button>
        <button id="patchNotesBtn">Patch Notes</button>
    </div>
  </div>

  <!-- Zoom Presets Panel -->
  <div id="zoomPresetsPanel" class="toolbar-panel">
      <div id="zoomPresetsList" class="preset-list">
        <!-- Dynamically populated -->
      </div>
  </div>

  <!-- NEW BUILD PANEL -->
  <div id="buildPanel" class="toolbar-panel">
    <div class="panel-section">
        <h4>Create Alliance</h4>
        <div class="form-grid">
            <label for="allianceName">Name:</label>
            <input type="text" id="allianceName" placeholder="AlphabetSoup" maxlength="20">
            <label for="allianceTag">Tag:</label>
            <input type="text" id="allianceTag" placeholder="ABC" maxlength="3">
            <label for="allianceColor">Color:</label>
            <input type="color" id="allianceColor" value="#d6662b">
        </div>
        <button id="createAllianceBtn" class="primary">Create Alliance</button>
    </div>
    <div class="panel-section">
        <h4>Alliances</h4>
        <div id="allianceList" class="alliance-list">
            <!-- Populated by JS -->
        </div>
    </div>
    <div class="panel-section">
        <button id="toggleBuildModeActualBtn" class="primary">Enter Build Mode</button>
    </div>
  </div>


  <!-- MODALS (unchanged structure, but triggered from new buttons) -->
  <div id="modalOverlay" class="modal-overlay"></div>
  <div id="patchNotesModal" class="modal">
    <div class="modal-header"><h3>What's New?!</h3><button id="closePatchNotesBtn" class="close-btn">√ó</button></div>
    <div class="modal-body" id="patchNotesBody"></div>
    <div class="modal-footer"><input type="checkbox" id="hidePatchNotesCheckbox"><label for="hidePatchNotesCheckbox"> Hide this window until the next update.</label></div>
  </div>
  <div id="controlsModal" class="modal">
      <div class="modal-header"><h3>Controls</h3><button id="closeControlsBtn" class="close-btn">√ó</button></div>
      <div class="modal-body">
          <ul>
            <li><strong>Pan</strong>: Drag with mouse / One-finger drag on touch</li>
            <li><strong>Zoom</strong>: Mouse wheel, +/- buttons, or the slider</li>
            <li><strong>Pinch-to-Zoom</strong>: Use two fingers on touch devices</li>
            <li><strong>Quick Zoom</strong>: Double-click to zoom in</li>
            <li><strong>Keyboard Pan</strong>: Use Arrow Keys</li>
            <li><strong>Select</strong>: Click or tap on any tile</li>
            <li><strong>Place Building (Build Mode)</strong>: Select a building from the menu and click on the map.</li>
            <li><strong>Cancel Placement (Build Mode)</strong>: Right-click or press Escape key.</li>
            <li><strong>Delete Building (Build Mode)</strong>: Right-click on a placed building.</li>
          </ul>
      </div>
  </div>
  <div id="editAllianceModal" class="modal">
    <div class="modal-header">
        <h3>Edit Alliance</h3><button class="close-btn">√ó</button>
    </div>
    <div class="modal-body">
        <input type="hidden" id="editAllianceId">
        <div class="form-grid">
            <label for="editAllianceName">Name:</label>
            <input type="text" id="editAllianceName" placeholder="Alliance Name" maxlength="20">
            <label for="editAllianceTag">Tag:</label>
            <input type="text" id="editAllianceTag" placeholder="TAG" maxlength="3">
            <label for="editAllianceColor">Color:</label>
            <input type="color" id="editAllianceColor">
        </div>
    </div>
    <div class="modal-footer">
        <button id="saveAllianceChangesBtn" class="primary">Save Changes</button>
    </div>
</div>

<script>
    const KingshotPlanner = {
      // --- TWEAKABLE SETTINGS ---
      config: {
        CURRENT_VERSION: '7.1.0.0', 
        N: 1200,
        tileW: 10,
        tileH: 10,
        strokeW: 0.3,
        borderColor: '#000',
        textColor: '#fff',
        maxPct: 250,
        selectionColor: '#ff0',
        pingColor: '#fff',
        pingDuration: 500,
        baseScale: 5,
        biomeColors: {
          fertile: 'rgb(109, 159, 62)',
          plains: 'rgb(158, 180, 103)',
          badlands: 'rgb(191, 208, 152)'
        },
        biomeRegions: {
          fertile: { x1: 480, y1: 480, x2: 719, y2: 719 },
          plains: { x1: 320, y1: 320, x2: 879, y2: 879 },
          badlands: { x1: 0, y1: 0, x2: 1199, y2: 1199 }
        },
        ALLIANCE_RSS_STYLES: {
          wood: { displayName: 'Wood', fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
          food: { displayName: 'Food', fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
          stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
          iron: { displayName: 'Iron', fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
        },
        minimap: {
          width: 350,
          height: 300,
          padding: 5,
          bgColor: 'rgba(40,40,40,0.8)',
          viewportFillColor: 'rgba(255, 255, 255, 0.2)',
          viewportBorderColor: 'rgba(255, 255, 255, 0.85)',
          kingCastleColor: 'rgba(255,215,0,0.9)',
          fortressColor: 'rgba(178,34,34,1)',
          sanctuaryColor: 'rgba(65,105,225,1)',
          buildersGuildOutpostColor: 'rgba(0, 206, 209, 1)',
          foragerGroveOutpostColor: 'rgba(50, 205, 50, 1)',
          harvestAltarOutpostColor: 'rgba(255, 0, 255, 1)',
          scholarsTowerOutpostColor: 'rgba(138, 43, 226, 1)',
          arsenalOutpostColor: 'rgba(255, 0, 0, 1)',
          armoryOutpostColor: 'rgba(0, 128, 128, 1)',
          drillCampOutpostColor: 'rgba(135, 206, 235, 1)',
          frontierLodgeOutpostColor: 'rgba(128, 128, 0, 1)',
          zoomFactorMin: 1.5, 
          zoomFactorMax: 15.0,
          mainMapZoomThresholdForMinimapZoom: 0.03
        }
      },

      // --- NEW HELPER FUNCTIONS ---
      darkenColor(hex, percent) {
        if (!hex.startsWith('#')) return hex;
        let R = parseInt(hex.substring(1, 3), 16);
        let G = parseInt(hex.substring(3, 5), 16);
        let B = parseInt(hex.substring(5, 7), 16);

        R = parseInt(R * (100 - percent) / 100);
        G = parseInt(G * (100 - percent) / 100);
        B = parseInt(B * (100 - percent) / 100);

        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;

        const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
        const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
        const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

        return "#" + RR + GG + BB;
      },
      hexToRgba(hex, alpha = 1) {
        if (!hex.startsWith('#')) return `rgba(0,0,0,${alpha})`;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      },

      // --- BUILDING CATALOG ---
      BUILDING_CATALOG: {
        'alliance_tower': { name: 'Alliance Tower', w: 1, h: 1, coverage: 7, text: 'tag', rule: 'any' },
        'hq_badlands': { name: 'Badlands HQ', w: 3, h: 3, coverage: 15, text: 'tag BadlandsHQ', rule: 'badlands', limit: 1 },
        'hq_plains': { name: 'Plains HQ', w: 3, h: 3, coverage: 15, text: 'tag PlainsHQ', rule: 'plains', limit: 1 },
        'hq_fertile': { name: 'Fertile Lands HQ', w: 3, h: 3, coverage: 15, text: 'tag FertileHQ', rule: 'fertile', limit: 1 },
        'pitfall': { name: 'Pitfall', w: 3, h: 3, coverage: 0, text: 'tag Bear', rule: 'claimed', limit: 1 },
        'statue1': { name: 'Prestige Statue 1', w: 2, h: 2, coverage: 0, text: 'tag Statue 1', rule: 'claimed', limit: 1 },
        'statue2': { name: 'Prestige Statue 2', w: 2, h: 2, coverage: 0, text: 'tag Statue 2', rule: 'claimed', limit: 1 },
        'statue3': { name: 'Prestige Statue 3', w: 2, h: 2, coverage: 0, text: 'tag Statue 3', rule: 'claimed', limit: 1 },
      },
      state: {
        baseMap: { unoccupiableTiles: [], defaultBuildings: [] },
        patchNotes: '',
        allBuildings: [],
        buildingMap: new Map(),
        chunkLevels: [],
        userBuildings: [],
        cam: { x: 0, y: 0, scale: 1 },
        lastFrame: 0,
        tileCount: 0,
        lastFPS: 0,
        lastTiles: 0,
        selection: null,
        minFitScale: 0.1,
        isInitialLoad: true,
        touchStartTime: 0,
        dragging: false,
        lastX: 0,
        lastY: 0,
        clickStartX: 0,
        clickStartY: 0,
        touchMode: null,
        startDist: 0,
        startScale: 1,
        pinchCenter: null,
        startCamX: 0,
        startCamY: 0,
        statsUpdateTime: 0,
        currentTileDetailThreshold: 50,
        isMinimapDragging: false,
        minimapClickStartPos: { x: 0, y: 0 },
        minimapCam: { x: 0, y: 0, scale: 0.1 },
        animationId: null,
        pinnedBookmarks: [],
        openPanel: null,
        isBuildMode: false,
        alliances: [],
        activeAllianceId: null,
        buildModeBuildings: [],
        selectedBuildingType: null,
        claimedTerritory: new Map(), 
        globallyClaimedTiles: new Map(), 
        mouseWorldPos: { x: 0, y: 0 },
      },
      dom: {}, // Will be populated in init()

      // --- CORE INITIALIZATION ---
      init() {
        // --- DOM REFERENCES (Updated for new UI) ---
        this.dom = {
          canvas: document.getElementById('map'),
          ctx: null,
          inpX: document.getElementById('inpX'),
          inpY: document.getElementById('inpY'),
          btnGo: document.getElementById('btnGo'),
          zoomLevelEl: document.getElementById('zoomLevel'),
          zoomDecBtn: document.getElementById('zoomDecBtn'),
          zoomIncBtn: document.getElementById('zoomIncBtn'),
          zoomSlider: document.getElementById('zoomSlider'),
          zoomPresetsToggleBtn: document.getElementById('zoomPresetsToggleBtn'),
          zoomPresetsPanel: document.getElementById('zoomPresetsPanel'),
          zoomPresetsList: document.getElementById('zoomPresetsList'),
          centerTileEl: document.getElementById('centerTile'),
          statsPanel: document.getElementById('statsPanel'),
          statsFPSEl: document.getElementById('statsFPS'),
          statsTilesEl: document.getElementById('statsTiles'),
          coordsToggle: document.getElementById('coordsToggle'),
          versionDisplay: document.getElementById('versionDisplay'),
          modalOverlay: document.getElementById('modalOverlay'),
          patchNotesBtn: document.getElementById('patchNotesBtn'),
          patchNotesModal: document.getElementById('patchNotesModal'),
          patchNotesBody: document.getElementById('patchNotesBody'),
          closePatchNotesBtn: document.getElementById('closePatchNotesBtn'),
          hidePatchNotesCheckbox: document.getElementById('hidePatchNotesCheckbox'),
          infoBtn: document.getElementById('infoBtn'),
          controlsModal: document.getElementById('controlsModal'),
          closeControlsBtn: document.getElementById('closeControlsBtn'),
          tileDetailSelect: document.getElementById('tileDetailSelect'),
          gridlinesToggle: document.getElementById('gridlinesToggle'),
          allianceRssToggle: document.getElementById('allianceRssToggle'),
          allianceRssAlwaysVisibleToggle: document.getElementById('allianceRssAlwaysVisibleToggle'),
          settingsToggleBtn: document.getElementById('settingsToggleBtn'),
          settingsPanel: document.getElementById('settingsPanel'),
          minimapContainer: document.getElementById('minimapContainer'),
          minimapToggleBtn: document.getElementById('minimapToggleBtn'),
          minimapCanvas: document.getElementById('minimapCanvas'),
          pinnedBookmarksToggleBtn: document.getElementById('pinnedBookmarksToggleBtn'),
          pinnedBookmarksPanel: document.getElementById('pinnedBookmarksPanel'),
          pinnedBookmarksList: document.getElementById('pinnedBookmarksList'),
          navPanelToggleBtn: document.getElementById('navPanelToggleBtn'),
          navPanel: document.getElementById('navPanel'),
          addBookmarksList: document.getElementById('addBookmarksList'),
          buildModeBanner: document.getElementById('buildModeBanner'),
          buildModeToggleBtn: document.getElementById('buildModeToggleBtn'),
          buildPanel: document.getElementById('buildPanel'),
          allianceNameInput: document.getElementById('allianceName'),
          allianceTagInput: document.getElementById('allianceTag'),
          allianceColorInput: document.getElementById('allianceColor'),
          createAllianceBtn: document.getElementById('createAllianceBtn'),
          allianceList: document.getElementById('allianceList'),
          toggleBuildModeActualBtn: document.getElementById('toggleBuildModeActualBtn'),
          floatingBuildingsBtn: document.getElementById('floatingBuildingsBtn'),
          buildingPalettePanel: document.getElementById('buildingPalettePanel'),
          buildingPaletteList: document.getElementById('buildingPaletteList'),
          alwaysShowClaimedToggle: document.getElementById('alwaysShowClaimedToggle'),
          editAllianceModal: document.getElementById('editAllianceModal'),
          editAllianceIdInput: document.getElementById('editAllianceId'),
          editAllianceNameInput: document.getElementById('editAllianceName'),
          editAllianceTagInput: document.getElementById('editAllianceTag'),
          editAllianceColorInput: document.getElementById('editAllianceColor'),
          saveAllianceChangesBtn: document.getElementById('saveAllianceChangesBtn'),
          importPlanBtn: document.getElementById('importPlanBtn'),
          exportPlanBtn: document.getElementById('exportPlanBtn'),
          planFileInput: document.getElementById('planFileInput'),
          clearPlanBtn: document.getElementById('clearPlanBtn'),
        };

        this.dom.ctx = this.dom.canvas.getContext('2d');

        if (this.dom.minimapCanvas) {
          const dpr = window.devicePixelRatio || 1;
          this.dom.minimapCanvas.width = this.config.minimap.width * dpr;
          this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
          this.dom.minimapCtx = this.dom.minimapCanvas.getContext('2d');
        }

        this.state.lastFrame = performance.now();
        Promise.all([
          fetch('baseMap.json').then(r => r.ok ? r.json() : { unoccupiableTiles: [], defaultBuildings: [] }),
          fetch('CHANGELOG.md').then(r => r.ok ? r.text() : '')
        ])
        .then(([baseMapData, changelogText]) => {
          Object.assign(this.state.baseMap, baseMapData);
          this.state.patchNotes = changelogText;
          this.preProcessBuildings();
          this.preCalculateChunks();
          this.loadPlanFromLocalStorage();
          this.initializeUI();
          this.resize();
          requestAnimationFrame(this.mainLoop.bind(this));
        })
        .catch(e => console.error("Error during initialization:", e));
      },

      initializeUI() {
          // --- PANEL TOGGLING LOGIC ---
          const panelMap = {
              'settings': { btn: this.dom.settingsToggleBtn, panel: this.dom.settingsPanel },
              'nav': { btn: this.dom.navPanelToggleBtn, panel: this.dom.navPanel },
              'zoomPresets': { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel },
              'pinnedBookmarks': { btn: this.dom.pinnedBookmarksToggleBtn, panel: this.dom.pinnedBookmarksPanel },
              'build': { btn: this.dom.buildModeToggleBtn, panel: this.dom.buildPanel },
              'buildingPalette': { btn: this.dom.floatingBuildingsBtn, panel: this.dom.buildingPalettePanel }
          };
          
          const togglePanel = (panelName) => {
                  const panelInfo = panelMap[panelName];
                  if (!panelInfo) return;

                  if (panelInfo.panel.classList.contains('open')) {
                      panelInfo.panel.classList.remove('open');
                      panelInfo.btn.classList.remove('active');
                      this.state.openPanel = null;
                  } else {
                      if (this.state.openPanel && panelMap[this.state.openPanel]) {
                          panelMap[this.state.openPanel].panel.classList.remove('open');
                          panelMap[this.state.openPanel].btn.classList.remove('active');
                      }
                      panelInfo.panel.classList.add('open');
                      panelInfo.btn.classList.add('active');
                      this.state.openPanel = panelName;
                  }
              };

          // Close panels when clicking outside
          document.addEventListener('click', (e) => {
              if (!this.state.openPanel) return;
              const current = panelMap[this.state.openPanel];
              if (!current.panel.contains(e.target) && !current.btn.contains(e.target)) {
                  togglePanel(this.state.openPanel);
              }
          });

          // Attach toggle events
          Object.keys(panelMap).forEach(key => {
              panelMap[key].btn.addEventListener('click', (e) => { 
                  e.stopPropagation(); 
                  if (key === 'build') {
                      this.renderAlliancePanel();
                  }
                  togglePanel(key); 
              });
          });

          // --- FIX: Navigation Panel Tab Logic ---
          const navPanel = this.dom.navPanel;
          if (navPanel) {
              navPanel.addEventListener('click', (e) => {
                  if (e.target.classList.contains('tab-button')) {
                      const tabId = e.target.dataset.tab;
                      if (!tabId) return;
                      navPanel.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                      navPanel.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                      e.target.classList.add('active');
                      const activeContent = document.getElementById(tabId);
                      if(activeContent) activeContent.classList.add('active');
                  }
              });
          }
          
          // MODAL and other event listeners...
          if (this.dom.infoBtn) this.dom.infoBtn.addEventListener('click', this.showControlsModal.bind(this));
          if (this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
          
          document.querySelectorAll('.modal .close-btn').forEach(btn => btn.addEventListener('click', () => this.hideAllModals()));
          if (this.dom.modalOverlay) this.dom.modalOverlay.addEventListener('click', () => this.hideAllModals());

          const lastSeenVersion = localStorage.getItem('lastSeenVersion');
          if (lastSeenVersion !== this.config.CURRENT_VERSION) { this.showPatchNotes(); }
          
          const settingsToPersist = {
              'mapTileDetail': { el: this.dom.tileDetailSelect, default: '49', prop: 'value' },
              'mapAlwaysShowRss': { el: this.dom.allianceRssAlwaysVisibleToggle, default: 'false', prop: 'checked' },
              'mapShowGridlines': { el: this.dom.gridlinesToggle, default: 'true', prop: 'checked' },
              'mapShowAllianceRss': { el: this.dom.allianceRssToggle, default: 'true', prop: 'checked' },
              'mapShowCoords': { el: this.dom.coordsToggle, default: 'true', prop: 'checked' },
              'mapAlwaysShowClaimed': { el: this.dom.alwaysShowClaimedToggle, default: 'false', prop: 'checked'},
          };
          Object.entries(settingsToPersist).forEach(([key, conf]) => {
              if (conf.el) {
                  const saved = localStorage.getItem(key) ?? conf.default;
                  conf.el[conf.prop] = conf.prop === 'checked' ? (saved === 'true') : saved;
                  conf.el.addEventListener('change', () => {
                      localStorage.setItem(key, String(conf.el[conf.prop]));
                      if(key === 'mapTileDetail') this.state.currentTileDetailThreshold = parseInt(conf.el.value, 10);
                  });
                  if(key === 'mapTileDetail') this.state.currentTileDetailThreshold = parseInt(conf.el.value, 10);
              }
          });
          
          this.loadPinnedBookmarks();
          this.renderAllBookmarkUI();
          if (this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
          
          if (this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
          if (this.dom.inpX && this.dom.inpY) [this.dom.inpX, this.dom.inpY].forEach(i => i.addEventListener('keydown', e => { if (e.key === 'Enter') this.doSearch(); }));
          
          if (this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-5));
          if (this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+5));
          if (this.dom.zoomSlider) this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));

          this.renderZoomPresets();

          if (this.dom.minimapToggleBtn && this.dom.minimapContainer) {
            this.dom.minimapToggleBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              this.dom.minimapContainer.classList.toggle('visible');
              this.dom.minimapToggleBtn.classList.toggle('active', this.dom.minimapContainer.classList.contains('visible'));
            });
            const isDesktop = window.innerWidth > 768;
            this.dom.minimapContainer.classList.toggle('visible', isDesktop);
            this.dom.minimapToggleBtn.classList.toggle('active', isDesktop);
          }
          
          // --- BUILD MODE UI LISTENERS ---
          if (this.dom.buildModeToggleBtn) this.dom.buildModeToggleBtn.title = "Manage Plan / Alliances";
          if (this.dom.toggleBuildModeActualBtn) this.dom.toggleBuildModeActualBtn.addEventListener('click', this.setBuildModeActive.bind(this));
          if (this.dom.createAllianceBtn) this.dom.createAllianceBtn.addEventListener('click', this.createAlliance.bind(this));
          if (this.dom.exportPlanBtn) this.dom.exportPlanBtn.addEventListener('click', this.exportPlan.bind(this));
          if (this.dom.importPlanBtn) this.dom.importPlanBtn.addEventListener('click', () => this.dom.planFileInput.click());
          if (this.dom.planFileInput) this.dom.planFileInput.addEventListener('change', this.importPlan.bind(this));
          if (this.dom.clearPlanBtn) this.dom.clearPlanBtn.addEventListener('click', this.clearPlan.bind(this));
          if (this.dom.saveAllianceChangesBtn) this.dom.saveAllianceChangesBtn.addEventListener('click', this.saveAllianceChanges.bind(this));

          window.addEventListener('resize', this.resize.bind(this));
          window.addEventListener('mousemove', this.handleMouseMove.bind(this));
          window.addEventListener('mouseup', () => { this.state.dragging = false; });
          window.addEventListener('keydown', this.handleKeyDown.bind(this));
          this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
          this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
          this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
          this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
          this.dom.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
          this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
          this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
          this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
          if (this.dom.minimapCanvas) {
            this.dom.minimapCanvas.addEventListener('mousedown', this.handleMinimapMouseDown.bind(this));
            this.dom.minimapCanvas.addEventListener('mousemove', this.handleMinimapMouseMove.bind(this));
            this.dom.minimapCanvas.addEventListener('mouseleave', this.handleMinimapMouseUp.bind(this));
            window.addEventListener('mouseup', this.handleMinimapMouseUp.bind(this));
          }
      },
      
      setBuildModeActive() {
          this.state.isBuildMode = !this.state.isBuildMode;
          const isActive = this.state.isBuildMode;

          this.dom.floatingBuildingsBtn.style.display = isActive ? 'block' : 'none';
          this.dom.toggleBuildModeActualBtn.textContent = isActive ? 'Exit Build Mode' : 'Enter Build Mode';
          this.dom.toggleBuildModeActualBtn.classList.toggle('danger', isActive);
          
          this.dom.buildModeBanner.style.display = isActive ? 'block' : 'none';
          if (isActive) {
              this.updateBanner(); // Update banner when entering build mode
          }

          if (!isActive) {
              this.dom.buildingPalettePanel.classList.remove('open');
              this.dom.floatingBuildingsBtn.classList.remove('open');
              this.state.selectedBuildingType = null;
              this.dom.canvas.classList.remove('build-cursor');
          }
        },

      updateBanner() {
          if (this.state.isBuildMode && this.state.activeAllianceId) {
              const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);
              if (alliance) {
                  this.dom.buildModeBanner.textContent = `Building as [${alliance.tag}] ${alliance.name}`;
                  this.dom.buildModeBanner.style.backgroundColor = alliance.color;
              }
          } else {
              this.dom.buildModeBanner.textContent = "Build Mode Enabled";
              this.dom.buildModeBanner.style.backgroundColor = 'var(--build-mode-bg)';
          }
        },

      createAlliance() {
        const name = this.dom.allianceNameInput.value.trim();
        const tag = this.dom.allianceTagInput.value.trim().toUpperCase();
        const color = this.dom.allianceColorInput.value;

        if (!name || !tag || tag.length === 0 || tag.length > 3) {
            alert("Please provide a valid alliance name and a 3 character tag.");
            return;
        }

        const newAlliance = {
            id: Date.now(),
            name,
            tag,
            color
        };

        this.state.alliances.push(newAlliance);
        this.savePlanToLocalStorage();
        this.dom.allianceNameInput.value = '';
        this.dom.allianceTagInput.value = '';
        this.renderAlliancePanel();
      },

      selectAlliance(id) {
          const isDeselecting = this.state.activeAllianceId === id;
          this.state.activeAllianceId = isDeselecting ? null : id;
          
          this.updateBanner();
          this.dom.allianceList.querySelectorAll('.alliance-item').forEach(item => {
              const itemId = parseInt(item.dataset.allianceId, 10);
              item.classList.toggle('selected', itemId === this.state.activeAllianceId);
              item.querySelector('.select-btn').textContent = (itemId === this.state.activeAllianceId) ? 'Selected' : 'Select';
          });
          
          this.dom.floatingBuildingsBtn.style.color = this.state.activeAllianceId ? this.state.alliances.find(a=>a.id === this.state.activeAllianceId).color : 'var(--text-color)';
          this.renderBuildingPalette();
      },
      
      deleteAlliance(id) {
          if (!confirm("Are you sure you want to delete this alliance and all its buildings? This cannot be undone.")) {
              return;
          }
          this.state.alliances = this.state.alliances.filter(a => a.id !== id);
          this.state.buildModeBuildings = this.state.buildModeBuildings.filter(b => b.allianceId !== id);
          if (this.state.activeAllianceId === id) {
              this.state.activeAllianceId = null;
              this.updateBanner();
          }
          this.recalculateAllClaimedTerritory();
          this.savePlanToLocalStorage();
          this.renderAlliancePanel();
      },

      renderAlliancePanel() {
          this.dom.allianceList.innerHTML = '';
          this.state.alliances.forEach(alliance => {
              const item = document.createElement('div');
              item.className = 'alliance-item';
              item.dataset.allianceId = alliance.id;
              if (alliance.id === this.state.activeAllianceId) {
                  item.classList.add('selected');
              }
              item.style.borderLeftColor = alliance.color;
              item.innerHTML = `
                  <div class="color-swatch" style="background-color: ${alliance.color};"></div>
                  <div class="name">${alliance.name}</div>
                  <div class="tag">${alliance.tag}</div>
                  <div class="controls">
                      <button class="edit-btn">Edit</button>
                      <button class="select-btn primary">${alliance.id === this.state.activeAllianceId ? 'Selected' : 'Select'}</button>
                      <button class="delete-btn danger">Del</button>
                  </div>
              `;
              item.querySelector('.edit-btn').onclick = () => this.showEditAllianceModal(alliance.id);
              item.querySelector('.select-btn').onclick = () => this.selectAlliance(alliance.id);
              item.querySelector('.delete-btn').onclick = () => this.deleteAlliance(alliance.id);
              this.dom.allianceList.appendChild(item);
          });
      },

      showEditAllianceModal(allianceId) {
          const alliance = this.state.alliances.find(a => a.id === allianceId);
          if (!alliance) return;

          this.dom.editAllianceIdInput.value = alliance.id;
          this.dom.editAllianceNameInput.value = alliance.name;
          this.dom.editAllianceTagInput.value = alliance.tag;
          this.dom.editAllianceColorInput.value = alliance.color;

          this.dom.modalOverlay.style.display = 'block';
          this.dom.editAllianceModal.style.display = 'block';
      },

      saveAllianceChanges() {
          const id = parseInt(this.dom.editAllianceIdInput.value, 10);
          const alliance = this.state.alliances.find(a => a.id === id);
          if (!alliance) return;

          const newName = this.dom.editAllianceNameInput.value.trim();
          const newTag = this.dom.editAllianceTagInput.value.trim().toUpperCase();

          if (!newName || !newTag || newTag.length === 0 || newTag.length > 3) {
              alert("Please provide a valid alliance name and a 3 character tag.");
              return;
          }

          alliance.name = newName;
          alliance.tag = newTag;
          alliance.color = this.dom.editAllianceColorInput.value;

          this.savePlanToLocalStorage();
          this.renderAlliancePanel();
          this.updateBanner();
          this.hideAllModals();
      },

      hideAllModals() {
          this.dom.modalOverlay.style.display = 'none';
          this.dom.patchNotesModal.style.display = 'none';
          this.dom.controlsModal.style.display = 'none';
          this.dom.editAllianceModal.style.display = 'none';
      },

      renderBuildingPalette() {
          if (!this.dom.buildingPaletteList) return;
          this.dom.buildingPaletteList.innerHTML = '';
          const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);
          
          if (!alliance) return;

          const allianceBuildings = this.state.buildModeBuildings.filter(b => b.allianceId === alliance.id);
          const buildingCounts = allianceBuildings.reduce((acc, b) => {
              acc[b.type] = (acc[b.type] || 0) + 1;
              return acc;
          }, {});

          for (const [type, def] of Object.entries(this.BUILDING_CATALOG)) {
              const btn = document.createElement('button');
              btn.dataset.type = type;
              btn.innerHTML = `${def.name}<br><span>S: ${def.w}x${def.h} | R: ${def.coverage}x${def.coverage}</span>`;
              
              if (def.limit > 0) {
                  const currentCount = buildingCounts[type] || 0;
                  if (currentCount >= def.limit) {
                      btn.disabled = true;
                      btn.title = `Limit of ${def.limit} reached`;
                  }
              }

              if (this.state.selectedBuildingType === type) {
                  btn.classList.add('selected');
              }
              btn.onclick = () => this.selectBuildingToPlace(type);
              this.dom.buildingPaletteList.appendChild(btn);
          }
      },
      
      selectBuildingToPlace(type) {
          const isDeselecting = this.state.selectedBuildingType === type;
          this.state.selectedBuildingType = isDeselecting ? null : type;

          this.dom.canvas.classList.toggle('build-cursor', !!this.state.selectedBuildingType);
          this.dom.buildingPaletteList.querySelectorAll('button').forEach(btn => {
              btn.classList.toggle('selected', btn.dataset.type === this.state.selectedBuildingType);
          });
      },

      savePlanToLocalStorage() {
          try {
              const planData = {
                  alliances: this.state.alliances,
                  buildings: this.state.buildModeBuildings
              };
              localStorage.setItem('kingshot_build_plan', JSON.stringify(planData));
          } catch(e) {
              console.error("Could not save plan to local storage:", e);
          }
      },

      loadPlanFromLocalStorage() {
          try {
              const savedPlan = localStorage.getItem('kingshot_build_plan');
              if (savedPlan) {
                  const data = JSON.parse(savedPlan);
                  if (data && Array.isArray(data.alliances) && Array.isArray(data.buildings)) {
                      this.state.alliances = data.alliances;
                      this.state.buildModeBuildings = data.buildings;
                      this.recalculateAllClaimedTerritory();
                      console.log("Backup plan loaded from browser storage.");
                  }
              }
          } catch (e) {
              console.error("Could not load plan from local storage:", e);
              localStorage.removeItem('kingshot_build_plan');
          }
      },

      clearPlan() {
          if (confirm("Are you sure you want to clear the entire plan? This will delete all alliances and buildings and cannot be undone.")) {
              this.state.alliances = [];
              this.state.buildModeBuildings = [];
              this.state.activeAllianceId = null;
              
              if(this.state.isBuildMode) {
                  this.setBuildModeActive();
              }
              
              this.recalculateAllClaimedTerritory();
              localStorage.removeItem('kingshot_build_plan');
              
              if(this.dom.buildPanel.classList.contains('open')) {
                this.renderAlliancePanel();
              }
              
              alert("Plan cleared.");
          }
      },

      exportPlan() {
          if (this.state.alliances.length === 0 && this.state.buildModeBuildings.length === 0) {
              alert("Nothing to export. Create some alliances or buildings first.");
              return;
          }
          const planData = {
              version: 1,
              alliances: this.state.alliances,
              buildings: this.state.buildModeBuildings
          };
          const jsonString = JSON.stringify(planData, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `kingshot-plan-${new Date().toISOString().slice(0,10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
      },

      importPlan(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
              try {
                  const data = JSON.parse(e.target.result);
                  if (data && data.version === 1 && Array.isArray(data.alliances) && Array.isArray(data.buildings)) {
                      if (!confirm("This will overwrite your current plan. Are you sure?")) {
                          this.dom.planFileInput.value = '';
                          return;
                      }
                      this.state.alliances = data.alliances;
                      this.state.buildModeBuildings = data.buildings;
                      this.recalculateAllClaimedTerritory();
                      this.savePlanToLocalStorage();
                      if(this.state.isBuildMode) {
                        this.renderAlliancePanel();
                      }
                      alert("Plan imported successfully!");
                  } else {
                      throw new Error("Invalid or unsupported plan file format.");
                  }
              } catch (error) {
                  alert(`Error importing plan: ${error.message}`);
                  console.error(error);
              } finally {
                this.dom.planFileInput.value = '';
              }
          };
          reader.readAsText(file);
      },

      recalculateAllClaimedTerritory() {
          this.state.globallyClaimedTiles.clear();
          this.state.claimedTerritory.clear();
          this.state.alliances.forEach(a => this.state.claimedTerritory.set(a.id, new Set()));

          this.state.allBuildings.forEach(b => {
              if (!b.isRss && b.coverage) {}
          });
          
          for (const b of this.state.buildModeBuildings) {
              const def = this.BUILDING_CATALOG[b.type];
              if (!def || def.coverage <= 0) continue;

              const allianceTerritory = this.state.claimedTerritory.get(b.allianceId);
              if (!allianceTerritory) continue;
              
              const radius = Math.floor(def.coverage / 2);
              const centerX = b.x + Math.floor(def.w / 2);
              const centerY = b.y + Math.floor(def.h / 2);

              for (let dx = -radius; dx <= radius; dx++) {
                  for (let dy = -radius; dy <= radius; dy++) {
                      const tileX = centerX + dx;
                      const tileY = centerY + dy;
                      const coordStr = `${tileX},${tileY}`;

                      const defaultBuilding = this.getBuildingAt(tileX, tileY);
                      if (defaultBuilding && !defaultBuilding.isRss) {
                          continue;
                      }

                      if (!this.state.globallyClaimedTiles.has(coordStr)) {
                          this.state.globallyClaimedTiles.set(coordStr, b.allianceId);
                          allianceTerritory.add(coordStr);
                      }
                  }
              }
          }
      },

      isTileClaimedBy(x, y, allianceId) {
          const territory = this.state.claimedTerritory.get(allianceId);
          return territory ? territory.has(`${x},${y}`) : false;
      },
      
      getBuildingAtCoords(x, y) {
        const defaultBuilding = this.getBuildingAt(x, y);
        if (defaultBuilding) return defaultBuilding;
        
        for (const b of this.state.buildModeBuildings) {
            if (x >= b.x && x < b.x + b.w && y >= b.y && y < b.y + b.h) {
                return b;
            }
        }
        return null;
      },

      checkPlacementValidity(type, x, y) {
          const def = this.BUILDING_CATALOG[type];
          const allianceId = this.state.activeAllianceId;
          if (!def || !allianceId) return { canPlace: false, message: "No building type or alliance selected." };

          if (def.limit > 0) {
              const count = this.state.buildModeBuildings.filter(b => b.allianceId === allianceId && b.type === type).length;
              if (count >= def.limit) {
                  return { canPlace: false, message: `Limit of ${def.limit} for ${def.name} reached for this alliance.` };
              }
          }

          for (let dx = 0; dx < def.w; dx++) {
              for (let dy = 0; dy < def.h; dy++) {
                  if (this.getBuildingAtCoords(x + dx, y + dy)) {
                      return { canPlace: false, message: "Collision with another building." };
                  }
              }
          }
          
          if (type === 'alliance_tower') {
              const claimedBy = this.state.globallyClaimedTiles.get(`${x},${y}`);
              if (claimedBy && claimedBy !== allianceId) {
                  return { canPlace: false, message: "Cannot place a tower in another alliance's territory." };
              }
          }

          if (def.rule === 'claimed') {
              let isClaimed = false;
              for (let dx = 0; dx < def.w; dx++) {
                  for (let dy = 0; dy < def.h; dy++) {
                      if (this.isTileClaimedBy(x + dx, y + dy, allianceId)) {
                          isClaimed = true;
                          break;
                      }
                  }
                  if(isClaimed) break;
              }
              if (!isClaimed) return { canPlace: false, message: "Must be placed on own alliance territory." };
          } else if (def.rule !== 'any') {
              const biome = this.getBiomeForTile(x, y);
              if (biome !== def.rule) {
                  return { canPlace: false, message: `Must be placed in ${def.rule} biome.` };
              }
          }

          return { canPlace: true, message: "OK" };
      },

      placeBuilding(type, x, y) {
          if (!this.state.activeAllianceId) return;
          const def = this.BUILDING_CATALOG[type];
          if (!def) return;

          const { canPlace, message } = this.checkPlacementValidity(type, x, y);
          if (!canPlace) {
              alert(`Cannot place building: ${message}`);
              console.warn(`Cannot place building: ${message}`);
              return;
          }

          const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);
          let text = def.text.replace('tag', alliance.tag);

          const newBuilding = {
              id: Date.now(),
              type, x, y,
              w: def.w, h: def.h,
              allianceId: this.state.activeAllianceId,
              displayText: text
          };
          
          this.state.buildModeBuildings.push(newBuilding);
          this.recalculateAllClaimedTerritory();
          this.savePlanToLocalStorage();
          this.renderBuildingPalette();
      },

      deleteBuildModeBuilding(buildingId) {
          this.state.buildModeBuildings = this.state.buildModeBuildings.filter(b => b.id !== buildingId);
          this.recalculateAllClaimedTerritory();
          this.savePlanToLocalStorage();
          this.renderBuildingPalette();
      },

      renderZoomPresets() {
        if (!this.dom.zoomPresetsList) return;
        this.dom.zoomPresetsList.innerHTML = '';
        ['Fit', '5%', '10%', '20%', '40%', '60%', '80%', '100%'].forEach(p => {
            const btn = document.createElement('button'); btn.textContent = p;
            btn.onclick = () => {
                if (p === 'Fit') { this.zoomToFit(); } 
                else {
                    const zoomVal = parseInt(p, 10);
                    const targetScale = (zoomVal / 100) * this.config.baseScale;
                    this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 200);
                }
                if (this.state.openPanel) {
                    const panelMap = { 'zoomPresets': { btn: this.dom.zoomPresetsToggleBtn, panel: this.dom.zoomPresetsPanel }};
                    const current = panelMap[this.state.openPanel];
                    if(current) {
                        current.panel.classList.remove('open');
                        current.btn.classList.remove('active');
                        this.state.openPanel = null;
                    }
                }
            };
            this.dom.zoomPresetsList.appendChild(btn);
        });
      },

      loadPinnedBookmarks() { 
        if (localStorage.getItem('pinnedBookmarks')) { 
            try { 
                this.state.pinnedBookmarks = JSON.parse(localStorage.getItem('pinnedBookmarks')) || []; 
            } 
            catch(e) { 
                this.state.pinnedBookmarks = []; 
            } 
        } 
      },

      savePinnedBookmarks() {
        localStorage.setItem('pinnedBookmarks', JSON.stringify(this.state.pinnedBookmarks));
      },

      pinBookmark(bookmark) {
        if (!this.state.pinnedBookmarks.some(p => p.x === bookmark.x && p.y === bookmark.y)) {
          this.state.pinnedBookmarks.push({ 
            x: bookmark.x, 
            y: bookmark.y, 
            displayName: bookmark.displayName 
          });
          this.savePinnedBookmarks(); 
          this.renderAllBookmarkUI();
        }
      },

      unpinBookmark(x, y) {
        this.state.pinnedBookmarks = this.state.pinnedBookmarks.filter(p => !(p.x === x && p.y === y));
        this.savePinnedBookmarks(); 
        this.renderAllBookmarkUI();
      },

      renderAllBookmarkUI() {
        this.renderPinnedBookmarks(); 
        this.renderAddBookmarksList();
      },

      createBookmarkItem(b, isPinned) {
          const item = document.createElement('div');
          item.className = 'bookmark-item';
          const nameSpan = document.createElement('span');
          nameSpan.textContent = b.displayName;
          
          const controlsDiv = document.createElement('div');
          controlsDiv.className = 'controls';
          const goBtn = document.createElement('button');
          goBtn.textContent = 'Go';
          goBtn.onclick = () => this.goToBookmark(b.x, b.y);

          if (isPinned) {
              const unpinBtn = document.createElement('button');
              unpinBtn.textContent = 'Unpin';
              unpinBtn.className = 'unpin-btn';
              unpinBtn.onclick = () => this.unpinBookmark(b.x, b.y);
              controlsDiv.append(goBtn, unpinBtn);
          } else {
              const pinBtn = document.createElement('button');
              pinBtn.textContent = 'Pin';
              pinBtn.onclick = () => this.pinBookmark(b);
              controlsDiv.append(goBtn, pinBtn);
          }
          item.append(nameSpan, controlsDiv);
          return item;
      },
      renderPinnedBookmarks() {
        if (!this.dom.pinnedBookmarksList) return;
        this.dom.pinnedBookmarksList.innerHTML = '';
        this.state.pinnedBookmarks.forEach(p => this.dom.pinnedBookmarksList.appendChild(this.createBookmarkItem(p, true)));
      },

      renderAddBookmarksList() {
        if (!this.dom.addBookmarksList || !this.state.baseMap.defaultBuildings) return;
          this.dom.addBookmarksList.innerHTML = '';
          const landmarkKeywords = ["King's Castle", "Fortress", "Sanctuary", "Outpost", "Altar", "Tower", "Grove", "Armory", "Arsenal", "Camp", "Lodge"];
          const allLandmarks = this.state.baseMap.defaultBuildings.filter(b => b.displayName && landmarkKeywords.some(kw => b.displayName.includes(kw)));
          const unpinned = allLandmarks.filter(landmark => !this.state.pinnedBookmarks.some(p => p.x === landmark.x && p.y === landmark.y));
            
          const getSortOrder = (name) => {
            if (name.includes("King's Castle")) return 0;
            if (name.includes("Fortress")) return 1;
            if (name.includes("Sanctuary")) return 2;
            if (name.includes("Lv.")) return 3 + parseInt(name.split('Lv.')[1], 10); // Sort by level
            return 10;
          };

          unpinned.sort((a, b) => {
            const orderA = getSortOrder(a.displayName);
            const orderB = getSortOrder(b.displayName);
            if (orderA !== orderB) return orderA - orderB;
            return a.displayName.localeCompare(b.displayName, undefined, { numeric: true });
          });
          unpinned.forEach(b => this.dom.addBookmarksList.appendChild(this.createBookmarkItem(b, false)));
      },
        goToBookmark(x, y) {
            if (this.state.openPanel) {
                const panelMap = { 'nav': {btn: this.dom.navPanelToggleBtn, panel: this.dom.navPanel}, 'pinnedBookmarks': {btn: this.dom.pinnedBookmarksToggleBtn, panel: this.dom.pinnedBookmarksPanel} };
                const current = panelMap[this.state.openPanel];
                if(current) {
                    current.panel.classList.remove('open');
                    current.btn.classList.remove('active');
                    this.state.openPanel = null;
                }
            }
            if (x >= 0 && y >= 0) {
                this.state.selection = this.getBuildingAtCoords(x, y) || { x, y };
                if (this.state.selection) this.state.selection.pingStart = performance.now();
                const targetScale = this.config.baseScale;
                const [screenX, screenY] = this.worldToScreen(x, y);
                this.animatePanZoom(targetScale, this.dom.canvas.width / 2 - screenX * targetScale, this.dom.canvas.height / 2 - screenY * targetScale);
            }
        },

      showPatchNotes() {
        if (!this.dom.modalOverlay || !this.dom.patchNotesModal) return;

        if (typeof marked !== 'undefined') { marked.setOptions({ gfm: true, breaks: true, sanitize: false }); } 
        let text = this.state.patchNotes || '';
        const idx = text.indexOf('## ['); 
        if (idx !== -1) { text = text.substring(idx); } 
        this.dom.patchNotesBody.innerHTML = marked.parse(text || 'No changelog available.');
        
        const headers = this.dom.patchNotesBody.querySelectorAll('h2');
        headers.forEach((header, index) => {
            const details = document.createElement('details');
            if (index === 0) {
                details.open = true;
            }

            const summary = document.createElement('summary');
            summary.innerHTML = header.innerHTML;
            details.appendChild(summary);

            let sibling = header.nextElementSibling;
            while(sibling && sibling.tagName !== 'H2') {
                const nextSibling = sibling.nextElementSibling;
                details.appendChild(sibling); 
                sibling = nextSibling;
            }
            
            header.parentNode.replaceChild(details, header);
        });

        this.dom.modalOverlay.style.display = 'block'; 
        this.dom.patchNotesModal.style.display = 'block'; 
      },

      hidePatchNotes() { 
        if (this.dom.modalOverlay && this.dom.patchNotesModal) { 
            if (this.dom.hidePatchNotesCheckbox && this.dom.hidePatchNotesCheckbox.checked) { 
                localStorage.setItem('lastSeenVersion', this.config.CURRENT_VERSION); 
            } 
            this.dom.modalOverlay.style.display = 'none'; 
            this.dom.patchNotesModal.style.display = 'none'; 
        } 
      },

      showControlsModal() { 
        if (this.dom.modalOverlay && this.dom.controlsModal) { 
            this.dom.modalOverlay.style.display = 'block'; 
            this.dom.controlsModal.style.display = 'block'; 
        } 
      },

      hideControlsModal() { 
        if (this.dom.modalOverlay && this.dom.controlsModal) { 
            this.dom.modalOverlay.style.display = 'none'; 
            this.dom.controlsModal.style.display = 'none'; 
        } 
      },

      preProcessBuildings() {
        let buildings = [...(this.state.baseMap.defaultBuildings || []), ...(this.state.userBuildings || [])];
        if (this.state.baseMap.allianceRssBuildings) {
          const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
            const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
            return { x: rss.x, y: rss.y, w: 2, h: 2, displayName: style.displayName, fillColor: style.fillColor, borderColor: style.borderColor, displayCoordinates: false, isRss: true };
          });
          buildings = buildings.concat(formattedRssBuildings);
        }
        this.state.allBuildings = buildings;
        this.state.buildingMap.clear();
        for (const b of this.state.allBuildings) {
          if (typeof b.w === 'number' && typeof b.h === 'number') {
            for (let dx = 0; dx < b.w; dx++) {
              for (let dy = 0; dy < b.h; dy++) { this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b); }
            }
          }
        }
      },

      preCalculateChunks() {
        const numLevels = 4; this.state.chunkLevels = [];
        for (let level = 0; level < numLevels; level++) {
          const chunkSize = Math.pow(2, level + 1); const levelMap = new Map();
          for (let x = 0; x < this.config.N; x += chunkSize) {
            for (let y = 0; y < this.config.N; y += chunkSize) {
              const biome = this.getBiomeForTile(x, y); levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
            }
          }
          this.state.chunkLevels.push(levelMap);
        }
      },

      worldToScreen(x, y) { 
        return [(x - y) * (this.config.tileW / 2), -(x + y) * (this.config.tileH / 2)]; 
      },

      screenToWorld(sx, sy) {
        const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
        const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
        if (tileW_half === 0 || tileH_half === 0) { return [0, 0]; }
        const lx = (sx - this.state.cam.x) / scale; const ly = (sy - this.state.cam.y) / scale;
        const u = lx / tileW_half; const v = -ly / tileH_half;
        return [Math.round((u + v) / 2), Math.round((v - u) / 2)];
      },

      getBuildingAt(x, y) { 
        return this.state.buildingMap.get(`${x},${y}`) || null; 
      },

      getBiomeForTile(x, y) {
        const { fertile, plains } = this.config.biomeRegions;
        if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
        if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
        return 'badlands';
      },

      getChunkLevelForZoom(pct) {
        if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100;
        const detailThreshold = this.state.currentTileDetailThreshold;
        if (pct > detailThreshold) return -1; if (pct > detailThreshold / 2) return 0;
        if (pct > detailThreshold / 5) return 1; if (pct > detailThreshold / 10) return 2;
        return 3;
      },

      clampCamera() {
        const s = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const canvasW = this.dom.canvas.width; const canvasH = this.dom.canvas.height;
        const N = this.config.N; const tileW = this.config.tileW; const tileH = this.config.tileH;
        const mapScreenW = (N - 1) * tileW * s;
        if (mapScreenW > canvasW) {
            const minCamX = canvasW - mapScreenW / 2; const maxCamX = mapScreenW / 2;
            this.state.cam.x = Math.max(minCamX, Math.min(maxCamX, this.state.cam.x));
        } else { this.state.cam.x = canvasW / 2; }
        const mapScreenH = (N - 1) * tileH * s;
        if (mapScreenH > canvasH) {
            const topOfMapY = mapScreenH; const bottomOfMapY = canvasH;
            this.state.cam.y = Math.max(bottomOfMapY, Math.min(topOfMapY, this.state.cam.y));
        } else {
            this.state.cam.y = canvasH / 2 + mapScreenH / 2;
        }
        if (isNaN(this.state.cam.x)) this.state.cam.x = canvasW / 2;
        if (isNaN(this.state.cam.y)) this.state.cam.y = canvasH / 2;
      },

      changeZoomBy(delta) {
        let currentPct = Math.round((this.state.cam.scale / this.config.baseScale) * 100);
        if (isNaN(currentPct)) { currentPct = Math.round((this.state.minFitScale / this.config.baseScale) * 100); }
        const targetPct = currentPct + delta;
        let targetScale = (targetPct / 100) * this.config.baseScale;
        const minScale = this.state.minFitScale;
        const maxScale = (this.config.maxPct / 100) * this.config.baseScale;
        targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
        if (!isNaN(targetScale)) { this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 150); }
      },

      animateZoom(targetScale, anchorX, anchorY, duration = 150) {
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
        const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const startX = this.state.cam.x; const startY = this.state.cam.y;
        const start = performance.now();
        if (startScale === 0) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
        const wx = (anchorX - startX) / startScale; const wy = (anchorY - startY) / startScale;
        if (isNaN(wx) || isNaN(wy)) { this.state.cam.scale = targetScale; this.clampCamera(); return; }
        const step = (now) => {
          const t = duration === 0 ? 1 : Math.min(1, (now - start) / duration);
          const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          this.state.cam.scale = startScale + (targetScale - startScale) * k;
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
          this.state.cam.x = anchorX - wx * this.state.cam.scale;
          this.state.cam.y = anchorY - wy * this.state.cam.scale;
          this.clampCamera();
          if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
          else { this.state.animationId = null; }
        };
        this.state.animationId = requestAnimationFrame(step);
      },

      animatePanZoom(targetScale, targetX, targetY, duration = 300) {
        if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); }
        const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const startX = this.state.cam.x; const startY = this.state.cam.y;
        const start = performance.now();
        const step = (now) => {
          const t = Math.min(1, (now - start) / duration);
          const k = t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
          this.state.cam.scale = startScale + (targetScale - startScale) * k;
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = startScale;
          this.state.cam.x = startX + (targetX - startX) * k;
          this.state.cam.y = startY + (targetY - startY) * k;
          this.clampCamera();
          if (t < 1) { this.state.animationId = requestAnimationFrame(step); } 
          else { this.state.animationId = null; }
        };
        this.state.animationId = requestAnimationFrame(step);
      },

      zoomToFit() {
        const targetScale = this.state.minFitScale;
        const targetCamX = this.dom.canvas.width / 2;
        const targetCamY = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * targetScale;
        this.animatePanZoom(targetScale, targetCamX, targetCamY, 200);
      },

      handleMinimapMouseDown(e) { 
        this.state.isMinimapDragging = true; 
        this.state.minimapClickStartPos = { x: e.clientX, y: e.clientY }; 
        this.state.startCamX = this.state.cam.x; 
        this.state.startCamY = this.state.cam.y; 
      },

      handleMinimapMouseMove(e) {
        if (!this.state.isMinimapDragging) return; if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
        const rect = this.dom.minimapCanvas.getBoundingClientRect(); const minimapCam = this.state.minimapCam;
        const clickScreenX = (e.clientX - rect.left); const clickScreenY = (e.clientY - rect.top);
        const lx = (clickScreenX - minimapCam.x) / minimapCam.scale; const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
        const tileW_half = this.config.tileW / 2; const tileH_half = this.config.tileH / 2;
        const u = lx / tileW_half; const v = -ly / tileH_half; const world_x = (u + v) / 2; const world_y = (v - u) / 2;
        const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
        this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale; this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
        this.clampCamera();
      },

      handleMinimapMouseUp(e) {
        if (!this.state.isMinimapDragging) return;
        this.state.isMinimapDragging = false;
        
        const dist = Math.hypot(e.clientX - this.state.minimapClickStartPos.x, e.clientY - this.state.minimapClickStartPos.y);
        if (dist < 5) {
          const rect = this.dom.minimapCanvas.getBoundingClientRect(); 
          const minimapCam = this.state.minimapCam;
          const clickScreenX = (e.clientX - rect.left); 
          const clickScreenY = (e.clientY - rect.top);
          
          const lx = (clickScreenX - minimapCam.x) / minimapCam.scale; 
          const ly = (clickScreenY - minimapCam.y) / minimapCam.scale;
          
          const tileW_half = this.config.tileW / 2; 
          const tileH_half = this.config.tileH / 2;
          const u = lx / tileW_half; 
          const v = -ly / tileH_half; 
          const world_x = (u + v) / 2; 
          const world_y = (v - u) / 2;
          
          const [targetScreenX, targetScreenY] = this.worldToScreen(world_x, world_y);
          
          this.state.cam.x = this.dom.canvas.width / 2 - targetScreenX * this.state.cam.scale; 
          this.state.cam.y = this.dom.canvas.height / 2 - targetScreenY * this.state.cam.scale;
          this.clampCamera();
        }
      },

      handleMouseDown(e) {
        if (e.button === 0) {
          this.state.clickStartX = e.clientX;
          this.state.clickStartY = e.clientY;
          this.state.lastX = e.clientX;
          this.state.lastY = e.clientY;

          if (!(this.state.isBuildMode && this.state.selectedBuildingType)) {
            this.state.dragging = true;
          }
        }
      },

      handleMouseMove(e) { 
        const [wx, wy] = this.screenToWorld(e.offsetX, e.offsetY);
        this.state.mouseWorldPos = {x: wx, y: wy};

        if (!this.state.dragging) return; 
        this.state.cam.x += e.clientX - this.state.lastX; 
        this.state.cam.y += e.clientY - this.state.lastY; 
        this.state.lastX = e.clientX; 
        this.state.lastY = e.clientY; 
        this.clampCamera(); 
      },

      handleCanvasClick(e) {
        const dist = Math.hypot(e.clientX - this.state.clickStartX, e.clientY - this.state.clickStartY);
        if (dist > 5) return; 

        const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);

        if (this.state.isBuildMode) {
            if (this.state.selectedBuildingType) {
                this.placeBuilding(this.state.selectedBuildingType, worldX, worldY);
            }
            return;
        }

        if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
          const building = this.getBuildingAtCoords(worldX, worldY);
          this.state.selection = building || { x: worldX, y: worldY };
          if (this.state.selection) this.state.selection.pingStart = performance.now();
          if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
          if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
        }
      },

      handleRightClick(e) {
          e.preventDefault();
          if (this.state.isBuildMode) {
              if (this.state.selectedBuildingType) {
                  this.state.selectedBuildingType = null;
                  this.dom.canvas.classList.remove('build-cursor');
                  this.renderBuildingPalette();
              } else {
                  const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
                  const building = this.getBuildingAtCoords(worldX, worldY);
                  if (building && building.allianceId) {
                      if(confirm(`Delete ${building.displayText}?`)) {
                          this.deleteBuildModeBuilding(building.id);
                      }
                  }
              }
          }
      },

      handleWheel(e) { 
        e.preventDefault(); 
        const factor = e.deltaY < 0 ? 1.2 : 0.8; 
        let targetScale = this.state.cam.scale * factor; 
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale)); 
        this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
      },

      handleDblClick(e) { 
        e.preventDefault(); 
        const factor = e.button === 2 ? 0.5 : 2.0; 
        let targetScale = this.state.cam.scale * factor; 
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale)); 
        this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
      },

      handleZoomSlider() {
        if (!this.dom.zoomSlider) return; const pct = Number(this.dom.zoomSlider.value);
        let targetScale = (pct / 100) * this.config.baseScale;
        targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
        this.animateZoom(targetScale, this.dom.canvas.width / 2, this.dom.canvas.height / 2, 0);
      },

      handleKeyDown(e) {
        if (e.target && e.target.tagName === 'INPUT') return;
        switch (e.key) {
          case '+': case '=': this.changeZoomBy(+5); break;
          case '-':           this.changeZoomBy(-5); break;
          case 'ArrowUp':     this.state.cam.y += this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowDown':   this.state.cam.y -= this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowLeft':   this.state.cam.x += this.config.tileW * 5; this.clampCamera(); break;
          case 'ArrowRight':  this.state.cam.x -= this.config.tileW * 5; this.clampCamera(); break;
          case 'Escape':
            if (this.state.isBuildMode && this.state.selectedBuildingType) {
                this.state.selectedBuildingType = null;
                this.dom.canvas.classList.remove('build-cursor');
                this.renderBuildingPalette();
            }
            break;
        }
      },

      handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
          this.state.touchMode = 'pan'; const t = e.touches[0]; this.state.lastX = t.clientX; this.state.lastY = t.clientY;
          this.state.clickStartX = t.clientX; this.state.clickStartY = t.clientY; this.state.touchStartTime = performance.now();
        } else if (e.touches.length === 2) {
          this.state.touchMode = 'pinch'; const [a, b] = e.touches;
          this.state.startDist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          this.state.startScale = this.state.cam.scale; this.state.pinchCenter = { x: (a.clientX + b.clientX) / 2, y: (a.clientY + b.clientY) / 2 };
          this.state.startCamX = this.state.cam.x; this.state.startCamY = this.state.cam.y;
        }
      },

      handleTouchMove(e) {
        e.preventDefault(); if (this.state.animationId) { cancelAnimationFrame(this.state.animationId); this.state.animationId = null; }
        if (this.state.touchMode === 'pan' && e.touches.length === 1) {
          const t = e.touches[0]; 
          this.state.cam.x += t.clientX - this.state.lastX; 
          this.state.cam.y += t.clientY - this.state.lastY;
          this.state.lastX = t.clientX; this.state.lastY = t.clientY; this.clampCamera();
        } else if (this.state.touchMode === 'pinch' && e.touches.length === 2) {
          const [a, b] = e.touches; const dist = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          if (this.state.startDist === 0) return; let newScale = this.state.startScale * (dist / this.state.startDist);
          this.state.cam.scale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, newScale));
          if (isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.startScale;
          const safeStartScale = (this.state.startScale === 0 || isNaN(this.state.startScale)) ? this.state.minFitScale : this.state.startScale;
          const wx = (this.state.pinchCenter.x - this.state.startCamX) / safeStartScale; const wy = (this.state.pinchCenter.y - this.state.startCamY) / safeStartScale;
          if (isNaN(wx) || isNaN(wy)) { this.state.cam.x = this.state.startCamX; this.state.cam.y = this.state.startCamY; } 
          else { this.state.cam.x = this.state.pinchCenter.x - wx * this.state.cam.scale; this.state.cam.y = this.state.pinchCenter.y - wy * this.state.cam.scale; }
          this.clampCamera();
        }
      },

      handleTouchEnd(e) {
        if (this.state.touchMode === 'pan' && e.changedTouches.length === 1) {
          const t = e.changedTouches[0]; const dist = Math.hypot(t.clientX - this.state.clickStartX, t.clientY - this.state.clickStartY);
          const duration = performance.now() - this.state.touchStartTime;
          if (duration < 200 && dist < 10) {
            const [worldX, worldY] = this.screenToWorld(t.clientX, t.clientY);
            
            if (this.state.isBuildMode && this.state.selectedBuildingType) {
                this.placeBuilding(this.state.selectedBuildingType, worldX, worldY);
                return;
            }

            if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
              const building = this.getBuildingAtCoords(worldX, worldY); 
              this.state.selection = building || { x: worldX, y: worldY };
              if (this.state.selection) this.state.selection.pingStart = performance.now();
              if (this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
              if (this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
            }
          }
        }
        if (e.touches.length < 2) this.state.touchMode = null;
      },

      resize() {
        this.dom.canvas.width = window.innerWidth; this.dom.canvas.height = window.innerHeight;
        if (this.dom.minimapCanvas && this.config.minimap) {
          const dpr = window.devicePixelRatio || 1;
          this.dom.minimapCanvas.width = this.config.minimap.width * dpr; this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
        }
        const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
        const mapTotalHeight = (this.config.N - 1) * this.config.tileH;
        const scaleX = this.dom.canvas.width / mapTotalWidth;
        const scaleY = this.dom.canvas.height / mapTotalHeight;
        this.state.minFitScale = Math.max(0.1, Math.min(scaleX, scaleY) * 0.95);
        if (isNaN(this.state.minFitScale)) { this.state.minFitScale = 0.1; }
        if (this.state.isInitialLoad) {
          this.state.isInitialLoad = false; this.zoomToFit();
        } else {
          this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
          if (isNaN(this.state.cam.scale)) { this.state.cam.scale = this.state.minFitScale; }
          this.clampCamera();
        }
      },

      doSearch() {
        if (!this.dom.inpX || !this.dom.inpY) return;
        this.goToBookmark(+this.dom.inpX.value, +this.dom.inpY.value);
      },

      drawIsometricMinimap(viewportCorners) {
        if (!this.dom.minimapCtx || !this.dom.minimapContainer.classList.contains('visible') || !this.config.minimap) return;
        const mmCtx = this.dom.minimapCtx; const { minimap, N, tileW, tileH, baseScale, maxPct } = this.config;
        const canvasWidth = this.dom.minimapCanvas.width; const canvasHeight = this.dom.minimapCanvas.height;
        mmCtx.save(); mmCtx.setTransform(1, 0, 0, 1, 0, 0); mmCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        mmCtx.fillStyle = minimap.bgColor; mmCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        const worldIsoWidth = N * tileW; const worldIsoHeight = N * tileH;
        const drawableWidth = canvasWidth - (minimap.padding * 2); const drawableHeight = canvasHeight - (minimap.padding * 2);
        const baseMinimapScale = Math.min(drawableWidth / worldIsoWidth, drawableHeight / worldIsoHeight);
        
        const mainMapCurrentScale = this.state.cam.scale; 
        const mainMapMaxScale = (maxPct / 100) * baseScale;
        const mainMapMinScale = this.state.minFitScale;

        let normalizedZoom = 0;
        if (mainMapMaxScale > mainMapMinScale) {
            normalizedZoom = Math.max(0, Math.min(1, (mainMapCurrentScale - mainMapMinScale) / (mainMapMaxScale - mainMapMinScale)));
        }
        
        // --- NEW: Use an even more aggressive easing function ---
        // An exponent of 0.1 makes the curve very steep at the start, for a near-instant lock-on effect.
        const easedNormalizedZoom = Math.pow(normalizedZoom, 0.1);

        const zoomFactor = minimap.zoomFactorMin + (minimap.zoomFactorMax - minimap.zoomFactorMin) * normalizedZoom;
        const finalMinimapScale = baseMinimapScale * zoomFactor;

        const mapVisualCenterX_iso = 0; const mapVisualCenterY_iso = -((N - 1) * tileH / 2);
        const [mainViewCenterX, mainViewCenterY] = this.screenToWorld(this.dom.canvas.width / 2, this.dom.canvas.height / 2);
        const [viewportCenterX_iso, viewportCenterY_iso] = this.worldToScreen(mainViewCenterX, mainViewCenterY);
        
        // Use the new, more aggressive eased value for panning
        const focalPointX = mapVisualCenterX_iso + (viewportCenterX_iso - mapVisualCenterX_iso) * easedNormalizedZoom; 
        const focalPointY = mapVisualCenterY_iso + (viewportCenterY_iso - mapVisualCenterY_iso) * easedNormalizedZoom;
        
        const translateX = (canvasWidth / 2) - (focalPointX * finalMinimapScale); 
        const translateY = (canvasHeight / 2) - (focalPointY * finalMinimapScale);
        this.state.minimapCam = { x: translateX, y: translateY, scale: finalMinimapScale };

        mmCtx.setTransform(finalMinimapScale, 0, 0, finalMinimapScale, translateX, translateY);
        const chunksToDraw = this.state.chunkLevels[3];
        chunksToDraw.forEach(chunk => { this.drawChunk(chunk, false, mmCtx); });
        (this.state.baseMap.defaultBuildings || []).forEach(b => {
            let buildingFillStyle = null;
            if (b.displayName === "King's Castle") buildingFillStyle = minimap.kingCastleColor;
            else if (b.displayName.startsWith("Fortress")) buildingFillStyle = minimap.fortressColor;
            else if (b.displayName.startsWith("Sanctuary")) buildingFillStyle = minimap.sanctuaryColor;
            else if (b.displayName.startsWith("Lv.1 Builder's Guild")) buildingFillStyle = minimap.buildersGuildOutpostColor;
            else if (b.displayName.startsWith("Lv.2 Builder's Guild")) buildingFillStyle = minimap.buildersGuildOutpostColor;
            else if (b.displayName.startsWith("Lv.3 Builder's Guild")) buildingFillStyle = minimap.buildersGuildOutpostColor;
            else if (b.displayName.startsWith("Lv.1 Forager Grove")) buildingFillStyle = minimap.foragerGroveOutpostColor;
            else if (b.displayName.startsWith("Lv.2 Forager Grove")) buildingFillStyle = minimap.foragerGroveOutpostColor;
            else if (b.displayName.startsWith("Lv.3 Forager Grove")) buildingFillStyle = minimap.foragerGroveOutpostColor;
            else if (b.displayName.startsWith("Lv.1 Harvest Altar")) buildingFillStyle = minimap.harvestAltarOutpostColor;
            else if (b.displayName.startsWith("Lv.2 Harvest Altar")) buildingFillStyle = minimap.harvestAltarOutpostColor;
            else if (b.displayName.startsWith("Lv.3 Harvest Altar")) buildingFillStyle = minimap.harvestAltarOutpostColor;
            else if (b.displayName.startsWith("Lv.1 Scholar's Tower")) buildingFillStyle = minimap.scholarsTowerOutpostColor;
            else if (b.displayName.startsWith("Lv.2 Scholar's Tower")) buildingFillStyle = minimap.scholarsTowerOutpostColor;
            else if (b.displayName.startsWith("Lv.3 Scholar's Tower")) buildingFillStyle = minimap.scholarsTowerOutpostColor;
            else if (b.displayName.startsWith("Lv.2 Arsenal")) buildingFillStyle = minimap.arsenalOutpostColor;
            else if (b.displayName.startsWith("Lv.3 Arsenal")) buildingFillStyle = minimap.arsenalOutpostColor;
            else if (b.displayName.startsWith("Lv.4 Arsenal")) buildingFillStyle = minimap.arsenalOutpostColor;
            else if (b.displayName.startsWith("Lv.2 Armory")) buildingFillStyle = minimap.armoryOutpostColor;
            else if (b.displayName.startsWith("Lv.3 Armory")) buildingFillStyle = minimap.armoryOutpostColor;
            else if (b.displayName.startsWith("Lv.4 Armory")) buildingFillStyle = minimap.armoryOutpostColor;
            if (buildingFillStyle) { const originalFill = b.fillColor; b.fillColor = buildingFillStyle; this.drawBuildingFootprint(b, null, false, mmCtx); b.fillColor = originalFill; }
        });
        if (viewportCorners) {
            const p1 = this.worldToScreen(viewportCorners.tl.x, viewportCorners.tl.y); const p2 = this.worldToScreen(viewportCorners.tr.x, viewportCorners.tr.y);
            const p3 = this.worldToScreen(viewportCorners.br.x, viewportCorners.br.y); const p4 = this.worldToScreen(viewportCorners.bl.x, viewportCorners.bl.y);
            mmCtx.fillStyle = minimap.viewportFillColor; mmCtx.strokeStyle = minimap.viewportBorderColor;
            mmCtx.lineWidth = 2 / finalMinimapScale; mmCtx.beginPath();
            mmCtx.moveTo(p1[0], p1[1]); mmCtx.lineTo(p2[0], p2[1]); mmCtx.lineTo(p3[0], p3[1]); mmCtx.lineTo(p4[0], p4[1]);
            mmCtx.closePath(); mmCtx.fill(); mmCtx.stroke();
        }
        mmCtx.restore();
      },

      drawTile(x, y, drawBorder = true) {
        this.state.tileCount++; const [sx, sy] = this.worldToScreen(x, y); const { config } = this; const ctx = this.dom.ctx;
        ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy);
        ctx.closePath(); ctx.fillStyle = config.biomeColors[this.getBiomeForTile(x, y)]; ctx.fill();
        if (drawBorder) ctx.stroke(); const building = this.getBuildingAt(x, y);
        if (building && building.hideCoordinates) return;
        const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
        const pct = Math.round((currentCamScale / config.baseScale) * 100);
        const showCoords = this.dom.coordsToggle ? this.dom.coordsToggle.checked : false;
        const showThreshold = showCoords ? 80 : 200;
        if (pct <= showThreshold) return;
        const text = `${x}, ${y}`; let optimalFontSize = Math.min(config.tileH * 0.8 * 0.5, (config.tileW * 0.8 / (text.length || 1)) * 1.8) * 0.7;
        if ((optimalFontSize * currentCamScale) < 5) return;
        ctx.fillStyle = config.textColor; ctx.font = `${optimalFontSize}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, sx, sy);
      },

      drawChunk(chunk, drawBorder = true, overrideCtx = null) {
        this.state.tileCount++; const ctx = overrideCtx || this.dom.ctx;
        const { x, y, size, biome } = chunk; const { config } = this;
        const currentCamScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
        const inflation = drawBorder || currentCamScale === 0 ? 0 : (1 / currentCamScale);
        const x0 = x; const y0 = y; const w = size; const h = size;
        const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
        const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
        const p_bottom = { x: sbx, y: sby + config.tileH / 2 + inflation }; const p_right = { x: srx + config.tileW / 2 + inflation, y: sry };
        const p_top = { x: stx, y: sty - config.tileH / 2 - inflation }; const p_left = { x: slx - config.tileW / 2 - inflation, y: sly };
        ctx.beginPath(); ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath();
        ctx.fillStyle = config.biomeColors[biome]; ctx.fill(); if (drawBorder) ctx.stroke();
      },

      drawBuildingFootprint(b, highlightStyle = null, drawBorder = true, overrideCtx = null) {
          const { config, state } = this; const ctx = overrideCtx || this.dom.ctx;
          
          let buildingDisplayName = b.displayName;
          let isBuildModeBuilding = !!b.allianceId;
          
          if (isBuildModeBuilding) {
              const alliance = state.alliances.find(a => a.id === b.allianceId);
              if (!alliance) return;
              b.fillColor = alliance.color;
              b.borderColor = this.darkenColor(alliance.color, 40);
              buildingDisplayName = b.displayText;
          }

          const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
          const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
          const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
          const [sbx, sby] = this.worldToScreen(x0, y0); const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
          const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1); const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
          const p_bottom = { x: sbx, y: sby + config.tileH / 2 }; const p_right = { x: srx + config.tileW / 2, y: sry };
          const p_top = { x: stx, y: sty - config.tileH / 2 }; const p_left = { x: slx - config.tileW / 2, y: sly };
          ctx.beginPath(); ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x, p_right.y);
          ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath();
          
          ctx.fillStyle = isBuildModeBuilding ? this.hexToRgba(fill, 0.4) : fill;
          ctx.fill();

          if(drawBorder) {
              ctx.strokeStyle = border; const currentScale = overrideCtx ? this.state.minimapCam.scale : this.state.cam.scale;
              ctx.lineWidth = (highlightStyle ? config.strokeW * 2 : config.strokeW) / (overrideCtx ? 1 : currentScale);
              ctx.stroke();
          }
          if (overrideCtx || highlightStyle) return;
          const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
          const pct = Math.round((currentCamScale / config.baseScale) * 100);
          if ((isBuildModeBuilding && pct > 30) || (!isBuildModeBuilding && currentCamScale > 0.4 && buildingDisplayName)) {
            const availableWidth = (p_right.x - p_left.x) * 0.8; const availableHeight = p_bottom.y - p_top.y;
            if (availableWidth < 1 || availableHeight < 1) return; 
            const isSmallBuilding = b.w <= 1 && b.h <= 1;
            
            ctx.font = `bold 100px sans-serif`; const textMetrics = ctx.measureText(buildingDisplayName);
            const displayNameWidth = textMetrics.width || 1; 
            const fontSizeBasedOnWidth = (availableWidth / displayNameWidth) * 100;

            const words = buildingDisplayName.split(' ');
            let lineCount = words.length;
            if(b.displayCoordinates) lineCount += 1;
            const fontSizeBasedOnHeight = (availableHeight / lineCount) * 0.9;
            
            let optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);
            if(isSmallBuilding && optimalFontSize * currentCamScale < 10) optimalFontSize = 10 / currentCamScale;

            if (optimalFontSize * currentCamScale < 7 && !isSmallBuilding) return;

            const centerX = (p_left.x + p_right.x) / 2;
            const unadjustedCenterY = (p_top.y + p_bottom.y) / 2;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lineHeight = optimalFontSize * 1.1;
            let totalBlockHeight = words.length * lineHeight;
            if (b.displayCoordinates) {
                totalBlockHeight += lineHeight * 0.8; 
            }
            
            let currentY = unadjustedCenterY - (totalBlockHeight / 2);

            ctx.fillStyle = config.textColor;
            ctx.font = `bold ${optimalFontSize}px sans-serif`;
            words.forEach(word => {
                ctx.fillText(word, centerX, currentY + lineHeight / 2);
                currentY += lineHeight;
            });

            if (b.displayCoordinates) {
              const coordFontSize = optimalFontSize * 0.7;
              ctx.font = `${coordFontSize}px sans-serif`;
              ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, currentY + (lineHeight * 0.8) / 2);
            }
          }
      },
      
      drawBuildModeOverlays(viewBounds) {
          const showOverlays = this.state.isBuildMode || (this.dom.alwaysShowClaimedToggle && this.dom.alwaysShowClaimedToggle.checked);
          if (!showOverlays) return;
          
          const ctx = this.dom.ctx;
          
          // --- 1. Draw permanently claimed territory ---
          for (const [allianceId, territorySet] of this.state.claimedTerritory.entries()) {
              const alliance = this.state.alliances.find(a => a.id === allianceId);
              if (alliance) {
                  // Pass 1: Fill the entire area
                  ctx.fillStyle = this.hexToRgba(alliance.color, 0.15);
                  territorySet.forEach(coordStr => {
                      const [x, y] = coordStr.split(',').map(Number);
                      if (x >= viewBounds.minX && x <= viewBounds.maxX && y >= viewBounds.minY && y <= viewBounds.maxY) {
                          const [sx, sy] = this.worldToScreen(x, y);
                          ctx.beginPath();
                          ctx.moveTo(sx, sy - this.config.tileH / 2);
                          ctx.lineTo(sx + this.config.tileW / 2, sy);
                          ctx.lineTo(sx, sy + this.config.tileH / 2);
                          ctx.lineTo(sx - this.config.tileW / 2, sy);
                          ctx.closePath();
                          ctx.fill();
                      }
                  });

                  // Pass 2: Draw the external border
                  ctx.strokeStyle = this.hexToRgba(this.darkenColor(alliance.color, 40), 0.9);
                  ctx.lineWidth = this.config.strokeW * 1.5;
                  territorySet.forEach(coordStr => {
                      const [x, y] = coordStr.split(',').map(Number);
                      if (x >= viewBounds.minX && x <= viewBounds.maxX && y >= viewBounds.minY && y <= viewBounds.maxY) {
                          const [sx, sy] = this.worldToScreen(x, y);
                          const T = { x: sx, y: sy - this.config.tileH / 2 };
                          const R = { x: sx + this.config.tileW / 2, y: sy };
                          const B = { x: sx, y: sy + this.config.tileH / 2 };
                          const L = { x: sx - this.config.tileW / 2, y: sy };

                          // Draw border only if neighbor is missing
                          if (!territorySet.has(`${x},${y+1}`)) { ctx.beginPath(); ctx.moveTo(L.x, L.y); ctx.lineTo(T.x, T.y); ctx.stroke(); }
                          if (!territorySet.has(`${x+1},${y}`)) { ctx.beginPath(); ctx.moveTo(T.x, T.y); ctx.lineTo(R.x, R.y); ctx.stroke(); }
                          if (!territorySet.has(`${x},${y-1}`)) { ctx.beginPath(); ctx.moveTo(R.x, R.y); ctx.lineTo(B.x, B.y); ctx.stroke(); }
                          if (!territorySet.has(`${x-1},${y}`)) { ctx.beginPath(); ctx.moveTo(B.x, B.y); ctx.lineTo(L.x, L.y); ctx.stroke(); }
                      }
                  });
              }
          }

          // --- 2. Draw building placement ghost and its coverage preview ---
          if (this.state.isBuildMode && this.state.selectedBuildingType) {
              const def = this.BUILDING_CATALOG[this.state.selectedBuildingType];
              const { canPlace } = this.checkPlacementValidity(this.state.selectedBuildingType, this.state.mouseWorldPos.x, this.state.mouseWorldPos.y);
              
              if (def) {
                  // Draw the coverage preview first
                  if (def.coverage > 0) {
                      const alliance = this.state.alliances.find(a => a.id === this.state.activeAllianceId);
                      if (alliance) {
                          const previewTerritory = new Set();
                          const radius = Math.floor(def.coverage / 2);
                          const centerX = this.state.mouseWorldPos.x + Math.floor(def.w / 2);
                          const centerY = this.state.mouseWorldPos.y + Math.floor(def.h / 2);
                          for (let dx = -radius; dx <= radius; dx++) {
                              for (let dy = -radius; dy <= radius; dy++) {
                                  previewTerritory.add(`${centerX + dx},${centerY + dy}`);
                              }
                          }

                          // Pass 1: Fill preview area
                          ctx.fillStyle = this.hexToRgba(alliance.color, 0.25);
                          previewTerritory.forEach(coordStr => {
                              const [x, y] = coordStr.split(',').map(Number);
                              if (x >= viewBounds.minX && x <= viewBounds.maxX && y >= viewBounds.minY && y <= viewBounds.maxY) {
                                  const [sx, sy] = this.worldToScreen(x, y);
                                  ctx.beginPath(); ctx.moveTo(sx, sy-this.config.tileH/2); ctx.lineTo(sx+this.config.tileW/2, sy); ctx.lineTo(sx, sy+this.config.tileH/2); ctx.lineTo(sx-this.config.tileW/2, sy); ctx.closePath();
                                  ctx.fill();
                              }
                          });

                          // Pass 2: Draw preview border
                          ctx.strokeStyle = this.hexToRgba(this.darkenColor(alliance.color, 40), 0.9);
                          ctx.lineWidth = this.config.strokeW * 1.5;
                           previewTerritory.forEach(coordStr => {
                               const [x, y] = coordStr.split(',').map(Number);
                               if (x >= viewBounds.minX && x <= viewBounds.maxX && y >= viewBounds.minY && y <= viewBounds.maxY) {
                                   const [sx, sy] = this.worldToScreen(x, y);
                                   const T = { x: sx, y: sy - this.config.tileH / 2 }, R = { x: sx + this.config.tileW / 2, y: sy }, B = { x: sx, y: sy + this.config.tileH / 2 }, L = { x: sx - this.config.tileW / 2, y: sy };
                                   if (!previewTerritory.has(`${x},${y+1}`)) { ctx.beginPath(); ctx.moveTo(L.x, L.y); ctx.lineTo(T.x, T.y); ctx.stroke(); }
                                   if (!previewTerritory.has(`${x+1},${y}`)) { ctx.beginPath(); ctx.moveTo(T.x, T.y); ctx.lineTo(R.x, R.y); ctx.stroke(); }
                                   if (!previewTerritory.has(`${x},${y-1}`)) { ctx.beginPath(); ctx.moveTo(R.x, R.y); ctx.lineTo(B.x, B.y); ctx.stroke(); }
                                   if (!previewTerritory.has(`${x-1},${y}`)) { ctx.beginPath(); ctx.moveTo(B.x, B.y); ctx.lineTo(L.x, L.y); ctx.stroke(); }
                               }
                           });
                      }
                  }
                  
                  // Draw the building ghost on top
                  const ghostBuilding = {
                      x: this.state.mouseWorldPos.x, y: this.state.mouseWorldPos.y,
                      w: def.w, h: def.h,
                      fillColor: canPlace ? '#28a745' : '#dc3545',
                      borderColor: canPlace ? this.darkenColor('#28a745', 40) : this.darkenColor('#dc3545', 40)
                  };
                  this.drawBuildingFootprint(ghostBuilding, null, true);
              }
          }
          // Reset line width for other drawing operations
          ctx.lineWidth = this.config.strokeW;
      },

      mainLoop(now) {
        const { dom, state, config } = this; const ctx = dom.ctx;
        try {
          ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
          const [centerX, centerY] = this.screenToWorld(dom.canvas.width / 2, dom.canvas.height / 2);
          if (dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
          const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
          const pct = Math.round((currentCamScale / config.baseScale) * 100);
          if (dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
          if (dom.zoomSlider) {
              const minScalePct = Math.round((state.minFitScale / config.baseScale) * 100);
              const maxScalePct = Math.round((config.maxPct / 100 * config.baseScale / config.baseScale) * 100);
              dom.zoomSlider.min = minScalePct; dom.zoomSlider.max = maxScalePct;
              if (document.activeElement !== dom.zoomSlider) dom.zoomSlider.value = pct;
          }
          state.tileCount = 0; ctx.save();
          ctx.setTransform(currentCamScale, 0, 0, currentCamScale, state.cam.x, state.cam.y);
          ctx.strokeStyle = config.borderColor; ctx.lineWidth = config.strokeW;
          const [tl_x, tl_y] = this.screenToWorld(0, 0); const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
          const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height); const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
          const viewBounds = {
            minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2, maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
            minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2, maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
          };
          const viewportCorners = { tl: { x: tl_x, y: tl_y }, tr: { x: tr_x, y: tr_y }, bl: { x: bl_x, y: bl_y }, br: { x: br_x, y: br_y } };
          if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
            ctx.restore(); this.drawIsometricMinimap(null); requestAnimationFrame(this.mainLoop.bind(this)); return;
          }
          const chunkLevel = this.getChunkLevelForZoom(pct);
          const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
          const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
          const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;

          // --- Drawing Base Layer ---
          if (chunkLevel === -1) {
            const shouldDrawBorders = showGrid && pct > 50; const minSum = Math.floor(viewBounds.minX + viewBounds.minY); const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);
            for (let sum = minSum; sum <= maxSum; sum++) {
              const startXCoord = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY))); const endXCoord = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));
              for (let x = startXCoord; x <= endXCoord; x++) { const y = sum - x; if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue; if (!this.getBuildingAtCoords(x, y)) this.drawTile(x, y, shouldDrawBorders); }
            }
            state.allBuildings.filter(b => (!b.isRss || showRss) && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)).forEach(b => this.drawBuildingFootprint(b, null, shouldDrawBorders));
            ctx.fillStyle = '#444';
            (state.baseMap.unoccupiableTiles || []).forEach(([x, y]) => { if (this.getBuildingAtCoords(x, y)) return; if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return; const [sx, sy] = this.worldToScreen(x, y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.fill(); });
          } else {
            if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
              const chunksToDraw = state.chunkLevels[chunkLevel]; const chunkSize = Math.pow(2, chunkLevel + 1);
              const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize; const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
              const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize; const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
              for (let x = startChunkX; x <= endChunkX; x += chunkSize) { for (let y = startChunkY; y <= endChunkY; y += chunkSize) { const chunk = chunksToDraw.get(`${x},${y}`); if (chunk) this.drawChunk(chunk, false); } }
            }
            state.allBuildings.filter(b => !b.isRss && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)).forEach(b => this.drawBuildingFootprint(b, null, false));
            if (showRss && alwaysShowRss) {
                state.allBuildings.filter(b => b.isRss && !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)).forEach(b => this.drawBuildingFootprint(b, null, false));
            }
            if (chunkLevel < 2) {
              ctx.fillStyle = '#444';
              (state.baseMap.unoccupiableTiles || []).forEach(([x, y]) => { if (this.getBuildingAtCoords(x, y)) return; if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return; const [sx, sy] = this.worldToScreen(x, y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.fill(); });
            }
          }
          
          // --- Draw Build Mode Content ---
          this.drawBuildModeOverlays(viewBounds); // This now handles claimed area toggle
          state.buildModeBuildings
            .filter(b => !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
            .forEach(b => this.drawBuildingFootprint(b, null, true));


          // --- Draw Selection ---
          if (state.selection && !state.isBuildMode) {
            let highlightColor = config.selectionColor;
            if (state.selection.pingStart && now - state.selection.pingStart < config.pingDuration) { if (Math.floor((now - state.selection.pingStart) / 100) % 2 === 0) { highlightColor = config.pingColor; } }
            if (state.selection.w) { this.drawBuildingFootprint(state.selection, highlightColor, true); } 
            else { const [sx, sy] = this.worldToScreen(state.selection.x, state.selection.y); ctx.beginPath(); ctx.moveTo(sx, sy - config.tileH / 2); ctx.lineTo(sx + config.tileW / 2, sy); ctx.lineTo(sx, sy + config.tileH / 2); ctx.lineTo(sx - config.tileW / 2, sy); ctx.closePath(); ctx.strokeStyle = highlightColor; ctx.lineWidth = config.strokeW * 1.5; ctx.stroke(); }
          }
          ctx.restore();
          this.drawIsometricMinimap(viewportCorners);
          const dt = now - state.lastFrame; state.lastFrame = now;
          if (dt > 0) { state.lastFPS = Math.round(1000 / dt); }
          state.lastTiles = state.tileCount;
          if (now - state.statsUpdateTime > 500) {
            if (dom.statsFPSEl) dom.statsFPSEl.textContent = `FPS:   ${state.lastFPS}`;
            if (dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
            state.statsUpdateTime = now;
          }
        } catch (error) { console.error("Error in mainLoop:", error); }
        requestAnimationFrame(this.mainLoop.bind(this));
      }

    };
    KingshotPlanner.init();
  </script>
</body>
</html>