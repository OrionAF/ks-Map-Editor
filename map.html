<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
<style>
    body {
      margin:0; background:#111; overflow:hidden;
      -webkit-user-select:none; user-select:none;
    }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }

    /* --- NEW: Search Controls (Left side) --- */
    #searchControls {
      /* order: 0; /* Place it at the top of zoomControlsContainer if it's moved inside */
      background: rgba(0,0,0,0.6);
      padding: 6px;
      border-radius: 4px;
      margin-bottom: 10px; /* Space between search and zoom slider */
      width: 200px; /* Match width of settings panel for consistency */
      box-sizing: border-box;
    }
    #searchControls h4 {
        margin: 0 0 4px;
        font-size: 13px;
        color: #aaa;
        text-transform: uppercase;
        text-align: left;
    }
    #searchControls > div {
        text-align: left;
    }
    #searchControls input { width:60px; }
    #searchControls button {
      margin:2px 0 2px 4px; /* Adjusted margin */
      -webkit-user-select:none; user-select:none;
    }

    /* --- MODIFIED: Settings Panel (Top Right) --- */
    #settingsContainer { /* New container for settings button and panel */
      position:absolute; top:10px; right:10px; z-index:10;
      width: 210px; 
      text-align: right;
    }
    #settingsBtn {
      margin-bottom: 5px; /* Space between button and panel */
      padding: 6px 10px;
    }
    #settingsPanel { /* Formerly #searchBox */
      color:#fff; font-family:sans-serif;
      background:rgba(0,0,0,0.6); padding:8px; border-radius:4px;
      max-height: 0; /* Collapsed by default */
      overflow: hidden;
      transition: max-height 0.3s ease-out;
      text-align: left; /* Content within panel is left-aligned */
    }
    #settingsPanel.open {
      max-height: 500px; /* Adjust as needed to fit all content */
    }
    #settingsPanel input[type="checkbox"], 
    #settingsPanel select { 
      vertical-align: middle; 
    }
    #settingsPanel > div { margin-top: 4px; text-align: left; }
    #settingsPanel > hr {
        border: none;
        border-top: 1px solid #444;
        margin: 8px 0;
    }
    #settingsPanel h4 {
        margin: 6px 0 2px;
        font-size: 13px;
        color: #aaa;
        text-transform: uppercase;
        text-align: left;
    }
    
    /* Center Tile Display - MOVED to bottom-center */
    #centerTile {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      color:#fff; font-family:sans-serif;
      font-size:14px;
      -webkit-user-select:none; user-select:none;
      z-index: 10;
    }

    /* Coords Toggle Label Style */
    label.coords-label {
        font-size: 13px;
        vertical-align: middle;
        user-select: none;
    }

    /* Info & Stats panels (remain mostly the same, but now inside #settingsPanel) */
    #infoBtn, #statsBtn {
      margin-top:6px; -webkit-user-select:none; user-select:none;
    }
    #infoPanel, #statsPanel {
      max-height:0; overflow:hidden;
      transition:max-height 0.3s ease;
      margin-top:6px;
      background:rgba(58,55,55,0.85);
      padding:0 6px; border-radius:4px;
      font-size:13px; color:#ddd;
      text-align: left;
    }
    #infoPanel.open { max-height:160px; } 
    #statsPanel.open { max-height:120px; }
    #infoPanel h4 { margin:6px 0 4px; color:#fff; text-transform: none; }
    #infoPanel ul { padding-left:16px; margin:0 }
    #infoPanel li { margin-bottom:4px; }
    #statsPanel div { margin:4px 0; color:#fff; }


    /* --- STYLES for Vertical Zoom Controls (LEFT) --- */
    #zoomControlsContainer {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 10px; /* Reduced padding slightly */
      border-radius: 4px;
      z-index: 10;
      color: #fff;
      font-family: sans-serif;
    }
    
    #zoomControlsContainer #presetButtons {
      display: flex;
      flex-direction: column;
      gap: 5px;
      order: 4; /* Search will be order 0 */
    }

    #zoomControlsContainer button {
      -webkit-user-select:none; user-select:none;
      margin: 0;
      width: 60px;
    }

    #settingsPanel select { /* Ensure select within settings panel is styled */
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 2px;
      padding: 2px;
      width: 100%; 
    }

    #zoomControlsContainer #zoomInc { order: 2; } /* Adjusted order */
    #zoomControlsContainer #sliderWrapper { order: 3; position: relative; } /* Adjusted order */
    #zoomControlsContainer #zoomDec { order: 4; } /* Adjusted order */
    #zoomControlsContainer #zoomLevel { order: 5; font-size: 14px; margin-top: 5px; } /* Adjusted order */
    #searchControls { order: 1; } /* Search controls at the top of this left panel */


    #zoomSlider {
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr; 
      height: 55vh; /* Adjusted height slightly */
      max-height: 400px; /* Adjusted max-height */
      width: auto;
      margin: 0;
    }

    #floatingZoomLabel {
        position: absolute;
        display: none;
        left: 25px;
        background-color: #0b508f;
        color: white;
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 13px;
        pointer-events: none;
        transform: translateY(-50%);
    }

    /* --- STYLES for Version Display & Patch Notes --- */
    #versionDisplay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: sans-serif;
        font-size: 12px;
        user-select: none;
        z-index: 10;
    }

    #modalOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
    }

    #patchNotesModal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        background: #2c2c2c;
        color: #eee;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    .patch-notes-header {
        padding: 15px;
        border-bottom: 1px solid #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .patch-notes-header h3 { margin: 0; }
    .patch-notes-header .close-btn {
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
    }
    .patch-notes-body {
        padding: 15px;
        max-height: 60vh;
        overflow-y: auto;
    }
    .patch-notes-body ul {
        padding-left: 20px;
        margin: 0;
    }
    .patch-notes-body li { margin-bottom: 8px; }
    .patch-notes-footer {
        padding: 10px 15px;
        border-top: 1px solid #444;
        background: #333;
        border-radius: 0 0 8px 8px;
    }
    .patch-notes-footer label { user-select: none; font-size: 14px; }

    /* --- NEW: Minimap Styles --- */
    #minimapContainer {
        position: absolute;
        top: 50px; /* Below settings button, adjust as needed */
        right: 10px;
        z-index: 9; /* Below settings panel if it overlaps */
    }
    #minimapCanvas {
        width: 200px; /* Desired display width */
        height: 150px; /* Desired display height */
        border: 1px solid #555;
        background-color: rgba(0,0,0,0.5); /* Placeholder background */
    }

  </style>
</head>
<body>
  <!-- Settings Container (Top Right) -->
  <div id="settingsContainer">
    <button id="settingsBtn">‚öôÔ∏è Settings</button>
    <div id="settingsPanel"> <!-- Formerly #searchBox -->
      <h4>Display</h4>
      <div>
        <input type="checkbox" id="gridlinesToggle">
        <label for="gridlinesToggle" class="coords-label">Show Gridlines</label>
      </div>
      <div>
        <input type="checkbox" id="coordsToggle">
        <label for="coordsToggle" class="coords-label">Show Coords >80%</label>
      </div>
      <div>
        <input type="checkbox" id="allianceRssToggle">
        <label for="allianceRssToggle" class="coords-label">Show Alliance RSS</label>
      </div>
      <div>
          <input type="checkbox" id="allianceRssAlwaysVisibleToggle">
          <label for="allianceRssAlwaysVisibleToggle" class="coords-label">Always Show RSS</label>
      </div>
      <hr>
      <h4>Performance</h4>
      <div>
          <label for="tileDetailSelect" class="coords-label">Tile Detail:</label>
          <select id="tileDetailSelect">
              <option value="25">Low (Merge Early)</option>
              <option value="50">Normal (Balanced)</option>
              <option value="80">High (Merge Late)</option>
          </select>
      </div>
      <hr>
      <div>
        <button id="infoBtn" title="Show controls">‚ÑπÔ∏è</button>
        <button id="statsBtn" title="Toggle stats">üìä</button> <!-- Changed icon for stats -->
      </div>
      <div id="infoPanel">
        <h4>Controls</h4>
        <ul>
          <li><strong>Pan</strong>: drag / one-finger touch</li>
          <li><strong>Zoom</strong>: wheel, slider, +/‚Äì, q/e, dblclick</li>
          <li><strong>Pinch</strong>: two-finger touch</li>
          <li><strong>Keyboard</strong>: arrows to pan</li>
        </ul>
        <button id="patchNotesBtn">Patch Notes</button>
      </div>
      <div id="statsPanel">
        <div id="statsFPS">FPS: ‚Äì</div>
        <div id="statsTiles">Tiles: ‚Äì</div>
      </div>
    </div>
  </div>

  <!-- Vertically oriented zoom controls (LEFT) -->
  <div id="zoomControlsContainer">
    <!-- Search Controls (Moved to Left) -->
    <div id="searchControls">
        <h4>Go To</h4>
        <div>
            X: <input id="inpX" type="number" min="0" max="1199" value="0">
            Y: <input id="inpY" type="number" min="0" max="1199" value="0">
            <button id="btnGo">Go</button>
        </div>
    </div>
    <button id="zoomInc">+</button>
    <div id="sliderWrapper">
        <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
        <div id="floatingZoomLabel"></div>
    </div>
    <button id="zoomDec">‚àí</button>
    <div id="presetButtons">
        <button data-zoom="Fit">Fit</button>
        <button data-zoom="50">50%</button>
        <button data-zoom="75">75%</button>
        <button data-zoom="100">100%</button>
    </div>
    <div id="zoomLevel">Zoom: 100%</div>
  </div>
  
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>

  <!-- Minimap Container (Top Right) -->
  <div id="minimapContainer">
      <canvas id="minimapCanvas"></canvas>
  </div>
  
  <!-- Patch Notes Modal -->
  <div id="modalOverlay"></div>
  <div id="patchNotesModal">
      <div class="patch-notes-header">
          <h3>What's New</h3>
          <button id="closePatchNotesBtn" class="close-btn">√ó</button>
      </div>
      <div class="patch-notes-body" id="patchNotesBody">
          <!-- Content will be injected by JS -->
      </div>
      <div class="patch-notes-footer"> <!-- Corrected class name -->
          <input type="checkbox" id="hidePatchNotesCheckbox">
          <label for="hidePatchNotesCheckbox">Do not show this again until the next update.</label>
      </div>
  </div>

  <canvas id="map"></canvas>

<script>
const KingshotPlanner = {
  // ‚Äî‚Äî CONFIGURATION ‚Äî‚Äî
  config: {
    CURRENT_VERSION: '0.2.7.0', // Version bump for minimap UI
    N: 1200,
    tileW: 10, tileH: 10,
    strokeW: 0.3, 
    borderColor: '#000', 
    textColor: '#fff',
    maxPct: 1000,
    selectionColor: '#ff0',
    pingColor: '#fff',
    pingDuration: 500, 
    baseScale: 5,
    biomeColors: {
      fertile:  'rgb(109, 159, 62)',
      plains:   'rgb(158, 180, 103)',
      badlands: 'rgb(191, 208, 152)'
    },
    biomeRegions: {
        fertile:  { x1: 480, y1: 480, x2: 719, y2: 719 },
        plains:   { x1: 320, y1: 320, x2: 879, y2: 879 },
        badlands: { x1: 0,   y1: 0,   x2: 1199,y2: 1199}
    },
    ALLIANCE_RSS_STYLES: {
      wood:  { displayName: 'Wood',  fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
      food:  { displayName: 'Food',  fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
      stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
      iron:  { displayName: 'Iron',  fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
    },
    minimap: { // Configuration for the minimap
        width: 200, // Display width (CSS)
        height: 150, // Display height (CSS)
        // internalWidth/Height will be set in init based on canvas element
        padding: 5, 
        bgColor: 'rgba(40,40,40,0.8)',
        viewportFillColor: 'rgba(255,255,255,0.2)',
        viewportBorderColor: 'rgba(255,255,255,0.7)',
        buildingColor: 'rgba(200,200,200,0.7)', // Generic color for buildings on minimap
        kingCastleColor: 'rgba(255,215,0,0.8)'
    }
  },

  // ‚Äî‚Äî APPLICATION STATE ‚Äî‚Äî
  state: {
    baseMap: { unoccupiableTiles:[], defaultBuildings:[] },
    patchNotes: {},
    allBuildings: [],
    buildingMap: new Map(),
    chunkLevels: [],
    userBuildings: [],
    cam: { x:0, y:0, scale:1 },
    lastFrame: 0,
    tileCount: 0,
    lastFPS: 0,
    lastTiles: 0,
    selection: null, 
    minFitScale: 0.001, 
    isInitialLoad: true,
    touchStartTime: 0,
    dragging: false, 
    lastX: 0, lastY: 0,
    clickStartX: 0, clickStartY: 0,
    touchMode: null,
    startDist: 0, startScale: 1, pinchCenter: null,
    startCamX: 0, startCamY: 0,
    hideLabelTimeout: null,
    statsUpdateTime: 0, 
    currentTileDetailThreshold: 50, 
    minimapActualScale: 0.1, // Will be calculated
    animationId: null 
  },

  // ‚Äî‚Äî DOM REFERENCES ‚Äî‚Äî
  dom: {
    canvas: null, ctx: null, inpX: null, inpY: null, btnGo: null,
    zoomLevelEl: null, zoomDecBtn: null, zoomIncBtn: null, zoomSlider: null,
    presetBtns: null, centerTileEl: null, infoBtn: null, infoPanel: null,
    statsBtn: null, statsPanel: null, statsFPSEl: null, statsTilesEl: null,
    coordsToggle: null, floatingZoomLabel: null, versionDisplay: null,
    patchNotesBtn: null, modalOverlay: null, patchNotesModal: null,
    patchNotesBody: null, closePatchNotesBtn: null, hidePatchNotesCheckbox: null,
    tileDetailSelect: null, gridlinesToggle: null, allianceRssToggle: null,
    allianceRssAlwaysVisibleToggle: null,
    settingsBtn: null, settingsPanel: null, // New for settings
    minimapCanvas: null, minimapCtx: null // New for minimap
  },

  // ‚Äî‚Äî INITIALIZATION ‚Äî‚Äî
  init() {
    const self = this; 

    this.dom.canvas = document.getElementById('map');
    if (!this.dom.canvas) {
        console.error("Fatal: Canvas element 'map' not found.");
        alert("Fatal Error: Canvas element not found. The application cannot start.");
        return; 
    }
    this.dom.ctx = this.dom.canvas.getContext('2d');
    if (!this.dom.ctx) {
        console.error("Fatal: Could not get 2D rendering context for canvas.");
        alert("Fatal Error: Could not initialize 2D graphics. The application cannot start. Try a different browser or update your current one.");
        return; 
    }

    // Existing DOM elements
    this.dom.inpX = document.getElementById('inpX');
    this.dom.inpY = document.getElementById('inpY');
    this.dom.btnGo = document.getElementById('btnGo');
    this.dom.zoomLevelEl = document.getElementById('zoomLevel');
    this.dom.zoomDecBtn = document.getElementById('zoomDec');
    this.dom.zoomIncBtn = document.getElementById('zoomInc');
    this.dom.zoomSlider = document.getElementById('zoomSlider');
    this.dom.presetBtns = document.querySelectorAll('#presetButtons button');
    this.dom.centerTileEl = document.getElementById('centerTile');
    this.dom.infoBtn = document.getElementById('infoBtn');
    this.dom.infoPanel = document.getElementById('infoPanel');
    this.dom.statsBtn = document.getElementById('statsBtn');
    this.dom.statsPanel = document.getElementById('statsPanel');
    this.dom.statsFPSEl = document.getElementById('statsFPS');
    this.dom.statsTilesEl = document.getElementById('statsTiles');
    this.dom.coordsToggle = document.getElementById('coordsToggle');
    this.dom.floatingZoomLabel = document.getElementById('floatingZoomLabel');
    this.dom.versionDisplay = document.getElementById('versionDisplay');
    this.dom.patchNotesBtn = document.getElementById('patchNotesBtn');
    this.dom.modalOverlay = document.getElementById('modalOverlay');
    this.dom.patchNotesModal = document.getElementById('patchNotesModal');
    this.dom.patchNotesBody = document.getElementById('patchNotesBody');
    this.dom.closePatchNotesBtn = document.getElementById('closePatchNotesBtn');
    this.dom.hidePatchNotesCheckbox = document.getElementById('hidePatchNotesCheckbox');
    this.dom.tileDetailSelect = document.getElementById('tileDetailSelect');
    this.dom.gridlinesToggle = document.getElementById('gridlinesToggle');
    this.dom.allianceRssToggle = document.getElementById('allianceRssToggle');
    this.dom.allianceRssAlwaysVisibleToggle = document.getElementById('allianceRssAlwaysVisibleToggle');

    // New DOM elements for UI rearrangement
    this.dom.settingsBtn = document.getElementById('settingsBtn');
    this.dom.settingsPanel = document.getElementById('settingsPanel');
    this.dom.minimapCanvas = document.getElementById('minimapCanvas');
    if (this.dom.minimapCanvas) {
        // Set actual canvas drawing surface size (higher resolution for clarity)
        this.dom.minimapCanvas.width = this.config.minimap.width * (window.devicePixelRatio || 1);
        this.dom.minimapCanvas.height = this.config.minimap.height * (window.devicePixelRatio || 1);
        this.dom.minimapCtx = this.dom.minimapCanvas.getContext('2d');
    } else {
        console.warn("Minimap canvas element not found.");
    }
    
    for (const key in this.dom) {
        if (this.dom[key] === null && !['ctx', 'canvas', 'minimapCtx', 'minimapCanvas'].includes(key) && this.dom.hasOwnProperty(key)) { 
            console.warn(`DOM element for '${key}' not found.`);
        }
    }

    this.state.lastFrame = performance.now();
    
    Promise.all([
      fetch('baseMap.json').then(r => r.ok ? r.json() : Promise.resolve({ unoccupiableTiles:[], defaultBuildings:[] })),
      fetch('patch_notes.json').then(r => r.ok ? r.json() : Promise.resolve({}))
    ])
    .then(([baseMapData, patchNotesData]) => {
        Object.assign(self.state.baseMap, baseMapData);
        self.state.patchNotes = patchNotesData;

        self.preProcessBuildings();
        self.preCalculateChunks();
        self.calculateMinimapScale(); // Calculate once data is ready
        self.initializeUI();
        self.resize(); 
        
        requestAnimationFrame(self.mainLoop.bind(self));
    })
    .catch(e => {
        console.error("Error during application initialization:", e);
        alert('Error loading essential application data or initializing. Check console for details.');
    });
  },

  initializeUI() {
    // Settings Panel Toggle
    if(this.dom.settingsBtn && this.dom.settingsPanel) {
        this.dom.settingsBtn.addEventListener('click', () => this.dom.settingsPanel.classList.toggle('open'));
    }

    if(this.dom.infoBtn && this.dom.infoPanel) this.dom.infoBtn.addEventListener('click', ()=>this.dom.infoPanel.classList.toggle('open'));
    if(this.dom.statsBtn && this.dom.statsPanel) this.dom.statsBtn.addEventListener('click', ()=>this.dom.statsPanel.classList.toggle('open'));

    if(this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
    if(this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
    if(this.dom.closePatchNotesBtn) this.dom.closePatchNotesBtn.addEventListener('click', this.hidePatchNotes.bind(this));
    if(this.dom.modalOverlay) this.dom.modalOverlay.addEventListener('click', this.hidePatchNotes.bind(this));
    
    const lastSeenVersion = localStorage.getItem('lastSeenVersion');
    if (lastSeenVersion !== this.config.CURRENT_VERSION) {
        this.showPatchNotes();
    }

    if(this.dom.tileDetailSelect) {
        const savedDetail = localStorage.getItem('mapTileDetail') || '50';
        this.dom.tileDetailSelect.value = savedDetail;
        this.state.currentTileDetailThreshold = parseInt(savedDetail, 10); 
        this.dom.tileDetailSelect.addEventListener('change', () => {
            localStorage.setItem('mapTileDetail', this.dom.tileDetailSelect.value);
            this.state.currentTileDetailThreshold = parseInt(this.dom.tileDetailSelect.value, 10); 
        });
    }

    if(this.dom.allianceRssAlwaysVisibleToggle) {
        const savedAlwaysVisible = localStorage.getItem('mapAlwaysShowRss') === 'true';
        this.dom.allianceRssAlwaysVisibleToggle.checked = savedAlwaysVisible;
        this.dom.allianceRssAlwaysVisibleToggle.addEventListener('change', () => localStorage.setItem('mapAlwaysShowRss', this.dom.allianceRssAlwaysVisibleToggle.checked));
    }
    if(this.dom.gridlinesToggle) {
        const savedGridlines = localStorage.getItem('mapShowGridlines') !== 'false';
        this.dom.gridlinesToggle.checked = savedGridlines;
        this.dom.gridlinesToggle.addEventListener('change', () => localStorage.setItem('mapShowGridlines', this.dom.gridlinesToggle.checked));
    }
    if(this.dom.allianceRssToggle) {
        const savedAllianceRss = localStorage.getItem('mapShowAllianceRss') !== 'false';
        this.dom.allianceRssToggle.checked = savedAllianceRss;
        this.dom.allianceRssToggle.addEventListener('change', () => localStorage.setItem('mapShowAllianceRss', this.dom.allianceRssToggle.checked));
    }
    if(this.dom.coordsToggle) {
        const savedCoords = localStorage.getItem('mapShowCoords') === 'true';
        this.dom.coordsToggle.checked = savedCoords;
        this.dom.coordsToggle.addEventListener('change', () => localStorage.setItem('mapShowCoords', this.dom.coordsToggle.checked));
    }

    if(this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
    if(this.dom.inpX && this.dom.inpY) [this.dom.inpX, this.dom.inpY].forEach(i => i.addEventListener('keydown', e => { if (e.key==='Enter') this.doSearch(); }));

    if(this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-1));
    if(this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+1));
    if(this.dom.presetBtns) this.dom.presetBtns.forEach(b => {
        const zoomVal = b.dataset.zoom;
        if (zoomVal === 'Fit') {
            b.textContent = 'Fit';
            b.addEventListener('click', this.zoomToFit.bind(this));
        } else {
            b.addEventListener('click', () => {
                const cx = this.dom.canvas.width/2, cy = this.dom.canvas.height/2;
                this.animateZoom((Number(zoomVal) / 100) * this.config.baseScale, cx, cy, 200);
            });
        }
    });
    if(this.dom.zoomSlider) {
        this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));
        this.dom.zoomSlider.addEventListener('mousedown', () => {
            clearTimeout(this.state.hideLabelTimeout);
            this.updateFloatingZoomLabel();
        });
    }

    window.addEventListener('resize', this.resize.bind(this));
    window.addEventListener('mousemove', this.handleMouseMove.bind(this));
    window.addEventListener('mouseup', () => { this.state.dragging = false; });
    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    
    this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
    this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
    this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
    this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
    this.dom.canvas.addEventListener('contextmenu', e => e.preventDefault());
    
    this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
    this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
    this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));

    // Minimap click listener (Phase 2)
    if (this.dom.minimapCanvas) {
        this.dom.minimapCanvas.addEventListener('click', this.handleMinimapClick.bind(this));
    }
  },

  // ‚Äî‚Äî DATA PROCESSING & HELPERS ‚Äî‚Äî
  calculateMinimapScale() {
    if (!this.dom.minimapCanvas) return;
    const { minimap, N } = this.config;
    const drawWidth = this.dom.minimapCanvas.width - 2 * minimap.padding * (window.devicePixelRatio || 1);
    const drawHeight = this.dom.minimapCanvas.height - 2 * minimap.padding * (window.devicePixelRatio || 1);
    this.state.minimapActualScale = Math.min(drawWidth / N, drawHeight / N);
  },

  preProcessBuildings() {
    let buildings = [...(this.state.baseMap.defaultBuildings || []), ...(this.state.userBuildings || [])];
    if (this.state.baseMap.allianceRssBuildings) {
      const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
        const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
        return {
          x: rss.x, y: rss.y, w: 2, h: 2,
          displayName: style.displayName,
          fillColor: style.fillColor,
          borderColor: style.borderColor,
          displayCoordinates: false,
          isRss: true
        };
      });
      buildings = buildings.concat(formattedRssBuildings);
    }
    this.state.allBuildings = buildings;
    this.state.buildingMap.clear();
    for (const b of this.state.allBuildings) {
      if (typeof b.w === 'number' && typeof b.h === 'number') { 
        for (let dx = 0; dx < b.w; dx++) {
          for (let dy = 0; dy < b.h; dy++) {
            this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b);
          }
        }
      }
    }
  },

  preCalculateChunks() {
    const numLevels = 4;
    this.state.chunkLevels = []; 
    for (let level = 0; level < numLevels; level++) {
      const chunkSize = Math.pow(2, level + 1);
      const levelMap = new Map();
      for (let x = 0; x < this.config.N; x += chunkSize) {
        for (let y = 0; y < this.config.N; y += chunkSize) {
          const biome = this.getBiomeForTile(x, y);
          levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
        }
      }
      this.state.chunkLevels.push(levelMap);
    }
  },

  worldToScreen(x,y) {
    return [(x - y)*(this.config.tileW/2), -(x + y)*(this.config.tileH/2)];
  },

  screenToWorld(sx,sy) {
    const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
    const tileW_half = this.config.tileW / 2;
    const tileH_half = this.config.tileH / 2;

    if (tileW_half === 0 || tileH_half === 0) { 
        console.error("tileW or tileH is zero in config!");
        return [0,0]; 
    }

    const lx = (sx - this.state.cam.x)/scale;
    const ly = (sy - this.state.cam.y)/scale;
    const u  = lx/tileW_half;
    const v  = -ly/tileH_half;
    const world_x = Math.round((u+v)/2);
    const world_y = Math.round((v-u)/2);
    return [world_x,world_y];
  },

  getBuildingAt(x, y) {
    return this.state.buildingMap.get(`${x},${y}`) || null;
  },

  getBiomeForTile(x, y) {
    const { fertile, plains } = this.config.biomeRegions;
    if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
    if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
    return 'badlands';
  },

  getChunkLevelForZoom(pct) {
    if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100; 
    const detailThreshold = this.state.currentTileDetailThreshold; 
    if (pct > detailThreshold) return -1;
    if (pct > detailThreshold / 2) return 0;
    if (pct > detailThreshold / 5) return 1;
    if (pct > detailThreshold / 10) return 2;
    return 3;
  },

  // ‚Äî‚Äî UI & INTERACTION HANDLERS (Existing ones mostly unchanged) ‚Äî‚Äî
  showPatchNotes() { /* ... same ... */ },
  hidePatchNotes() { /* ... same ... */ },
  handleMouseDown(e) { /* ... same ... */ },
  handleMouseMove(e) { /* ... same ... */ },
  handleCanvasClick(e) { /* ... same ... */ },
  handleWheel(e) { /* ... same ... */ },
  handleDblClick(e) { /* ... same ... */ },
  handleZoomSlider() { /* ... same ... */ },
  handleKeyDown(e) { /* ... same ... */ },
  handleTouchStart(e) { /* ... same ... */ },
  handleTouchMove(e) { /* ... same ... */ },
  handleTouchEnd(e) { /* ... same ... */ },
  doSearch() { /* ... same ... */ },
  centerOn(x,y) { /* ... same ... */ },
  zoomToFit() { /* ... same ... */ },
  
  resize() {
    this.dom.canvas.width  = window.innerWidth;
    this.dom.canvas.height = window.innerHeight;
    
    if (this.dom.minimapCanvas) { 
        const dpr = window.devicePixelRatio || 1;
        this.dom.minimapCanvas.width = this.config.minimap.width * dpr;
        this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
        this.calculateMinimapScale(); 
    }

    const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
    const mapTotalHeight = (this.config.N - 1) * this.config.tileH;

    const safeMapTotalWidth = Math.max(1, mapTotalWidth);
    const safeMapTotalHeight = Math.max(1, mapTotalHeight);

    const scaleX = this.dom.canvas.width / safeMapTotalWidth;
    const scaleY = this.dom.canvas.height / safeMapTotalHeight;
    
    // --- MODIFIED minFitScale calculation ---
    let calculatedMinFit = Math.min(scaleX, scaleY) * 0.95; // Calculate the true geometric fit

    // Ensure minFitScale is not impractically small for visibility.
    // 0.025 is chosen as a practical minimum. If baseScale is 5, this is 0.5% zoom.
    // This means "Fit" will not zoom out beyond this practical limit,
    // even if the geometric fit would be smaller.
    this.state.minFitScale = Math.max(0.025, calculatedMinFit); 
    
    // Failsafe if calculatedMinFit somehow resulted in NaN (e.g., if canvas dimensions were 0 and division by 0 occurred, though safeMapTotalWidth should prevent that)
    if (isNaN(this.state.minFitScale)) {
        this.state.minFitScale = 0.025; 
    }
    // --- END MODIFICATION ---
    
    if (this.state.isInitialLoad) {
        this.state.cam.scale = this.state.minFitScale; 
        this.state.cam.x = this.dom.canvas.width / 2;
        this.state.cam.y = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * this.state.cam.scale;
        this.clampCamera(); 
        this.state.isInitialLoad = false;
    } else {
        // When resizing after initial load, ensure current scale respects the new minFitScale
        this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
        if(isNaN(this.state.cam.scale)) { // Failsafe for cam.scale
             this.state.cam.scale = this.state.minFitScale; 
        }
        this.clampCamera();
    }
  },

  clampCamera() { /* ... same ... */ },
  changeZoomBy(delta) { /* ... same ... */ },
  animateZoom(targetScale, anchorX, anchorY, duration=150) { /* ... same ... */ },
  animatePanZoom(targetScale, targetX, targetY, duration=300) { /* ... same ... */ },
  updateFloatingZoomLabel() { /* ... same ... */ },

  // --- MINIMAP FUNCTIONS ---
  handleMinimapClick(e) {
    if (!this.dom.minimapCanvas) return;
    const { minimap, N } = this.config;
    const dpr = window.devicePixelRatio || 1;
    const rect = this.dom.minimapCanvas.getBoundingClientRect();
    const clickX = (e.clientX - rect.left) * dpr; // Scale click to canvas internal resolution
    const clickY = (e.clientY - rect.top) * dpr;

    const padding = minimap.padding * dpr;
    const minimapScale = this.state.minimapActualScale;

    // Convert minimap click to world coordinates
    let worldX = (clickX - padding) / minimapScale;
    let worldY = (clickY - padding) / minimapScale;

    // Clamp to world bounds
    worldX = Math.max(0, Math.min(N - 1, worldX));
    worldY = Math.max(0, Math.min(N - 1, worldY));
    
    // Center main map on these world coordinates
    // We want the clicked point to be the new center of the main view
    const [screenX, screenY] = this.worldToScreen(worldX, worldY);
    const targetCamX = this.dom.canvas.width/2 - screenX * this.state.cam.scale;
    const targetCamY = this.dom.canvas.height/2 - screenY * this.state.cam.scale;
    this.animatePanZoom(this.state.cam.scale, targetCamX, targetCamY, 200);
  },

  drawMinimap(mainViewBounds) {
    if (!this.dom.minimapCtx) return;

    const ctx = this.dom.minimapCtx;
    const { minimap, N, biomeRegions, biomeColors } = this.config;
    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = this.dom.minimapCanvas.width;
    const canvasHeight = this.dom.minimapCanvas.height;
    const mScale = this.state.minimapActualScale;
    const mPadding = minimap.padding * dpr;

    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.fillStyle = minimap.bgColor;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Draw Biome Regions (simplified as 2D top-down)
    for (const biomeName in biomeRegions) {
        const region = biomeRegions[biomeName];
        ctx.fillStyle = biomeColors[biomeName];
        const x = mPadding + region.x1 * mScale;
        const y = mPadding + region.y1 * mScale;
        const w = (region.x2 - region.x1 + 1) * mScale;
        const h = (region.y2 - region.y1 + 1) * mScale;
        ctx.fillRect(x, y, w, h);
    }
    
    // Draw Key Buildings (e.g., King's Castle, Fortresses)
    (this.state.baseMap.defaultBuildings || []).forEach(b => {
        if (b.displayName === "King's Castle") {
            ctx.fillStyle = minimap.kingCastleColor;
        } else if (b.displayName.startsWith("Fortress")) {
            ctx.fillStyle = this.config.ALLIANCE_RSS_STYLES.stone.borderColor; // Use a fortress-like color
        } else {
            return; // Only draw specific key buildings for clarity, or use a generic color
            // ctx.fillStyle = minimap.buildingColor; 
        }
        const bx = mPadding + b.x * mScale;
        const by = mPadding + b.y * mScale;
        const bw = Math.max(1 * dpr, b.w * mScale); // Ensure min 1 pixel width
        const bh = Math.max(1 * dpr, b.h * mScale); // Ensure min 1 pixel height
        ctx.fillRect(bx, by, bw, bh);
    });


    // Draw Viewport Rectangle
    if (mainViewBounds) {
        const vx = mPadding + mainViewBounds.minX * mScale;
        const vy = mPadding + mainViewBounds.minY * mScale;
        const vw = (mainViewBounds.maxX - mainViewBounds.minX) * mScale;
        const vh = (mainViewBounds.maxY - mainViewBounds.minY) * mScale;

        ctx.fillStyle = minimap.viewportFillColor;
        ctx.fillRect(vx, vy, vw, vh);
        ctx.strokeStyle = minimap.viewportBorderColor;
        ctx.lineWidth = 1 * dpr;
        ctx.strokeRect(vx, vy, vw, vh);
    }
  },

  // ‚Äî‚Äî DRAWING FUNCTIONS (Main Canvas) ‚Äî‚Äî
  drawTile(x, y, drawBorder = true) { /* ... same ... */ },
  drawChunk(chunk, drawBorder = true) { /* ... same ... */ },
  drawBuildingFootprint(b, highlightStyle = null, drawBorder = true) { /* ... same ... */ },

  // ‚Äî‚Äî MAIN RENDER LOOP ‚Äî‚Äî
  mainLoop(now) {
    const { dom, state, config } = this;
    const ctx = dom.ctx; 
    
    try {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,dom.canvas.width,dom.canvas.height);

        const [centerX, centerY] = this.screenToWorld(dom.canvas.width/2, dom.canvas.height/2);
        if(dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
        
        const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
        const pct = Math.round((currentCamScale / config.baseScale) * 100);

        if(dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
        if(dom.zoomSlider) {
            if (pct > parseInt(dom.zoomSlider.max,10)) dom.zoomSlider.max = pct.toString();
            if (pct < parseInt(dom.zoomSlider.min,10)) dom.zoomSlider.min = pct.toString();
            dom.zoomSlider.value = pct.toString();
        }
        state.tileCount = 0;

        ctx.save();
        ctx.setTransform(currentCamScale,0,0,currentCamScale,state.cam.x,state.cam.y);
        ctx.strokeStyle = config.borderColor;
        ctx.lineWidth = config.strokeW;
        
        const [tl_x, tl_y] = this.screenToWorld(0, 0);
        const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
        const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height);
        const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
        const viewBounds = { // These are world coordinates of the main view
          minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2,
          maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
          minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2,
          maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
        };

        if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
            console.error("View bounds are NaN, skipping render cycle.", viewBounds);
            ctx.restore();
            this.drawMinimap(null); // Draw minimap without viewport if bounds are bad
            requestAnimationFrame(this.mainLoop.bind(this));
            return;
        }

        const chunkLevel = this.getChunkLevelForZoom(pct);
        const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
        const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
        const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;

        // ... (Main map drawing logic - same as before) ...
        if (chunkLevel === -1) {
          const shouldDrawBorders = showGrid && pct > 50;
          const minSum = Math.floor(viewBounds.minX + viewBounds.minY);
          const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);
          for (let sum = minSum; sum <= maxSum; sum++) {
            const startXCoord = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY)));
            const endXCoord = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));
            for (let x = startXCoord; x <= endXCoord; x++) {
                const y = sum - x;
                if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue;
                if (!this.getBuildingAt(x, y)) this.drawTile(x, y, shouldDrawBorders);
            }
          }
          state.allBuildings
            .filter(b => 
              (!b.isRss || showRss) && 
              !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)
            )
            .forEach(b => this.drawBuildingFootprint(b, null, shouldDrawBorders));
          ctx.fillStyle = '#444';
          (state.baseMap.unoccupiableTiles || []).forEach(([x,y])=>{
            if (this.getBuildingAt(x, y)) return;
            if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
            const [sx,sy] = this.worldToScreen(x,y);
            ctx.beginPath();
            ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
            ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
            ctx.closePath(); ctx.fill();
          });
        } else { // Chunked view
          if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
            const chunksToDraw = state.chunkLevels[chunkLevel];
            const chunkSize = Math.pow(2, chunkLevel + 1);
            const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize;
            const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
            const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize;
            const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
            for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
              for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
                  const chunk = chunksToDraw.get(`${x},${y}`);
                  if (chunk) this.drawChunk(chunk, false);
              }
            }
          }
          (state.baseMap.defaultBuildings || [])
            .filter(b => !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
            .forEach(b => this.drawBuildingFootprint(b, null, false));
          if (showRss && alwaysShowRss) {
            state.allBuildings
              .filter(b => 
                b.isRss && 
                !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)
              )
              .forEach(b => this.drawBuildingFootprint(b, null, false));
          }
          if (chunkLevel < 2) {
              ctx.fillStyle = '#444';
              (state.baseMap.unoccupiableTiles || []).forEach(([x,y])=>{
                if (this.getBuildingAt(x, y)) return;
                if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
                const [sx,sy] = this.worldToScreen(x,y);
                ctx.beginPath();
                ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
                ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
                ctx.closePath(); ctx.fill();
              });
          }
        }

        if (state.selection) { /* ... same selection drawing ... */ }
        
        ctx.restore(); // Restore main canvas transform

        // Draw Minimap
        this.drawMinimap(viewBounds);


        const dt  = now - state.lastFrame;
        state.lastFrame = now;
        if (dt > 0) { 
            state.lastFPS   = Math.round(1000/dt);
        }
        state.lastTiles = state.tileCount;
        
        if (now - state.statsUpdateTime > 500) { 
          if(dom.statsFPSEl) dom.statsFPSEl.textContent   = `FPS:   ${state.lastFPS}`;
          if(dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
          state.statsUpdateTime = now; 
        }

    } catch (error) {
        console.error("Error in mainLoop:", error);
    }
    
    requestAnimationFrame(this.mainLoop.bind(this));
  }
};

KingshotPlanner.init();

</script>
</body>
</html>