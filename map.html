<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
<style>
    body {
      margin:0; background:#111; overflow:hidden;
      -webkit-user-select:none; user-select:none;
    }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }

    /* UI Container */
    #searchBox {
      position:absolute; top:10px; left:10px; z-index:10;
      color:#fff; font-family:sans-serif;
      background:rgba(0,0,0,0.6); padding:8px; border-radius:4px;
    }
    #searchBox input { width:60px; }
    #searchBox input[type=range] {
      width:250px;
      vertical-align:middle; margin:0 6px;
    }
    #searchBox button {
      margin:2px 4px 2px 0;
      -webkit-user-select:none; user-select:none;
    }
    #zoomLevel, #centerTile {
      margin-top:4px; font-size:14px;
      -webkit-user-select:none; user-select:none;
    }

    /* Info & Stats panels */
    #infoBtn, #statsBtn {
      margin-top:6px; -webkit-user-select:none; user-select:none;
    }
    #infoPanel, #statsPanel {
      max-height:0; overflow:hidden;
      transition:max-height 0.3s ease;
      margin-top:6px;
      background:rgba(58,55,55,0.85);
      padding:0 6px; border-radius:4px;
      font-size:13px; color:#ddd;
    }
    #infoPanel.open, #statsPanel.open { max-height:120px; }
    #infoPanel h4 { margin:6px 0 4px; color:#fff; }
    #infoPanel ul { padding-left:16px; margin:0 }
    #infoPanel li { margin-bottom:4px; }
    #statsPanel div { margin:4px 0; color:#fff; }
  </style>
</head>
<body>
  <div id="searchBox">
    X: <input id="inpX" type="number" min="0" max="1199" value="0">
    Y: <input id="inpY" type="number" min="0" max="1199" value="0">
    <button id="btnGo">Go</button>
    <div id="zoomLevel">Zoom: 100%</div>
    <button id="zoomDec">−</button>
    <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
    <button id="zoomInc">+</button>
    <div id="presetButtons">
        <button data-zoom="Fit">Fit</button>
        <button data-zoom="50">50%</button>
        <button data-zoom="75">75%</button>
        <button data-zoom="100">100%</button>
    </div>
    <div id="centerTile">Center: X0 Y0</div>
    <button id="infoBtn" title="Show controls">ℹ️</button>
    <div id="infoPanel">
      <h4>Controls</h4>
      <ul>
        <li><strong>Pan</strong>: drag / one-finger touch</li>
        <li><strong>Zoom</strong>: wheel, slider, +/–, q/e, dblclick</li>
        <li><strong>Zoom out</strong>: right-dblclick</li>
        <li><strong>Pinch</strong>: two-finger touch</li>
        <li><strong>Keyboard</strong>: arrows to pan</li>
        <li><strong>Search</strong>: enter X/Y then Go (zooms to 150%)</li>
      </ul>
    </div>
    <button id="statsBtn" title="Toggle stats">⚙️</button>
    <div id="statsPanel">
      <div id="statsFPS">FPS: –</div>
      <div id="statsTiles">Tiles: –</div>
    </div>
  </div>

  <canvas id="map"></canvas>

<script>
// —— CONFIG ——
  const N           = 1200,
        tileW       = 10, tileH = 10,
        strokeW     = 1,
        borderColor = '#000',
        textColor   = '#fff',
        // MODIFIED: Retuned detailScale to work with a new linear merging formula
        detailScale = 7.5,
        maxPct      = 1000,
        selectionColor = '#ff0';
  
  const baseScale = 5;

  const biomeColors = {
    fertile:  'rgb(109, 159, 62)',
    plains:   'rgb(158, 180, 103)',
    badlands: 'rgb(191, 208, 152)'
  };
  // ——————————

  // DOM refs
  const canvas       = document.getElementById('map');
  const ctx          = canvas.getContext('2d');
  const inpX         = document.getElementById('inpX');
  const inpY         = document.getElementById('inpY');
  const btnGo        = document.getElementById('btnGo');
  const zoomLevelEl  = document.getElementById('zoomLevel');
  const zoomDecBtn   = document.getElementById('zoomDec');
  const zoomIncBtn   = document.getElementById('zoomInc');
  const zoomSlider   = document.getElementById('zoomSlider');
  const presetBtns   = document.querySelectorAll('#presetButtons button');
  const centerTileEl = document.getElementById('centerTile');
  const infoBtn      = document.getElementById('infoBtn');
  const infoPanel    = document.getElementById('infoPanel');
  const statsBtn     = document.getElementById('statsBtn');
  const statsPanel   = document.getElementById('statsPanel');
  const statsFPSEl   = document.getElementById('statsFPS');
  const statsTilesEl = document.getElementById('statsTiles');

  // toggle panels
  infoBtn.addEventListener('click', ()=>infoPanel.classList.toggle('open'));
  statsBtn.addEventListener('click', ()=>statsPanel.classList.toggle('open'));

  // data layers
  let baseMap = { unoccupiableTiles:[], defaultBuildings:[] };
  const buildingMap = new Map();

  function preProcessBuildings() {
    buildingMap.clear();
    const allBuildings = [...baseMap.defaultBuildings, ...userBuildings];
    for (const b of allBuildings) {
      for (let dx = 0; dx < b.w; dx++) {
        for (let dy = 0; dy < b.h; dy++) {
          const key = `${b.x + dx},${b.y + dy}`;
          buildingMap.set(key, b);
        }
      }
    }
  }

  fetch('baseMap.json')
    .then(r=>r.ok? r.json(): Promise.reject(r.status))
    .then(d=>{
      Object.assign(baseMap, d);
      preProcessBuildings();
      resize();
    })
    .catch(e=>{ console.error(e); alert('BaseMap load error'); });
  
  let userBuildings = [];

  // camera + stats state …
  const cam = { x:0, y:0, scale:1 };
  let lastFrame = performance.now(),
      tileCount = 0,
      lastFPS = 0,
      lastTiles = 0;
  let selection = null; 
  let minFitScale = 0.01; 

  // coord transforms
  function worldToScreen(x,y) {
    return [(x - y)*(tileW/2), -(x + y)*(tileH/2)];
  }
  function screenToWorld(sx,sy) {
    const lx = (sx - cam.x)/cam.scale,
          ly = (sy - cam.y)/cam.scale,
          u  = lx/(tileW/2),
          v  = -ly/(tileH/2);
    const x = Math.round((u+v)/2),
          y = Math.round((v-u)/2);
    return [x,y];
  }

  function getBuildingAt(x, y) {
    return buildingMap.get(`${x},${y}`) || null;
  }

  function getBiomeForTile(x, y) {
    if (x >= 450 && x <= 749 && y >= 450 && y <= 749) {
      return 'fertile';
    }
    else if (x >= 300 && x <= 899 && y >= 300 && y <= 899) {
      return 'plains';
    }
    else {
      return 'badlands';
    }
  }

  // --- GRID DRAWING ---
  function drawTile(x, y) {
    tileCount++;
    const [sx,sy] = worldToScreen(x,y);
    ctx.beginPath();
    ctx.moveTo(   sx,        sy - tileH/2);
    ctx.lineTo(sx + tileW/2, sy      );
    ctx.lineTo(   sx,        sy + tileH/2);
    ctx.lineTo(sx - tileW/2, sy      );
    ctx.closePath();
    
    const biome = getBiomeForTile(x, y);
    ctx.fillStyle = biomeColors[biome];
    ctx.fill();

    ctx.strokeStyle = borderColor; ctx.lineWidth = strokeW; ctx.stroke();

    const building = getBuildingAt(x, y);
    if (building && building.hideCoordinates) {
        return;
    }

    // MODIFIED: Hide coordinates until zoom level is > 100%
    if (cam.scale <= baseScale) {
        return;
    }
    
    const availableWidth = tileW;
    const availableHeight = tileH;
    const text = `${x}, ${y}`;
    const padding = 0.8;
    let optimalFontSize = Math.min(
      availableHeight * padding * 0.5,
      (availableWidth * padding / text.length) * 1.8
    );
    
    // MODIFIED: Further reduce font size for better visual balance
    optimalFontSize *= 0.7;

    if ((optimalFontSize * cam.scale) < 5) {
        return;
    }

    ctx.fillStyle = textColor;
    ctx.font = `${optimalFontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, sx, sy);
  }

  function drawMergedTile(x, y, size) {
    tileCount += size * size;
    const x0 = x, y0 = y, w = size, h = size;
    const rightTile  = { x: x0 + w - 1, y: y0 };
    const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
    const leftTile   = { x: x0,         y: y0 + h - 1 };

    const [sbx, sby] = worldToScreen(x0, y0);
    const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
    const [stx, sty] = worldToScreen(topTile.x, topTile.y);
    const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);

    const p_bottom = { x: sbx,             y: sby + tileH/2 };
    const p_right  = { x: srx + tileW/2,   y: sry };
    const p_top    = { x: stx,             y: sty - tileH/2 };
    const p_left   = { x: slx - tileW/2,   y: sly };

    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y);
    ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x,    p_top.y);
    ctx.lineTo(p_left.x,   p_left.y);
    ctx.closePath();

    const biome = getBiomeForTile(x, y);
    ctx.fillStyle = biomeColors[biome];
    ctx.fill();
  }

  function drawGrid(groupSize) {
    const halfH = tileH/2, s = cam.scale, H = canvas.height;
    const maxCoord = N - 1;
    const sumMin = Math.max(0, Math.floor((cam.y - H - halfH*s)/(s*halfH)));
    const sumMax = Math.min(2 * maxCoord, Math.ceil((cam.y + halfH*s)/(s*halfH)));
    
    for (let sum = sumMin; sum <= sumMax; sum++) {
      const sx = Math.max(0, sum - maxCoord), ex = Math.min(sum, maxCoord);
      for (let x = sx; x <= ex; x++) {
        const y = sum - x;
        
        if (!getBuildingAt(x, y)) {
            if (groupSize === 1) {
              drawTile(x, y);
            } else {
              if (x % groupSize === 0 && y % groupSize === 0) {
                drawMergedTile(x, y, groupSize);
              }
            }
        }
      }
    }
  }

  function drawBuildingFootprint(b, highlightStyle = null) {
    const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
    const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
    const x0 = b.x, y0 = b.y, w = b.w, h = b.h;

    const bottomTile = { x: x0, y: y0 };
    const rightTile  = { x: x0 + w - 1, y: y0 };
    const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
    const leftTile   = { x: x0, y: y0 + h - 1 };
    const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
    const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
    const [stx, sty] = worldToScreen(topTile.x, topTile.y);
    const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);
    const p_bottom = { x: sbx, y: sby + tileH/2 };
    const p_right  = { x: srx + tileW/2, y: sry };
    const p_top    = { x: stx, y: sty - tileH/2 };
    const p_left   = { x: slx - tileW/2, y: sly };
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y);
    ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x,    p_top.y);
    ctx.lineTo(p_left.x,   p_left.y);
    ctx.closePath();
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = border; 
    ctx.lineWidth = highlightStyle ? strokeW * 2 : strokeW;
    ctx.stroke();

    if (cam.scale > 0.4 && b.displayName) {
      const availableWidth = p_right.x - p_left.x;
      const availableHeight = p_bottom.y - p_top.y;
      
      if (availableWidth < 30 || availableHeight < 15) return;

      const padding = 0.9;
      let optimalFontSize = Math.min(availableHeight * padding, (availableWidth * padding / b.displayName.length) * 1.5);
      optimalFontSize = Math.min(48, optimalFontSize);

      const centerX = (p_left.x + p_right.x) / 2;
      const centerY = (p_top.y + p_bottom.y) / 2;

      ctx.fillStyle = textColor;
      ctx.font = `bold ${optimalFontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.displayName, centerX, centerY);
      
      if (b.displayCoordinates) {
        const coordFontSize = Math.max(8, optimalFontSize * 0.6);
        ctx.font = `${coordFontSize}px sans-serif`;
        ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, centerY + optimalFontSize * 0.9);
      }
    }
  }

  function centerOn(x,y) {
    const lx = (x - y)*(tileW/2),
          ly = -((x + y)*(tileH/2));
    cam.x = canvas.width*0.5 - lx*cam.scale;
    cam.y = canvas.height*0.5 - ly*cam.scale;
  }

  function zoomToFit() {
    cam.scale = minFitScale;
    clampCamera();
  }

  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    const mapTotalWidth = (N - 1) * tileW;
    const mapTotalHeight = (N - 1) * tileH;
    
    const scaleX = canvas.width / mapTotalWidth;
    const scaleY = canvas.height / mapTotalHeight;

    const padding = 0.95;
    minFitScale = Math.min(scaleX, scaleY) * padding;
    
    if (cam.scale === 1) {
        cam.scale = baseScale;
    }
    clampCamera();
  }
  window.addEventListener('resize', resize);

  function clampCamera() {
    const s = cam.scale;
    const mapScreenWidth = (N - 1) * tileW * s;
    const mapScreenHeight = (N - 1) * tileH * s;

    if (mapScreenWidth < canvas.width) {
      cam.x = canvas.width / 2;
    } else {
      const mapEdgeX = mapScreenWidth / 2;
      cam.x = Math.max(canvas.width - mapEdgeX, Math.min(mapEdgeX, cam.x));
    }

    if (mapScreenHeight < canvas.height) {
      cam.y = (canvas.height / 2) + (mapScreenHeight / 2);
    } else {
      cam.y = Math.max(canvas.height, Math.min(mapScreenHeight, cam.y));
    }
  }

  let dragging=false, lastX, lastY;
  let clickStartX, clickStartY;
  canvas.addEventListener('mousedown', e=>{
    if (e.button===0) {
      dragging=true;
      lastX = e.clientX;
      lastY = e.clientY;
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    }
  });
  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    cam.x += e.clientX - lastX;
    cam.y += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    clampCamera();
  });
  window.addEventListener('mouseup', ()=>dragging=false);

  canvas.addEventListener('click', e => {
    const dist = Math.hypot(e.clientX - clickStartX, e.clientY - clickStartY);
    if (dist > 5) {
      return;
    }
    const [worldX, worldY] = screenToWorld(e.offsetX, e.offsetY);

    if (worldX >= 0 && worldX < N && worldY >= 0 && worldY < N) {
      const building = getBuildingAt(worldX, worldY);
      
      if (building) {
        selection = building;
        inpX.value = building.x;
        inpY.value = building.y;
      } else {
        selection = { x: worldX, y: worldY };
        inpX.value = worldX;
        inpY.value = worldY;
      }
    }
  });

  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.1 : 0.9;
    const mx = e.offsetX, my = e.offsetY;
    const wx = (mx - cam.x)/cam.scale,
          wy = (my - cam.y)/cam.scale;
    cam.scale *= factor;
    cam.scale = Math.max(minFitScale,
      Math.min(maxPct/100 * baseScale, cam.scale));
    cam.x = mx - wx * cam.scale;
    cam.y = my - wy * cam.scale;
    clampCamera();
  },{ passive:false });

  function animateZoom(targetScale, anchorX, anchorY, duration=150) {
    const startScale = cam.scale;
    const startX = cam.x, startY = cam.y;
    const start = performance.now();
    const wx = (anchorX - startX)/startScale,
          wy = (anchorY - startY)/startScale;

    function step(now) {
      const t = Math.min(1, (now - start)/duration);
      const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
      cam.scale = startScale + (targetScale - startScale)*k;
      cam.x = anchorX - wx * cam.scale;
      cam.y = anchorY - wy * cam.scale;
      clampCamera();
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  canvas.addEventListener('dblclick', e=>{
    e.preventDefault();
    const curPct = Math.round((cam.scale / baseScale) * 100);
    let targetPct;
    if (e.button === 2) { 
      targetPct = (cam.scale >= detailScale) ? Math.round(curPct / 1.75) : curPct - 75;
    } else { 
      targetPct = (cam.scale < detailScale) ? curPct + 75 : Math.round(curPct * 1.75);
    }
    const targetScale = (targetPct / 100) * baseScale;
    animateZoom(Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale)), e.offsetX, e.offsetY);
  });

  canvas.addEventListener('contextmenu', e=>e.preventDefault());

  zoomSlider.addEventListener('input', () => {
    const cx = canvas.width/2, cy = canvas.height/2;
    const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
    let pct = Number(zoomSlider.value);
    const targetScale = (pct / 100) * baseScale;
    cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
    cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
    clampCamera();
  });

  function changeZoomBy(delta) {
    const cx = canvas.width/2, cy = canvas.height/2;
    const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
    let pct = Math.round((cam.scale / baseScale) * 100) + delta;
    const targetScale = (pct / 100) * baseScale;
    cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
    cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
    clampCamera();
  }
  zoomDecBtn.addEventListener('click', ()=>changeZoomBy(-1));
  zoomIncBtn.addEventListener('click', ()=>changeZoomBy(+1));

  presetBtns.forEach(b => {
    const zoomVal = b.dataset.zoom;
    if (zoomVal === 'Fit') {
        b.textContent = 'Fit';
        b.addEventListener('click', zoomToFit);
        return;
    }

    b.addEventListener('click', () => {
        const cx = canvas.width/2, cy = canvas.height/2;
        const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
        let pct = Number(zoomVal);
        const targetScale = (pct / 100) * baseScale;
        cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
        cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
        clampCamera();
    });
  });

  window.addEventListener('keydown', e=>{
    if (e.target.tagName==='INPUT') return;
    switch(e.key) {
      case '+': case '=': changeZoomBy(+1); break;
      case '-': changeZoomBy(-1); break;
      case 'q': changeZoomBy(+1); break;
      case 'e': changeZoomBy(-1); break;
      case 'ArrowUp':    cam.y += tileW * 5; clampCamera(); break;
      case 'ArrowDown':  cam.y -= tileW * 5; clampCamera(); break;
      case 'ArrowLeft':  cam.x += tileW * 5; clampCamera(); break;
      case 'ArrowRight': cam.x -= tileW * 5; clampCamera(); break;
    }
  });

  function doSearch() {
    const x = +inpX.value, y = +inpY.value;
    if (x>=0 && y>=0 && x<N && y<N) {
      const building = getBuildingAt(x, y);
      selection = building || { x, y };

      cam.scale = 12; 
      centerOn(x,y);
      clampCamera();
    }
  }
  btnGo.addEventListener('click', doSearch);
  [inpX,inpY].forEach(i=>{
    i.addEventListener('keydown', e=>{ if (e.key==='Enter') doSearch(); });
  });

  let touchMode = null;
  let startDist, startScale, pinchCenter;
  canvas.addEventListener('touchstart', e=>{
    e.preventDefault();
    if (e.touches.length===1) {
      touchMode = 'pan';
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    } else if (e.touches.length===2) {
      touchMode = 'pinch';
      const [a,b] = e.touches;
      startDist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
      startScale= cam.scale;
      pinchCenter = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', e=>{
    e.preventDefault();
    if (touchMode==='pan' && e.touches.length===1) {
      const t = e.touches[0];
      const dx = t.clientX - lastX, dy = t.clientY - lastY;
      cam.x += dx; cam.y += dy;
      lastX = t.clientX; lastY = t.clientY;
      clampCamera();
    }
    else if (touchMode==='pinch' && e.touches.length===2) {
      const [a,b] = e.touches;
      const dist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
      let scaleFactor = dist / startDist;
      let newScale = startScale * scaleFactor;
      newScale = Math.max(minFitScale, Math.min(maxPct/100 * baseScale, newScale));
      const wx = (pinchCenter.x - cam.x)/cam.scale, wy = (pinchCenter.y - cam.y)/cam.scale;
      cam.scale = newScale;
      cam.x = pinchCenter.x - wx*newScale;
      cam.y = pinchCenter.y - wy*newScale;
      clampCamera();
    }
  }, { passive:false });

  canvas.addEventListener('touchend', e=>{
    if (e.touches.length<2) touchMode = null;
  });

  function mainLoop(now) {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const [centerX, centerY] = screenToWorld(canvas.width/2, canvas.height/2);
    centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
    
    const pct = Math.round((cam.scale / baseScale) * 100);
    zoomLevelEl.textContent = `Zoom: ${pct}%`;
    zoomSlider.value = Math.min(pct, zoomSlider.max);
    
    const ratio = detailScale/cam.scale;

    // MODIFIED: Replaced the log2 calculation with a simpler linear one for smoother merging
    const groupSize = Math.max(1, Math.floor(ratio));
    
    tileCount = 0;

    ctx.save();
    ctx.setTransform(cam.scale,0,0,cam.scale,cam.x,cam.y);

    drawGrid(groupSize);

    ctx.fillStyle = '#444';
    baseMap.unoccupiableTiles.forEach(([x,y])=>{
      if (getBuildingAt(x, y)) return;
      const [sx,sy] = worldToScreen(x,y);
      ctx.beginPath();
      ctx.moveTo(sx, sy - tileH/2);
      ctx.lineTo(sx + tileW/2, sy);
      ctx.lineTo(sx, sy + tileH/2);
      ctx.lineTo(sx - tileW/2, sy);
      ctx.closePath();
      ctx.fill();
    });

    baseMap.defaultBuildings.forEach(b => drawBuildingFootprint(b));
    userBuildings.forEach(b => drawBuildingFootprint(b));

    if (selection) {
      if (selection.w) {
        drawBuildingFootprint(selection, selectionColor);
      } else {
        const [sx, sy] = worldToScreen(selection.x, selection.y);
        ctx.beginPath();
        ctx.moveTo(sx, sy - tileH/2);
        ctx.lineTo(sx + tileW/2, sy);
        ctx.lineTo(sx, sy + tileH/2);
        ctx.lineTo(sx - tileW/2, sy);
        ctx.closePath();
        ctx.strokeStyle = selectionColor;
        ctx.lineWidth = strokeW * 1.5;
        ctx.stroke();
      }
    }
    ctx.restore();

    const dt  = now - lastFrame;
    lastFrame = now;
    lastFPS   = Math.round(1000/dt);
    lastTiles = tileCount;
    
    if (!mainLoop.t0) mainLoop.t0 = now;
    if (now - mainLoop.t0 > 500) {
      statsFPSEl.textContent   = `FPS:   ${lastFPS}`;
      statsTilesEl.textContent = `Tiles: ${lastTiles}`;
      mainLoop.t0 = now;
    }
    
    requestAnimationFrame(mainLoop);
  }

  requestAnimationFrame(mainLoop);
  </script>
</body>
</html>