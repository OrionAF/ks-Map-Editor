<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      margin:0; background:#111; overflow:hidden;
      -webkit-user-select:none; user-select:none;
    }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }

    /* --- NEW: Search Controls (Left side) --- */
    #searchControls {
      /* order: 0; /* Place it at the top of zoomControlsContainer if it's moved inside */
      background: rgba(0,0,0,0.6);
      padding: 6px;
      border-radius: 4px;
      margin-bottom: 10px; /* Space between search and zoom slider */
      width: 200px; /* Match width of settings panel for consistency */
      box-sizing: border-box;
    }
    #searchControls h4 {
        margin: 0 0 4px;
        font-size: 13px;
        color: #aaa;
        text-transform: uppercase;
        text-align: left;
    }
    #searchControls > div {
        text-align: left;
    }
    #searchControls input { width:60px; }
    #searchControls button {
      margin:2px 0 2px 4px; /* Adjusted margin */
      -webkit-user-select:none; user-select:none;
    }

    /* --- MODIFIED: Settings Panel (Top Right) --- */
    #settingsContainer { /* Ensure settings has higher z-index to pop over everything if panel opens wide */
        position:absolute; top:10px; right:10px; z-index:1000;
        width: 210px; 
        text-align: right;
    }
    #settingsBtn {
      margin-bottom: 5px; /* Space between button and panel */
      padding: 6px 10px;
    }
    #settingsPanel { /* Formerly #searchBox */
      color:#fff; font-family:sans-serif;
      background:rgba(0,0,0,0.6); padding:8px; border-radius:4px;
      max-height: 0; /* Collapsed by default */
      overflow: hidden;
      transition: max-height 0.3s ease-out;
      text-align: left; /* Content within panel is left-aligned */
    }
    #settingsPanel.open {
      max-height: 500px; /* Adjust as needed to fit all content */
    }
    #settingsPanel input[type="checkbox"], 
    #settingsPanel select { 
      vertical-align: middle; 
    }
    #settingsPanel > div { margin-top: 4px; text-align: left; }
    #settingsPanel > hr {
        border: none;
        border-top: 1px solid #444;
        margin: 8px 0;
    }
    #settingsPanel h4 {
        margin: 6px 0 2px;
        font-size: 13px;
        color: #aaa;
        text-transform: uppercase;
        text-align: left;
    }
    
    /* Center Tile Display - MOVED to bottom-center */
    #centerTile {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      color:#fff; font-family:sans-serif;
      font-size:14px;
      -webkit-user-select:none; user-select:none;
      z-index: 10;
    }

    /* Coords Toggle Label Style */
    label.coords-label {
        font-size: 13px;
        vertical-align: middle;
        user-select: none;
    }

    /* Info & Stats panels (remain mostly the same, but now inside #settingsPanel) */
    #infoBtn, #statsBtn {
      margin-top:6px; -webkit-user-select:none; user-select:none;
    }
    #infoPanel, #statsPanel {
      max-height:0; overflow:hidden;
      transition:max-height 0.3s ease;
      margin-top:6px;
      background:rgba(58,55,55,0.85);
      padding:0 6px; border-radius:4px;
      font-size:13px; color:#ddd;
      text-align: left;
    }
    #infoPanel.open { max-height:160px; } 
    #statsPanel.open { max-height:120px; }
    #infoPanel h4 { margin:6px 0 4px; color:#fff; text-transform: none; }
    #infoPanel ul { padding-left:16px; margin:0 }
    #infoPanel li { margin-bottom:4px; }
    #statsPanel div { margin:4px 0; color:#fff; }


    /* --- STYLES for Vertical Zoom Controls (LEFT) --- */
    #zoomControlsContainer {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 10px; /* Reduced padding slightly */
      border-radius: 4px;
      z-index: 10;
      color: #fff;
      font-family: sans-serif;
    }
    
    #zoomControlsContainer #presetButtons {
      display: flex;
      flex-direction: column;
      gap: 5px;
      order: 4; /* Search will be order 0 */
    }

    #zoomControlsContainer button {
      -webkit-user-select:none; user-select:none;
      margin: 0;
      width: 60px;
    }

    #settingsPanel select { /* Ensure select within settings panel is styled */
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 2px;
      padding: 2px;
      width: 100%; 
    }

    #zoomControlsContainer #zoomInc { order: 2; } /* Adjusted order */
    #zoomControlsContainer #sliderWrapper { order: 3; position: relative; } /* Adjusted order */
    #zoomControlsContainer #zoomDec { order: 4; } /* Adjusted order */
    #zoomControlsContainer #zoomLevel { order: 5; font-size: 14px; margin-top: 5px; } /* Adjusted order */
    #searchControls { order: 1; } /* Search controls at the top of this left panel */


    #zoomSlider {
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr; 
      height: 55vh; /* Adjusted height slightly */
      max-height: 400px; /* Adjusted max-height */
      width: auto;
      margin: 0;
    }

    #floatingZoomLabel {
        position: absolute;
        display: none;
        left: 25px;
        background-color: #0b508f;
        color: white;
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 13px;
        pointer-events: none;
        transform: translateY(-50%);
    }

    /* --- STYLES for Version Display & Patch Notes --- */
    #versionDisplay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: sans-serif;
        font-size: 12px;
        user-select: none;
        z-index: 10;
    }

    #modalOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
    }

    #patchNotesModal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        background: #2c2c2c;
        color: #eee;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    .patch-notes-header {
        padding: 15px;
        border-bottom: 1px solid #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .patch-notes-header h3 { margin: 0; }
    .patch-notes-header .close-btn {
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
    }
    .patch-notes-body {
        padding: 15px;
        max-height: 60vh;
        overflow-y: auto;
    }
    .patch-notes-body ul {
        padding-left: 20px;
        margin: 0;
    }
    .patch-notes-body li { margin-bottom: 8px; }
    .patch-notes-footer {
        padding: 10px 15px;
        border-top: 1px solid #444;
        background: #333;
        border-radius: 0 0 8px 8px;
    }
    .patch-notes-footer label { user-select: none; font-size: 14px; }

    /* --- NEW: Minimap Styles --- */
    #minimapContainer {
        position: absolute;
        /* Push it below the settings button. Adjust 45px if button height changes. */
        top: 10px; 
        margin-top: 40px; 
        right: 10px;
        z-index: 900; /* Ensure it's above main canvas, below settings modal if it were ever to overlap */
        transition: margin-top 0.3s ease-out; /* Add this line */
    }
    #minimapCanvas {
        width: 200px; /* Desired display width */
        height: 150px; /* Desired display height */
        border: 1px solid #555;
        background-color: rgba(0,0,0,0.5); /* Placeholder background */
    }

  </style>
</head>
<body>
  <!-- Settings Container (Top Right) -->
  <div id="settingsContainer">
    <button id="settingsBtn">‚öôÔ∏è Settings</button>
    <div id="settingsPanel"> <!-- Formerly #searchBox -->
      <h4>Display</h4>
      <div>
        <input type="checkbox" id="gridlinesToggle">
        <label for="gridlinesToggle" class="coords-label">Show Gridlines</label>
      </div>
      <div>
        <input type="checkbox" id="coordsToggle">
        <label for="coordsToggle" class="coords-label">Show Coords >80%</label>
      </div>
      <div>
        <input type="checkbox" id="allianceRssToggle">
        <label for="allianceRssToggle" class="coords-label">Show Alliance RSS</label>
      </div>
      <div>
          <input type="checkbox" id="allianceRssAlwaysVisibleToggle">
          <label for="allianceRssAlwaysVisibleToggle" class="coords-label">Always Show RSS</label>
      </div>
      <hr>
      <h4>Performance</h4>
      <div>
          <label for="tileDetailSelect" class="coords-label">Tile Detail:</label>
          <select id="tileDetailSelect">
              <option value="25">Low (Merge Early)</option>
              <option value="50">Normal (Balanced)</option>
              <option value="80">High (Merge Late)</option>
          </select>
      </div>
      <hr>
      <div>
        <button id="infoBtn" title="Show controls">‚ÑπÔ∏è</button>
        <button id="statsBtn" title="Toggle stats">üìä</button> <!-- Changed icon for stats -->
      </div>
      <div id="infoPanel">
        <h4>Controls</h4>
        <ul>
          <li><strong>Pan</strong>: drag / one-finger touch</li>
          <li><strong>Zoom</strong>: wheel, slider, +/‚Äì, q/e, dblclick</li>
          <li><strong>Pinch</strong>: two-finger touch</li>
          <li><strong>Keyboard</strong>: arrows to pan</li>
        </ul>
        <button id="patchNotesBtn">Patch Notes</button>
      </div>
      <div id="statsPanel">
        <div id="statsFPS">FPS: ‚Äì</div>
        <div id="statsTiles">Tiles: ‚Äì</div>
      </div>
    </div>
  </div>

  <!-- Vertically oriented zoom controls (LEFT) -->
  <div id="zoomControlsContainer">
    <!-- Search Controls (Moved to Left) -->
    <div id="searchControls">
        <h4>Go To</h4>
        <div>
            X: <input id="inpX" type="number" min="0" max="1199" value="0">
            Y: <input id="inpY" type="number" min="0" max="1199" value="0">
            <button id="btnGo">Go</button>
        </div>
    </div>
    <button id="zoomInc">+</button>
    <div id="sliderWrapper">
        <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
        <div id="floatingZoomLabel"></div>
    </div>
    <button id="zoomDec">‚àí</button>
    <div id="presetButtons">
        <button data-zoom="Fit">Fit</button>
        <button data-zoom="50">50%</button>
        <button data-zoom="75">75%</button>
        <button data-zoom="100">100%</button>
    </div>
    <div id="zoomLevel">Zoom: 100%</div>
  </div>
  
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>

  <!-- Minimap Container (Top Right) -->
  <div id="minimapContainer">
      <canvas id="minimapCanvas"></canvas>
  </div>
  
  <!-- Patch Notes Modal -->
  <div id="modalOverlay"></div>
  <div id="patchNotesModal">
      <div class="patch-notes-header">
          <h3>What's New</h3>
          <button id="closePatchNotesBtn" class="close-btn">√ó</button>
      </div>
      <div class="patch-notes-body" id="patchNotesBody">
          <!-- Content will be injected by JS -->
      </div>
      <div class="patch-notes-footer"> <!-- Corrected class name -->
          <input type="checkbox" id="hidePatchNotesCheckbox">
          <label for="hidePatchNotesCheckbox">Do not show this again until the next update.</label>
      </div>
  </div>

  <canvas id="map"></canvas>

<script>
const KingshotPlanner = {
  // ‚Äî‚Äî CONFIGURATION ‚Äî‚Äî
  config: {
    CURRENT_VERSION: '0.2.7.4', // Version bump for minimap enhancements
    N: 1200,
    tileW: 10, tileH: 10,
    strokeW: 0.3, 
    borderColor: '#000', 
    textColor: '#fff',
    maxPct: 1000,
    selectionColor: '#ff0',
    pingColor: '#fff',
    pingDuration: 500, 
    baseScale: 5, // Main map base scale
    biomeColors: {
      fertile:  'rgb(109, 159, 62)',
      plains:   'rgb(158, 180, 103)',
      badlands: 'rgb(191, 208, 152)'
    },
    biomeRegions: {
        fertile:  { x1: 480, y1: 480, x2: 719, y2: 719 },
        plains:   { x1: 320, y1: 320, x2: 879, y2: 879 },
        badlands: { x1: 0,   y1: 0,   x2: 1199,y2: 1199}
    },
    ALLIANCE_RSS_STYLES: {
      wood:  { displayName: 'Wood',  fillColor: 'rgba(139,69,19,1)', borderColor: 'rgba(111,55,15,1)' },
      food:  { displayName: 'Food',  fillColor: 'rgba(255,165,0,1)', borderColor: 'rgba(204,132,0,1)' },
      stone: { displayName: 'Stone', fillColor: 'rgba(128,128,128,1)', borderColor: 'rgba(102,102,102,1)' },
      iron:  { displayName: 'Iron',  fillColor: 'rgba(192,192,192,1)', borderColor: 'rgba(153,153,153,1)' },
    },
    minimap: { 
        width: 200, 
        height: 150, 
        padding: 5, 
        bgColor: 'rgba(40,40,40,0.8)',
        viewportFillColor: 'rgba(255,255,255,0.2)',
        viewportBorderColor: 'rgba(255,255,255,0.7)',
        buildingColor: 'rgba(200,200,200,0.7)', 
        kingCastleColor: 'rgba(255,215,0,0.8)',
        zoomFactorMin: 1.0, // How much of the world is shown when main map is max zoomed OUT (1.0 = whole world)
        zoomFactorMax: 12.0, // How much minimap "zooms in" when main map is max zoomed IN (higher = more zoom)
                            // This factor scales the baseMinimapScale.
        mainMapZoomThresholdForMinimapZoom: 0.2 // Main map scale (relative to baseScale) below which minimap starts zooming
    }
  },

  // ‚Äî‚Äî APPLICATION STATE ‚Äî‚Äî
  state: {
    baseMap: { unoccupiableTiles:[], defaultBuildings:[] },
    patchNotes: {},
    allBuildings: [],
    buildingMap: new Map(),
    chunkLevels: [],
    userBuildings: [],
    cam: { x:0, y:0, scale:1 }, // Main camera
    lastFrame: 0,
    tileCount: 0,
    lastFPS: 0,
    lastTiles: 0,
    selection: null, 
    minFitScale: 0.1, 
    isInitialLoad: true,
    touchStartTime: 0,
    dragging: false, 
    lastX: 0, lastY: 0,
    clickStartX: 0, clickStartY: 0,
    touchMode: null,
    startDist: 0, startScale: 1, pinchCenter: null,
    startCamX: 0, startCamY: 0,
    hideLabelTimeout: null,
    statsUpdateTime: 0, 
    currentTileDetailThreshold: 50, 
    
    baseMinimapScale: 0.1,
    minimapActualScale: 0.1, // You already have this for the scale
    minimapWorldOffsetX: 0,  // <--- ADD THIS
    minimapWorldOffsetY: 0,  // <--- ADD THIS
    animationId: null 
  },

  // ‚Äî‚Äî DOM REFERENCES ‚Äî‚Äî
  dom: {
    canvas: null, ctx: null, inpX: null, inpY: null, btnGo: null,
    zoomLevelEl: null, zoomDecBtn: null, zoomIncBtn: null, zoomSlider: null,
    presetBtns: null, centerTileEl: null, infoBtn: null, infoPanel: null,
    statsBtn: null, statsPanel: null, statsFPSEl: null, statsTilesEl: null,
    coordsToggle: null, floatingZoomLabel: null, versionDisplay: null,
    patchNotesBtn: null, modalOverlay: null, patchNotesModal: null,
    patchNotesBody: null, closePatchNotesBtn: null, hidePatchNotesCheckbox: null,
    tileDetailSelect: null, gridlinesToggle: null, allianceRssToggle: null,
    allianceRssAlwaysVisibleToggle: null,
    settingsBtn: null, settingsPanel: null, 
    minimapCanvas: null, minimapCtx: null,
    minimapContainer: null
  },

  // ‚Äî‚Äî INITIALIZATION ‚Äî‚Äî
  init() {
    const self = this; 

    this.dom.canvas = document.getElementById('map');
    if (!this.dom.canvas) {
        console.error("Fatal: Canvas element 'map' not found.");
        alert("Fatal Error: Canvas element not found. The application cannot start.");
        return; 
    }
    this.dom.ctx = this.dom.canvas.getContext('2d');
    if (!this.dom.ctx) {
        console.error("Fatal: Could not get 2D rendering context for canvas.");
        alert("Fatal Error: Could not initialize 2D graphics. The application cannot start. Try a different browser or update your current one.");
        return; 
    }

    this.dom.inpX = document.getElementById('inpX');
    this.dom.inpY = document.getElementById('inpY');
    this.dom.btnGo = document.getElementById('btnGo');
    this.dom.zoomLevelEl = document.getElementById('zoomLevel');
    this.dom.zoomDecBtn = document.getElementById('zoomDec');
    this.dom.zoomIncBtn = document.getElementById('zoomInc');
    this.dom.zoomSlider = document.getElementById('zoomSlider');
    this.dom.presetBtns = document.querySelectorAll('#presetButtons button');
    this.dom.centerTileEl = document.getElementById('centerTile');
    this.dom.infoBtn = document.getElementById('infoBtn');
    this.dom.infoPanel = document.getElementById('infoPanel');
    this.dom.statsBtn = document.getElementById('statsBtn');
    this.dom.statsPanel = document.getElementById('statsPanel');
    this.dom.statsFPSEl = document.getElementById('statsFPS');
    this.dom.statsTilesEl = document.getElementById('statsTiles');
    this.dom.coordsToggle = document.getElementById('coordsToggle');
    this.dom.floatingZoomLabel = document.getElementById('floatingZoomLabel');
    this.dom.versionDisplay = document.getElementById('versionDisplay');
    this.dom.patchNotesBtn = document.getElementById('patchNotesBtn');
    this.dom.modalOverlay = document.getElementById('modalOverlay');
    this.dom.patchNotesModal = document.getElementById('patchNotesModal');
    this.dom.patchNotesBody = document.getElementById('patchNotesBody');
    this.dom.closePatchNotesBtn = document.getElementById('closePatchNotesBtn');
    this.dom.hidePatchNotesCheckbox = document.getElementById('hidePatchNotesCheckbox');
    this.dom.tileDetailSelect = document.getElementById('tileDetailSelect');
    this.dom.gridlinesToggle = document.getElementById('gridlinesToggle');
    this.dom.allianceRssToggle = document.getElementById('allianceRssToggle');
    this.dom.allianceRssAlwaysVisibleToggle = document.getElementById('allianceRssAlwaysVisibleToggle');
    this.dom.settingsBtn = document.getElementById('settingsBtn');
    this.dom.settingsPanel = document.getElementById('settingsPanel');
    this.dom.minimapContainer = document.getElementById('minimapContainer');
    this.dom.minimapCanvas = document.getElementById('minimapCanvas');
    if (this.dom.minimapCanvas) {
        this.dom.minimapCanvas.width = this.config.minimap.width * (window.devicePixelRatio || 1);
        this.dom.minimapCanvas.height = this.config.minimap.height * (window.devicePixelRatio || 1);
        this.dom.minimapCtx = this.dom.minimapCanvas.getContext('2d');
    } else {
        console.warn("Minimap canvas element not found.");
    }
    
    for (const key in this.dom) {
        if (this.dom[key] === null && !['ctx', 'canvas', 'minimapCtx', 'minimapCanvas'].includes(key) && this.dom.hasOwnProperty(key)) { 
            console.warn(`DOM element for '${key}' not found.`);
        }
    }

    this.state.lastFrame = performance.now();
    
    Promise.all([
      fetch('baseMap.json').then(r => r.ok ? r.json() : Promise.resolve({ unoccupiableTiles:[], defaultBuildings:[] })),
      fetch('patch_notes.json').then(r => r.ok ? r.json() : Promise.resolve({}))
    ])
    .then(([baseMapData, patchNotesData]) => {
        Object.assign(self.state.baseMap, baseMapData);
        self.state.patchNotes = patchNotesData;

        self.preProcessBuildings();
        self.preCalculateChunks();
        self.calculateBaseMinimapScale(); 
        self.initializeUI();
        self.resize(); 
        
        requestAnimationFrame(self.mainLoop.bind(self));
    })
    .catch(e => {
        console.error("Error during application initialization:", e);
        alert('Error loading essential application data or initializing. Check console for details.');
    });
  },

  initializeUI() {
    // Original simple settingsBtn listener is REMOVED/COMMENTED to avoid conflicts
    /* 
    if(this.dom.settingsBtn && this.dom.settingsPanel) {
        this.dom.settingsBtn.addEventListener('click', () => this.dom.settingsPanel.classList.toggle('open'));
    }
    */

    if(this.dom.infoBtn && this.dom.infoPanel) this.dom.infoBtn.addEventListener('click', ()=>this.dom.infoPanel.classList.toggle('open'));
    if(this.dom.statsBtn && this.dom.statsPanel) this.dom.statsBtn.addEventListener('click', ()=>this.dom.statsPanel.classList.toggle('open'));
    if(this.dom.versionDisplay) this.dom.versionDisplay.textContent = 'V' + this.config.CURRENT_VERSION;
    if(this.dom.patchNotesBtn) this.dom.patchNotesBtn.addEventListener('click', this.showPatchNotes.bind(this));
    if(this.dom.closePatchNotesBtn) this.dom.closePatchNotesBtn.addEventListener('click', this.hidePatchNotes.bind(this));
    if(this.dom.modalOverlay) this.dom.modalOverlay.addEventListener('click', this.hidePatchNotes.bind(this));
    
    const lastSeenVersion = localStorage.getItem('lastSeenVersion');
    if (lastSeenVersion !== this.config.CURRENT_VERSION) {
        this.showPatchNotes();
    }

    if(this.dom.tileDetailSelect) {
        const savedDetail = localStorage.getItem('mapTileDetail') || '50';
        this.dom.tileDetailSelect.value = savedDetail;
        this.state.currentTileDetailThreshold = parseInt(savedDetail, 10); 
        this.dom.tileDetailSelect.addEventListener('change', () => {
            localStorage.setItem('mapTileDetail', this.dom.tileDetailSelect.value);
            this.state.currentTileDetailThreshold = parseInt(this.dom.tileDetailSelect.value, 10); 
        });
    }
    if(this.dom.allianceRssAlwaysVisibleToggle) {
        const savedAlwaysVisible = localStorage.getItem('mapAlwaysShowRss') === 'true';
        this.dom.allianceRssAlwaysVisibleToggle.checked = savedAlwaysVisible;
        this.dom.allianceRssAlwaysVisibleToggle.addEventListener('change', () => localStorage.setItem('mapAlwaysShowRss', this.dom.allianceRssAlwaysVisibleToggle.checked));
    }
    if(this.dom.gridlinesToggle) {
        const savedGridlines = localStorage.getItem('mapShowGridlines') !== 'false';
        this.dom.gridlinesToggle.checked = savedGridlines;
        this.dom.gridlinesToggle.addEventListener('change', () => localStorage.setItem('mapShowGridlines', this.dom.gridlinesToggle.checked));
    }
    if(this.dom.allianceRssToggle) {
        const savedAllianceRss = localStorage.getItem('mapShowAllianceRss') !== 'false';
        this.dom.allianceRssToggle.checked = savedAllianceRss;
        this.dom.allianceRssToggle.addEventListener('change', () => localStorage.setItem('mapShowAllianceRss', this.dom.allianceRssToggle.checked));
    }
    if(this.dom.coordsToggle) {
        const savedCoords = localStorage.getItem('mapShowCoords') === 'true';
        this.dom.coordsToggle.checked = savedCoords;
        this.dom.coordsToggle.addEventListener('change', () => localStorage.setItem('mapShowCoords', this.dom.coordsToggle.checked));
    }
    if(this.dom.btnGo) this.dom.btnGo.addEventListener('click', this.doSearch.bind(this));
    if(this.dom.inpX && this.dom.inpY) [this.dom.inpX, this.dom.inpY].forEach(i => i.addEventListener('keydown', e => { if (e.key==='Enter') this.doSearch(); }));
    if(this.dom.zoomDecBtn) this.dom.zoomDecBtn.addEventListener('click', () => this.changeZoomBy(-1));
    if(this.dom.zoomIncBtn) this.dom.zoomIncBtn.addEventListener('click', () => this.changeZoomBy(+1));
    if(this.dom.presetBtns) this.dom.presetBtns.forEach(b => {
        const zoomVal = b.dataset.zoom;
        if (zoomVal === 'Fit') {
            b.textContent = 'Fit';
            b.addEventListener('click', this.zoomToFit.bind(this));
        } else {
            b.addEventListener('click', () => {
                const cx = this.dom.canvas.width/2, cy = this.dom.canvas.height/2;
                this.animateZoom((Number(zoomVal) / 100) * this.config.baseScale, cx, cy, 200);
            });
        }
    });

    // --- Logic for settings button and minimap interaction ---
    let originalMinimapMarginTopValue = '40px'; // Default from CSS
    if (this.dom.minimapContainer) {
        // Attempt to get computed style. Ensure this runs after DOM is ready and styles are applied.
        // If getComputedStyle is called too early, it might not reflect the CSS.
        // However, within initializeUI (called after DOM elements are fetched), this should generally be fine.
        try { // Add try-catch for robustness if getComputedStyle fails for any reason early on
            originalMinimapMarginTopValue = getComputedStyle(this.dom.minimapContainer).marginTop;
        } catch(e) {
            console.warn("Could not get computed style for minimapContainer.marginTop, using default.", e);
        }
    }

    if(this.dom.settingsBtn && this.dom.settingsPanel && this.dom.minimapContainer) {
        const panel = this.dom.settingsPanel;
        const minimap = this.dom.minimapContainer;
        const settingsBtn = this.dom.settingsBtn;
        const gap = 10; // Desired gap in pixels between panel and minimap

        const updateMinimapPosition = () => {
            const settingsButtonHeight = settingsBtn.offsetHeight;
            let settingsButtonMarginBottom = 0;
            try {
                 settingsButtonMarginBottom = parseInt(getComputedStyle(settingsBtn).marginBottom, 10) || 0;
            } catch(e) {
                console.warn("Could not get computed style for settingsBtn.marginBottom.", e);
            }


            if (panel.classList.contains('open')) {
                // Panel is open, position minimap below it
                const panelHeight = panel.offsetHeight;
                minimap.style.marginTop = `${settingsButtonHeight + settingsButtonMarginBottom + panelHeight + gap}px`;
            } else {
                // Panel is closed, reset minimap position
                minimap.style.marginTop = originalMinimapMarginTopValue;
            }
        };

        // Listen for transitionend on the panel to update after its animation
        panel.addEventListener('transitionend', (event) => {
            // Ensure we're reacting to the max-height transition from the panel itself
            if (event.target === panel && event.propertyName === 'max-height') {
                updateMinimapPosition();
            }
        });

        // This is the SOLE click listener for settingsBtn related to panel toggle and minimap
        this.dom.settingsBtn.addEventListener('click', () => {
            panel.classList.toggle('open');
            
            // If panel is closing, or if there's no transition / it's instantaneous,
            // update minimap position. 
            // For opening with a transition, 'transitionend' provides a more accurate final height.
            if (!panel.classList.contains('open')) { // Panel is now closed or closing
                 minimap.style.marginTop = originalMinimapMarginTopValue; // Reset minimap margin immediately
            } else { // Panel is now open or opening
                // If the panel already has a height (e.g. was already open, or no transition defined),
                // update position. Otherwise, 'transitionend' will handle it more accurately.
                // This helps if the panel was opened by default or if transitions are disabled in CSS.
                if (panel.offsetHeight > 0) {
                    updateMinimapPosition();
                }
                // If offsetHeight is 0 (e.g. max-height was 0 and now transitioning to 500px),
                // the `transitionend` event listener will call `updateMinimapPosition` 
                // once the panel has expanded.
            }
        });
    }
    // --- End of logic for settings button and minimap interaction ---


    if(this.dom.zoomSlider) {
        this.dom.zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));
        this.dom.zoomSlider.addEventListener('mousedown', () => {
            clearTimeout(this.state.hideLabelTimeout);
            this.updateFloatingZoomLabel();
        });
    }

    window.addEventListener('resize', this.resize.bind(this));
    window.addEventListener('mousemove', this.handleMouseMove.bind(this));
    window.addEventListener('mouseup', () => { this.state.dragging = false; });
    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    
    this.dom.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
    this.dom.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
    this.dom.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
    this.dom.canvas.addEventListener('dblclick', this.handleDblClick.bind(this));
    this.dom.canvas.addEventListener('contextmenu', e => e.preventDefault());
    this.dom.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
    this.dom.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
    this.dom.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));

    if (this.dom.minimapCanvas) {
        this.dom.minimapCanvas.addEventListener('click', this.handleMinimapClick.bind(this));
    }
  },

  calculateBaseMinimapScale() {
    if (!this.dom.minimapCanvas) return;
    const { minimap, N } = this.config;
    const dpr = window.devicePixelRatio || 1;
    const drawWidth = this.dom.minimapCanvas.width - 2 * minimap.padding * dpr;
    const drawHeight = this.dom.minimapCanvas.height - 2 * minimap.padding * dpr;
    
    this.state.baseMinimapScale = Math.min(drawWidth / N, drawHeight / N);
    if (this.state.baseMinimapScale <= 0) {
        console.warn("Base minimap scale calculated to be zero or negative. Setting to a small positive value.");
        this.state.baseMinimapScale = 0.01; // Default small positive value
    }
  },

  preProcessBuildings() {
    let buildings = [...(this.state.baseMap.defaultBuildings || []), ...(this.state.userBuildings || [])];
    if (this.state.baseMap.allianceRssBuildings) {
      const formattedRssBuildings = this.state.baseMap.allianceRssBuildings.map(rss => {
        const style = this.config.ALLIANCE_RSS_STYLES[rss.type] || {};
        return {
          x: rss.x, y: rss.y, w: 2, h: 2,
          displayName: style.displayName,
          fillColor: style.fillColor,
          borderColor: style.borderColor,
          displayCoordinates: false,
          isRss: true
        };
      });
      buildings = buildings.concat(formattedRssBuildings);
    }
    this.state.allBuildings = buildings;
    this.state.buildingMap.clear();
    for (const b of this.state.allBuildings) {
      if (typeof b.w === 'number' && typeof b.h === 'number') { 
        for (let dx = 0; dx < b.w; dx++) {
          for (let dy = 0; dy < b.h; dy++) {
            this.state.buildingMap.set(`${b.x + dx},${b.y + dy}`, b);
          }
        }
      }
    }
  },

  preCalculateChunks() {
    const numLevels = 4;
    this.state.chunkLevels = []; 
    for (let level = 0; level < numLevels; level++) {
      const chunkSize = Math.pow(2, level + 1);
      const levelMap = new Map();
      for (let x = 0; x < this.config.N; x += chunkSize) {
        for (let y = 0; y < this.config.N; y += chunkSize) {
          const biome = this.getBiomeForTile(x, y);
          levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
        }
      }
      this.state.chunkLevels.push(levelMap);
    }
  },

  worldToScreen(x,y) {
    return [(x - y)*(this.config.tileW/2), -(x + y)*(this.config.tileH/2)];
  },

  screenToWorld(sx,sy) {
    const scale = (this.state.cam.scale === 0 || isNaN(this.state.cam.scale)) ? this.state.minFitScale : this.state.cam.scale;
    const tileW_half = this.config.tileW / 2;
    const tileH_half = this.config.tileH / 2;

    if (tileW_half === 0 || tileH_half === 0) { 
        console.error("tileW or tileH is zero in config!");
        return [0,0]; 
    }
    if (scale === 0) { // Should be caught by the ternary above, but as an extra guard
        console.error("screenToWorld: scale is zero!");
        return [0,0];
    }

    const lx = (sx - this.state.cam.x)/scale;
    const ly = (sy - this.state.cam.y)/scale;
    const u  = lx/tileW_half;
    const v  = -ly/tileH_half;
    const world_x = Math.round((u+v)/2);
    const world_y = Math.round((v-u)/2);
    return [world_x,world_y];
  },

  getBuildingAt(x, y) {
    return this.state.buildingMap.get(`${x},${y}`) || null;
  },

  getBiomeForTile(x, y) {
    const { fertile, plains } = this.config.biomeRegions;
    if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) return 'fertile';
    if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) return 'plains';
    return 'badlands';
  },

  getChunkLevelForZoom(pct) {
    if (isNaN(pct)) pct = (this.state.cam.scale / this.config.baseScale) * 100; 
    const detailThreshold = this.state.currentTileDetailThreshold; 
    if (pct > detailThreshold) return -1;
    if (pct > detailThreshold / 2) return 0;
    if (pct > detailThreshold / 5) return 1;
    if (pct > detailThreshold / 10) return 2;
    return 3;
  },

// In your KingshotPlanner object:

  showPatchNotes() {
    if (!this.dom.patchNotesBody || !this.dom.modalOverlay || !this.dom.patchNotesModal) return;
    
    // Optional: Configure marked.js - do this once, perhaps in init or here.
    // For trusted content, default options are often fine.
    // Enabling GFM (GitHub Flavored Markdown) and breaks for newlines is common.
    if (typeof marked !== 'undefined') { // Ensure marked is loaded
        marked.setOptions({
            gfm: true,      // Enable GitHub Flavored Markdown (tables, strikethrough, etc.)
            breaks: true,   // Convert single newlines in Markdown to <br>
            sanitize: false // IMPORTANT: Set to true if parsing untrusted content. 
        });
    } else {
        console.warn("marked.js library not loaded. Markdown processing will be basic.");
    }


    const versions = Object.keys(this.state.patchNotes || {});
    if (versions.length === 0) {
        this.dom.patchNotesBody.innerHTML = `<p>No patch notes are available at this time.</p>`;
    } else {
        versions.sort((a, b) => {
            const partsA = a.split('.').map(Number);
            const partsB = b.split('.').map(Number);
            for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
                const numA = partsA[i] || 0;
                const numB = partsB[i] || 0;
                if (numA !== numB) return numB - numA;
            }
            return 0;
        });
        let content = '';
        versions.forEach((version, index) => {
            const notesForVersion = this.state.patchNotes[version] || [];
            const notesHtml = notesForVersion.map(noteText => {
                let htmlOutput = '';
                if (typeof marked !== 'undefined') {
                    htmlOutput = marked.parse(noteText.trim()); // Use marked.parse()
                } else {
                    // Fallback to basic text if marked.js isn't loaded
                    // You could add your simple regex parser here as a fallback if desired
                    htmlOutput = noteText.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">"); 
                }
                return `<li>${htmlOutput}</li>`;
            }).join('');

            content += `<h4>Version ${version}</h4><ul>${notesHtml}</ul>`;
            if (index < versions.length - 1) content += '<hr style="border-color: #444; border-top: 0;">';
        });
        this.dom.patchNotesBody.innerHTML = content;
    }
    this.dom.modalOverlay.style.display = 'block';
    this.dom.patchNotesModal.style.display = 'block';
  },

  hidePatchNotes() {
    if (!this.dom.modalOverlay || !this.dom.patchNotesModal) return;
    if (this.dom.hidePatchNotesCheckbox && this.dom.hidePatchNotesCheckbox.checked) {
        localStorage.setItem('lastSeenVersion', this.config.CURRENT_VERSION);
    }
    this.dom.modalOverlay.style.display = 'none';
    this.dom.patchNotesModal.style.display = 'none';
  },

  handleMouseDown(e) {
    if (e.button===0) {
      this.state.dragging = true;
      this.state.lastX = e.clientX;
      this.state.lastY = e.clientY;
      this.state.clickStartX = e.clientX;
      this.state.clickStartY = e.clientY;
    }
  },

  handleMouseMove(e) {
    if (!this.state.dragging) return;
    this.state.cam.x += e.clientX - this.state.lastX;
    this.state.cam.y += e.clientY - this.state.lastY;
    this.state.lastX = e.clientX;
    this.state.lastY = e.clientY;
    this.clampCamera();
  },

  handleCanvasClick(e) {
    const dist = Math.hypot(e.clientX - this.state.clickStartX, e.clientY - this.state.clickStartY);
    if (dist > 5) return;
    
    const [worldX, worldY] = this.screenToWorld(e.offsetX, e.offsetY);
    if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
      const building = this.getBuildingAt(worldX, worldY);
      this.state.selection = building || { x: worldX, y: worldY };
      if(this.state.selection) this.state.selection.pingStart = performance.now(); 
      if(this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
      if(this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
    }
  },

  handleWheel(e) {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.2 : 0.8;
    let targetScale = this.state.cam.scale * factor;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    this.animateZoom(targetScale, e.offsetX, e.offsetY, 150); 
  },

  handleDblClick(e) {
    e.preventDefault();
    const factor = e.button === 2 ? 0.5 : 2.0;
    let targetScale = this.state.cam.scale * factor;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    this.animateZoom(targetScale, e.offsetX, e.offsetY, 150);
  },

  handleZoomSlider() {
    if(!this.dom.zoomSlider) return;
    const pct = Number(this.dom.zoomSlider.value);
    let targetScale = (pct / 100) * this.config.baseScale;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    const cx = this.dom.canvas.width / 2, cy = this.dom.canvas.height / 2;
    this.animateZoom(targetScale, cx, cy, 0); 
    this.updateFloatingZoomLabel();
  },

  handleKeyDown(e) {
    if (e.target && e.target.tagName==='INPUT') return;
    switch(e.key) {
      case '+': case '=': this.changeZoomBy(+1); break;
      case '-': this.changeZoomBy(-1); break;
      case 'q': this.changeZoomBy(+1); break;
      case 'e': this.changeZoomBy(-1); break;
      case 'ArrowUp':    this.state.cam.y += this.config.tileW * 5; this.clampCamera(); break;
      case 'ArrowDown':  this.state.cam.y -= this.config.tileW * 5; this.clampCamera(); break;
      case 'ArrowLeft':  this.state.cam.x += this.config.tileW * 5; this.clampCamera(); break;
      case 'ArrowRight': this.state.cam.x -= this.config.tileW * 5; this.clampCamera(); break;
    }
  },

  handleTouchStart(e) {
    e.preventDefault();
    if (e.touches.length === 1) {
        this.state.touchMode = 'pan';
        const t = e.touches[0];
        this.state.lastX = t.clientX;
        this.state.lastY = t.clientY;
        this.state.clickStartX = t.clientX;
        this.state.clickStartY = t.clientY;
        this.state.touchStartTime = performance.now();
    } else if (e.touches.length === 2) {
        this.state.touchMode = 'pinch';
        const [a,b] = e.touches;
        this.state.startDist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
        this.state.startScale = this.state.cam.scale;
        this.state.pinchCenter = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
        
        this.state.startCamX = this.state.cam.x;
        this.state.startCamY = this.state.cam.y;
    }
  },

  handleTouchMove(e) {
    e.preventDefault();
    if (this.state.animationId) {
        cancelAnimationFrame(this.state.animationId);
        this.state.animationId = null;
    }

    if (this.state.touchMode === 'pan' && e.touches.length === 1) {
        const t = e.touches[0];
        this.state.cam.x += t.clientX - this.state.lastX;
        this.state.cam.y += t.clientY - this.state.lastY;
        this.state.lastX = t.clientX; this.state.lastY = t.clientY;
        this.clampCamera();
    } else if (this.state.touchMode === 'pinch' && e.touches.length === 2) {
        const [a,b] = e.touches;
        const dist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);

        if (this.state.startDist === 0) {
            return; 
        }

        let newScale = this.state.startScale * (dist / this.state.startDist);
        
        this.state.cam.scale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct/100 * this.config.baseScale, newScale));
        if (isNaN(this.state.cam.scale)) this.state.cam.scale = this.state.startScale; 

        const safeStartScale = (this.state.startScale === 0 || isNaN(this.state.startScale)) ? this.state.minFitScale : this.state.startScale;

        const wx = (this.state.pinchCenter.x - this.state.startCamX) / safeStartScale;
        const wy = (this.state.pinchCenter.y - this.state.startCamY) / safeStartScale;

        if (isNaN(wx) || isNaN(wy)) { 
             this.state.cam.x = this.state.startCamX;
             this.state.cam.y = this.state.startCamY;
        } else {
            this.state.cam.x = this.state.pinchCenter.x - wx * this.state.cam.scale;
            this.state.cam.y = this.state.pinchCenter.y - wy * this.state.cam.scale;
        }
        this.clampCamera();
    }
  },

  handleTouchEnd(e) {
    if (this.state.touchMode === 'pan' && e.changedTouches.length === 1) {
      const t = e.changedTouches[0];
      const dist = Math.hypot(t.clientX - this.state.clickStartX, t.clientY - this.state.clickStartY);
      const duration = performance.now() - this.state.touchStartTime;
      if (duration < 200 && dist < 10) {
          const [worldX, worldY] = this.screenToWorld(t.clientX, t.clientY);
          if (worldX >= 0 && worldX < this.config.N && worldY >= 0 && worldY < this.config.N) {
              const building = this.getBuildingAt(worldX, worldY);
              this.state.selection = building || { x: worldX, y: worldY };
              if(this.state.selection) this.state.selection.pingStart = performance.now(); 
              if(this.dom.inpX && this.state.selection) this.dom.inpX.value = this.state.selection.x;
              if(this.dom.inpY && this.state.selection) this.dom.inpY.value = this.state.selection.y;
          }
      }
    }
    if (e.touches.length < 2) this.state.touchMode = null;
  },

  doSearch() {
    if(!this.dom.inpX || !this.dom.inpY) return;
    const x = +this.dom.inpX.value, y = +this.dom.inpY.value;
    if (x >= 0 && y >= 0 && x < this.config.N && y < this.config.N) {
      this.state.selection = this.getBuildingAt(x, y) || { x, y };
      if(this.state.selection) this.state.selection.pingStart = performance.now(); 
      const targetScale = (150 / 100) * this.config.baseScale;
      const [screenX, screenY] = this.worldToScreen(x, y);
      const targetCamX = this.dom.canvas.width/2 - screenX * targetScale;
      const targetCamY = this.dom.canvas.height/2 - screenY * targetScale;
      this.animatePanZoom(targetScale, targetCamX, targetCamY); 
    }
  },
  
  centerOn(x,y) {
    const [lx, ly] = this.worldToScreen(x,y);
    this.state.cam.x = this.dom.canvas.width*0.5 - lx*this.state.cam.scale;
    this.state.cam.y = this.dom.canvas.height*0.5 - ly*this.state.cam.scale;
    this.clampCamera();
  },
  
  zoomToFit() {
    const targetScale = this.state.minFitScale;
    const targetCamX = this.dom.canvas.width / 2;
    const targetCamY = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * targetScale;
    this.animatePanZoom(targetScale, targetCamX, targetCamY, 200); 
  },
  
  resize() {
    this.dom.canvas.width  = window.innerWidth;
    this.dom.canvas.height = window.innerHeight;
    
    if (this.dom.minimapCanvas) { 
        const dpr = window.devicePixelRatio || 1;
        this.dom.minimapCanvas.width = this.config.minimap.width * dpr;
        this.dom.minimapCanvas.height = this.config.minimap.height * dpr;
        this.calculateBaseMinimapScale(); 
    }

    const mapTotalWidth = (this.config.N - 1) * this.config.tileW;
    const mapTotalHeight = (this.config.N - 1) * this.config.tileH;

    const safeMapTotalWidth = Math.max(1, mapTotalWidth);
    const safeMapTotalHeight = Math.max(1, mapTotalHeight);

    const scaleX = this.dom.canvas.width / safeMapTotalWidth;
    const scaleY = this.dom.canvas.height / safeMapTotalHeight;
    
    let calculatedMinFit = Math.min(scaleX, scaleY) * 0.95; 
    this.state.minFitScale = Math.max(0.1, calculatedMinFit); // Using 0.1 as a practical minimum
    if (isNaN(this.state.minFitScale)) {
        this.state.minFitScale = 0.1; 
    }
    
    if (this.state.isInitialLoad) {
        this.state.cam.scale = this.state.minFitScale; 
        this.state.cam.x = this.dom.canvas.width / 2;
        this.state.cam.y = this.dom.canvas.height / 2 + ((this.config.N - 1) * this.config.tileH / 2) * this.state.cam.scale;
        this.clampCamera(); 
        this.state.isInitialLoad = false;
    } else {
        this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
        if(isNaN(this.state.cam.scale)) { 
             this.state.cam.scale = this.state.minFitScale; 
        }
        this.clampCamera();
    }
  },

  clampCamera() {
    const s = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const canvasW = this.dom.canvas.width;
    const canvasH = this.dom.canvas.height;
    
    const mapScreenW = (this.config.N - 1) * this.config.tileW * s;
    const mapScreenH = (this.config.N - 1) * this.config.tileH * s;

    if (mapScreenW > canvasW) {
        const minCamX = canvasW - mapScreenW / 2;
        const maxCamX = mapScreenW / 2;
        this.state.cam.x = Math.max(minCamX, Math.min(maxCamX, this.state.cam.x));
    } else {
        this.state.cam.x = canvasW / 2;
    }

    if (mapScreenH > canvasH) {
        const minCamY = canvasH; 
        const maxCamY = mapScreenH; 
        this.state.cam.y = Math.max(minCamY, Math.min(maxCamY, this.state.cam.y));
    } else {
        this.state.cam.y = canvasH / 2 + mapScreenH / 2;
    }
    if(isNaN(this.state.cam.x)) this.state.cam.x = canvasW / 2; 
    if(isNaN(this.state.cam.y)) this.state.cam.y = canvasH / 2; 
  },

  changeZoomBy(delta) {
    let currentPct = (this.state.cam.scale / this.config.baseScale) * 100;
    if(isNaN(currentPct)) currentPct = (this.state.minFitScale / this.config.baseScale) * 100;

    const changeAmt = delta > 0 ? currentPct * 0.25 : currentPct * -0.2;
    let targetScale = ((currentPct + changeAmt) / 100) * this.config.baseScale;
    targetScale = Math.max(this.state.minFitScale, Math.min(this.config.maxPct / 100 * this.config.baseScale, targetScale));
    if(isNaN(targetScale)) targetScale = this.state.cam.scale; 

    const cx = this.dom.canvas.width / 2, cy = this.dom.canvas.height / 2;
    this.animateZoom(targetScale, cx, cy, 150); 
  },

  animateZoom(targetScale, anchorX, anchorY, duration=150) {
    if (this.state.animationId) {
        cancelAnimationFrame(this.state.animationId);
    }
    const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const startX = this.state.cam.x, startY = this.state.cam.y;
    const start = performance.now();

    if (startScale === 0) { 
        console.error("animateZoom called with startScale 0");
        this.state.cam.scale = targetScale; 
        this.clampCamera();
        return;
    }

    const wx = (anchorX - startX)/startScale;
    const wy = (anchorY - startY)/startScale;

    if (isNaN(wx) || isNaN(wy)) { 
        this.state.cam.scale = targetScale;
        this.clampCamera();
        return;
    }

    const step = (now) => {
      const t = duration === 0 ? 1 : Math.min(1, (now - start)/duration);
      const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; // easeInOutCubic
      this.state.cam.scale = startScale + (targetScale - startScale)*k;
      this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale); 
      if(isNaN(this.state.cam.scale)) this.state.cam.scale = startScale; 

      this.state.cam.x = anchorX - wx * this.state.cam.scale;
      this.state.cam.y = anchorY - wy * this.state.cam.scale;
      this.clampCamera();
      if (t < 1) {
          this.state.animationId = requestAnimationFrame(step);
      } else {
          this.state.animationId = null;
      }
    };
    this.state.animationId = requestAnimationFrame(step);
  },

  animatePanZoom(targetScale, targetX, targetY, duration=300) {
    if (this.state.animationId) {
        cancelAnimationFrame(this.state.animationId);
    }
    const startScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const startX = this.state.cam.x, startY = this.state.cam.y;
    const start = performance.now();
    const step = (now) => {
        const t = Math.min(1, (now - start)/duration);
        const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; // easeInOutCubic
        this.state.cam.scale = startScale + (targetScale - startScale)*k;
        this.state.cam.scale = Math.max(this.state.minFitScale, this.state.cam.scale);
        if(isNaN(this.state.cam.scale)) this.state.cam.scale = startScale; 

        this.state.cam.x = startX + (targetX - startX)*k;
        this.state.cam.y = startY + (targetY - startY)*k;
        this.clampCamera();
        if (t < 1) {
            this.state.animationId = requestAnimationFrame(step);
        } else {
            this.state.animationId = null;
        }
    };
    this.state.animationId = requestAnimationFrame(step);
  },
  
  updateFloatingZoomLabel() {
    if(!this.dom.zoomSlider || !this.dom.floatingZoomLabel) return;
    const slider = this.dom.zoomSlider;
    const label = this.dom.floatingZoomLabel;
    const min = parseInt(slider.min, 10);
    const max = parseInt(slider.max, 10);
    const val = parseInt(slider.value, 10);

    if (max === min) { 
        label.style.display = 'none';
        return;
    }

    const percent = (val - min) / (max - min);
    const thumbHeight = 15;
    const trackHeight = slider.offsetHeight;
    const topPos = (1 - percent) * (trackHeight - thumbHeight) + (thumbHeight / 2);
    label.style.top = `${topPos}px`;
    label.textContent = `Zoom: ${val}%`;
    label.style.display = 'block';
    clearTimeout(this.state.hideLabelTimeout);
    this.state.hideLabelTimeout = setTimeout(() => { label.style.display = 'none'; }, 1500);
  },

  handleMinimapClick(e) {
    if (!this.dom.minimapCanvas) return;
    const { minimap, N } = this.config;
    const dpr = window.devicePixelRatio || 1;
    const rect = this.dom.minimapCanvas.getBoundingClientRect();
    const clickX = (e.clientX - rect.left) * dpr; 
    const clickY = (e.clientY - rect.top) * dpr;

    const padding = minimap.padding * dpr;
    const minimapScale = this.state.minimapActualScale;

    if (minimapScale <= 0) { // Prevent division by zero if minimap scale is bad
        console.error("Minimap scale is zero or negative, cannot process click.");
        return;
    }

    // Calculate click position relative to the minimap's visible world area's top-left
    let localClickedWorldX = (clickX - padding) / minimapScale;
    let localClickedWorldY = (clickY - padding) / minimapScale;

    // Add the minimap's current world offset to get the absolute world coordinates
    let worldX = localClickedWorldX + this.state.minimapWorldOffsetX;
    let worldY = localClickedWorldY + this.state.minimapWorldOffsetY;

    // Clamp to map boundaries and optionally round
    worldX = Math.max(0, Math.min(N - 1, Math.round(worldX)));
    worldY = Math.max(0, Math.min(N - 1, Math.round(worldY)));

    const [screenX, screenY] = this.worldToScreen(worldX, worldY);
    const targetCamX = this.dom.canvas.width / 2 - screenX * this.state.cam.scale;
    const targetCamY = this.dom.canvas.height / 2 - screenY * this.state.cam.scale;
    this.animatePanZoom(this.state.cam.scale, targetCamX, targetCamY, 200);
  },

    drawMinimap(mainViewBounds) {
    if (!this.dom.minimapCtx || this.state.baseMinimapScale <= 0) return;

    const mmCtx = this.dom.minimapCtx;
    const { minimap, N, biomeRegions, biomeColors, baseScale: mainBaseScale } = this.config;
    const { cam: mainCam, baseMinimapScale } = this.state;
    const dpr = window.devicePixelRatio || 1;
    const canvasWidth = this.dom.minimapCanvas.width;
    const canvasHeight = this.dom.minimapCanvas.height;
    const mPadding = minimap.padding * dpr;

    // --- Dynamic Minimap Zoom Logic ---
    const mainZoomRatio = mainCam.scale / mainBaseScale; // How zoomed in is main map (e.g., 1.0 = base, >1 = zoomed in)
    let currentMinimapZoomFactor = minimap.zoomFactorMin;
    const mainMapRatioForMinimapMaxZoom = 2.0;     
    if (mainZoomRatio > minimap.mainMapZoomThresholdForMinimapZoom) {
        const maxMainZoomRatio = this.config.maxPct / 100;
        let progress = (mainZoomRatio - minimap.mainMapZoomThresholdForMinimapZoom) / 
                       (maxMainZoomRatio - minimap.mainMapZoomThresholdForMinimapZoom);
        progress = Math.max(0, Math.min(1, progress)); // Clamp 0-1
        currentMinimapZoomFactor = minimap.zoomFactorMin + progress * (minimap.zoomFactorMax - minimap.zoomFactorMin);
    }
    
    const mScale = baseMinimapScale * currentMinimapZoomFactor;
    this.state.minimapActualScale = mScale; // Add this line
    // --- End Dynamic Minimap Zoom Logic ---


      mmCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      mmCtx.fillStyle = minimap.bgColor;
      mmCtx.fillRect(0, 0, canvasWidth, canvasHeight);

      // Determine the world coordinates for the center of the minimap view
      const [minimapViewCenterX, minimapViewCenterY] = this.screenToWorld(this.dom.canvas.width / 2, this.dom.canvas.height / 2);
      const minimapWorldWidthVisible = (canvasWidth - 2 * mPadding) / mScale;        
      const minimapWorldHeightVisible = (canvasHeight - 2 * mPadding) / mScale;
      
      const worldOffsetX = minimapViewCenterX - (minimapWorldWidthVisible / 2);
      const worldOffsetY = minimapViewCenterY - (minimapWorldHeightVisible / 2);

      this.state.minimapWorldOffsetX = worldOffsetX; // <--- ADD THIS LINE
      this.state.minimapWorldOffsetY = worldOffsetY; // <--- ADD THIS LINE

      // --- Corrected Biome Drawing Section ---
      const biomeDrawOrder = ['badlands', 'plains', 'fertile']; // Define your draw order
      for (const biomeName of biomeDrawOrder) { // Iterate using the defined order
          if (biomeRegions[biomeName]) { 
              const region = biomeRegions[biomeName];
              mmCtx.fillStyle = biomeColors[biomeName];
              const x = mPadding + (region.x1 - worldOffsetX) * mScale;
              const y = mPadding + (region.y1 - worldOffsetY) * mScale;
              const w = (region.x2 - region.x1 + 1) * mScale;
              const h = (region.y2 - region.y1 + 1) * mScale;
              mmCtx.fillRect(x, y, w, h);
          }
      }
    
    // Draw Key Buildings, offset by minimap's view
    (this.state.baseMap.defaultBuildings || []).forEach(b => {
        let buildingFillStyle = null;
        if (b.displayName === "King's Castle") {
            buildingFillStyle = minimap.kingCastleColor;
        } else if (b.displayName.startsWith("Fortress")) {
            buildingFillStyle = this.config.ALLIANCE_RSS_STYLES.stone.borderColor; 
        }
        
        if(buildingFillStyle){
            mmCtx.fillStyle = buildingFillStyle;
            const bx = mPadding + (b.x - worldOffsetX) * mScale;
            const by = mPadding + (b.y - worldOffsetY) * mScale;
            const bw = Math.max(1 * dpr, b.w * mScale); 
            const bh = Math.max(1 * dpr, b.h * mScale); 
            mmCtx.fillRect(bx, by, bw, bh);
        }
    });

    // Draw Viewport Rectangle (mainViewBounds are already world coords)
    if (mainViewBounds && !isNaN(mainViewBounds.minX) && !isNaN(mainViewBounds.minY) && !isNaN(mainViewBounds.maxX) && !isNaN(mainViewBounds.maxY)) {
        const vx = mPadding + (mainViewBounds.minX - worldOffsetX) * mScale;
        const vy = mPadding + (mainViewBounds.minY - worldOffsetY) * mScale;
        const vw = (mainViewBounds.maxX - mainViewBounds.minX) * mScale;
        const vh = (mainViewBounds.maxY - mainViewBounds.minY) * mScale;

        if (vw > 0 && vh > 0) { 
            mmCtx.fillStyle = minimap.viewportFillColor;
            mmCtx.fillRect(vx, vy, vw, vh);
            mmCtx.strokeStyle = minimap.viewportBorderColor;
            mmCtx.lineWidth = 1 * dpr;
            mmCtx.strokeRect(vx, vy, vw, vh);
        }
    }
  },

  drawTile(x, y, drawBorder = true) {
    this.state.tileCount++;
    const [sx,sy] = this.worldToScreen(x,y);
    const { config } = this;
    const ctx = this.dom.ctx;
    ctx.beginPath();
    ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
    ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
    ctx.closePath();

    ctx.fillStyle = config.biomeColors[this.getBiomeForTile(x, y)];
    ctx.fill();
    if (drawBorder) ctx.stroke();

    const building = this.getBuildingAt(x, y);
    if (building && building.hideCoordinates) return;

    const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const pct = Math.round((currentCamScale / config.baseScale) * 100);
    const showCoords = this.dom.coordsToggle ? this.dom.coordsToggle.checked : false;
    const showThreshold = showCoords ? 80 : 200;

    if (pct <= showThreshold) return;
    
    const text = `${x}, ${y}`;
    let optimalFontSize = Math.min(
      config.tileH * 0.8 * 0.5,
      (config.tileW * 0.8 / (text.length || 1)) * 1.8 
    ) * 0.7;
    if ((optimalFontSize * currentCamScale) < 5) return;

    ctx.fillStyle = config.textColor;
    ctx.font = `${optimalFontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, sx, sy);
  },

  drawChunk(chunk, drawBorder = true) {
    this.state.tileCount += chunk.size * chunk.size;
    const { x, y, size, biome } = chunk;
    const { config } = this;
    const ctx = this.dom.ctx;
    const currentCamScale = (isNaN(this.state.cam.scale) || this.state.cam.scale === 0) ? this.state.minFitScale : this.state.cam.scale;
    const inflation = drawBorder || currentCamScale === 0 ? 0 : (1 / currentCamScale); 
    const x0 = x, y0 = y, w = size, h = size;
    const [sbx, sby] = this.worldToScreen(x0, y0);
    const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
    const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1);
    const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
    const p_bottom = { x: sbx, y: sby + config.tileH/2 + inflation };
    const p_right  = { x: srx + config.tileW/2 + inflation, y: sry };
    const p_top    = { x: stx, y: sty - config.tileH/2 - inflation };
    const p_left   = { x: slx - config.tileW/2 - inflation, y: sly };
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y);
    ctx.closePath();
    ctx.fillStyle = config.biomeColors[biome];
    ctx.fill();
    if (drawBorder) ctx.stroke();
  },
  
  drawBuildingFootprint(b, highlightStyle = null, drawBorder = true) {
    const { config, state } = this;
    const ctx = this.dom.ctx;
    const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
    const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
    const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
    const [sbx, sby] = this.worldToScreen(x0, y0);
    const [srx, sry] = this.worldToScreen(x0 + w - 1, y0);
    const [stx, sty] = this.worldToScreen(x0 + w - 1, y0 + h - 1);
    const [slx, sly] = this.worldToScreen(x0, y0 + h - 1);
    const p_bottom = { x: sbx, y: sby + config.tileH/2 };
    const p_right  = { x: srx + config.tileW/2, y: sry };
    const p_top    = { x: stx, y: sty - config.tileH/2 };
    const p_left   = { x: slx - config.tileW/2, y: sly };
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x, p_top.y); ctx.lineTo(p_left.x, p_left.y);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = border; 
    ctx.lineWidth = highlightStyle ? config.strokeW * 2 : config.strokeW;
    if (drawBorder) ctx.stroke();

    const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
    if (currentCamScale > 0.4 && b.displayName) {
      const availableWidth = (p_right.x - p_left.x) * 0.8;
      const availableHeight = p_bottom.y - p_top.y;
      if (availableWidth < 10 || availableHeight < 10) return;
      const hasCoords = b.displayCoordinates;
      const heightFactor = hasCoords ? 0.5 : 1.0; 
      const fontSizeBasedOnHeight = (availableHeight * heightFactor) * 0.9;
      ctx.font = `bold 100px sans-serif`; 
      const textMetrics = ctx.measureText(b.displayName);
      const displayNameWidth = textMetrics.width || 1; 
      const fontSizeBasedOnWidth = (availableWidth / displayNameWidth) * 100;
      const optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);

      if (optimalFontSize * currentCamScale < 7) return;
      const centerX = (p_left.x + p_right.x) / 2;
      const yOffset = hasCoords ? optimalFontSize * -0.45 : 0;
      const centerY = (p_top.y + p_bottom.y) / 2 + yOffset;
      ctx.fillStyle = config.textColor;
      ctx.font = `bold ${optimalFontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.displayName, centerX, centerY);
      if (b.displayCoordinates) {
        const coordFontSize = optimalFontSize * 0.7;
        ctx.font = `${coordFontSize}px sans-serif`;
        ctx.fillText(`(X${b.x}, Y${b.y})`, centerX, centerY + optimalFontSize * 0.9);
      }
    }
  },

  mainLoop(now) {
    const { dom, state, config } = this;
    const ctx = dom.ctx; 
    
    try {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,dom.canvas.width,dom.canvas.height);

        const [centerX, centerY] = this.screenToWorld(dom.canvas.width/2, dom.canvas.height/2);
        if(dom.centerTileEl) dom.centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
        
        const currentCamScale = (isNaN(state.cam.scale) || state.cam.scale === 0) ? state.minFitScale : state.cam.scale;
        const pct = Math.round((currentCamScale / config.baseScale) * 100);

        if(dom.zoomLevelEl) dom.zoomLevelEl.textContent = `Zoom: ${pct}%`;
        if(dom.zoomSlider) {
            // Ensure slider min/max are valid before setting value
            const sliderMin = parseInt(dom.zoomSlider.min,10);
            const sliderMax = parseInt(dom.zoomSlider.max,10);
            if (pct > sliderMax) dom.zoomSlider.max = pct.toString();
            // Only set min if pct is less AND it doesn't make min > max
            if (pct < sliderMin && pct < sliderMax) dom.zoomSlider.min = pct.toString(); 
            else if (sliderMin > sliderMax) dom.zoomSlider.min = sliderMax.toString(); // Correct if min > max

            if (pct >= parseInt(dom.zoomSlider.min,10) && pct <= parseInt(dom.zoomSlider.max,10)) {
                 dom.zoomSlider.value = pct.toString();
            } else if (pct < parseInt(dom.zoomSlider.min,10)) {
                 dom.zoomSlider.value = dom.zoomSlider.min;
            } else {
                 dom.zoomSlider.value = dom.zoomSlider.max;
            }
        }
        state.tileCount = 0;

        ctx.save();
        ctx.setTransform(currentCamScale,0,0,currentCamScale,state.cam.x,state.cam.y);
        ctx.strokeStyle = config.borderColor;
        ctx.lineWidth = config.strokeW;
        
        const [tl_x, tl_y] = this.screenToWorld(0, 0);
        const [tr_x, tr_y] = this.screenToWorld(dom.canvas.width, 0);
        const [bl_x, bl_y] = this.screenToWorld(0, dom.canvas.height);
        const [br_x, br_y] = this.screenToWorld(dom.canvas.width, dom.canvas.height);
        const viewBounds = { 
          minX: Math.min(tl_x, tr_x, bl_x, br_x) - 2,
          maxX: Math.max(tl_x, tr_x, bl_x, br_x) + 2,
          minY: Math.min(tl_y, tr_y, bl_y, br_y) - 2,
          maxY: Math.max(tl_y, tr_y, bl_y, br_y) + 2,
        };

        if (isNaN(viewBounds.minX) || isNaN(viewBounds.maxX) || isNaN(viewBounds.minY) || isNaN(viewBounds.maxY)) {
            console.error("View bounds are NaN, skipping render cycle. Cam State:", state.cam, "Calculated Bounds:", viewBounds);
            ctx.restore();
            this.drawMinimap(null); 
            requestAnimationFrame(this.mainLoop.bind(this));
            return;
        }

        const chunkLevel = this.getChunkLevelForZoom(pct);
        const showGrid = dom.gridlinesToggle ? dom.gridlinesToggle.checked : false;
        const showRss = dom.allianceRssToggle ? dom.allianceRssToggle.checked : false;
        const alwaysShowRss = dom.allianceRssAlwaysVisibleToggle ? dom.allianceRssAlwaysVisibleToggle.checked : false;

        if (chunkLevel === -1) {
          const shouldDrawBorders = showGrid && pct > 50;
          const minSum = Math.floor(viewBounds.minX + viewBounds.minY);
          const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);
          for (let sum = minSum; sum <= maxSum; sum++) {
            const startXCoord = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY)));
            const endXCoord = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));
            for (let x = startXCoord; x <= endXCoord; x++) {
                const y = sum - x;
                if (x < 0 || x >= config.N || y < 0 || y >= config.N) continue;
                if (!this.getBuildingAt(x, y)) this.drawTile(x, y, shouldDrawBorders);
            }
          }
          state.allBuildings
            .filter(b => 
              (!b.isRss || showRss) && 
              !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)
            )
            .forEach(b => this.drawBuildingFootprint(b, null, shouldDrawBorders));
          ctx.fillStyle = '#444';
          (state.baseMap.unoccupiableTiles || []).forEach(([x,y])=>{
            if (this.getBuildingAt(x, y)) return;
            if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
            const [sx,sy] = this.worldToScreen(x,y);
            ctx.beginPath();
            ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
            ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
            ctx.closePath(); ctx.fill();
          });
        } else { 
          if (state.chunkLevels && state.chunkLevels[chunkLevel]) {
            const chunksToDraw = state.chunkLevels[chunkLevel];
            const chunkSize = Math.pow(2, chunkLevel + 1);
            const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize;
            const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
            const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize;
            const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
            for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
              for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
                  const chunk = chunksToDraw.get(`${x},${y}`);
                  if (chunk) this.drawChunk(chunk, false);
              }
            }
          }
          (state.baseMap.defaultBuildings || [])
            .filter(b => !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY))
            .forEach(b => this.drawBuildingFootprint(b, null, false));
          if (showRss && alwaysShowRss) {
            state.allBuildings
              .filter(b => 
                b.isRss && 
                !(b.x > viewBounds.maxX || b.x + b.w - 1 < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h - 1 < viewBounds.minY)
              )
              .forEach(b => this.drawBuildingFootprint(b, null, false));
          }
          if (chunkLevel < 2) {
              ctx.fillStyle = '#444';
              (state.baseMap.unoccupiableTiles || []).forEach(([x,y])=>{
                if (this.getBuildingAt(x, y)) return;
                if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
                const [sx,sy] = this.worldToScreen(x,y);
                ctx.beginPath();
                ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
                ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
                ctx.closePath(); ctx.fill();
              });
          }
        }

        if (state.selection) { 
            let highlightColor = config.selectionColor;
            if (state.selection.pingStart && now - state.selection.pingStart < config.pingDuration) {
                if (Math.floor((now - state.selection.pingStart) / 100) % 2 === 0) {
                    highlightColor = config.pingColor;
                }
            }
            if (state.selection.w) { 
              this.drawBuildingFootprint(state.selection, highlightColor, true);
            } else { 
              const [sx, sy] = this.worldToScreen(state.selection.x, state.selection.y);
              ctx.beginPath();
              ctx.moveTo(sx, sy - config.tileH/2); ctx.lineTo(sx + config.tileW/2, sy);
              ctx.lineTo(sx, sy + config.tileH/2); ctx.lineTo(sx - config.tileW/2, sy);
              ctx.closePath();
              ctx.strokeStyle = highlightColor;
              ctx.lineWidth = config.strokeW * 1.5;
              ctx.stroke();
            }
        }
        
        ctx.restore(); 

        this.drawMinimap(viewBounds);

        const dt  = now - state.lastFrame;
        state.lastFrame = now;
        if (dt > 0) { 
            state.lastFPS   = Math.round(1000/dt);
        }
        state.lastTiles = state.tileCount;
        
        if (now - state.statsUpdateTime > 500) { 
          if(dom.statsFPSEl) dom.statsFPSEl.textContent   = `FPS:   ${state.lastFPS}`;
          if(dom.statsTilesEl) dom.statsTilesEl.textContent = `Tiles: ${state.lastTiles}`;
          state.statsUpdateTime = now; 
        }

    } catch (error) {
        console.error("Error in mainLoop:", error);
    }
    
    requestAnimationFrame(this.mainLoop.bind(this));
  }
};

KingshotPlanner.init();

</script>
</body>
</html>