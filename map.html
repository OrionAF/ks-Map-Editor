<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kingshot map editor & planner</title>
<style>
    body {
      margin:0; background:#111; overflow:hidden;
      -webkit-user-select:none; user-select:none;
    }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }

    /* UI Container - MOVED to top-right */
    #searchBox {
      position:absolute; top:10px; right:10px; z-index:10;
      color:#fff; font-family:sans-serif;
      background:rgba(0,0,0,0.6); padding:8px; border-radius:4px;
      text-align: right;
    }
    #searchBox input { width:60px; }
    #searchBox button {
      margin:2px 4px 2px 0;
      -webkit-user-select:none; user-select:none;
    }
    
    /* Center Tile Display - MOVED to bottom-center */
    #centerTile {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 4px;
      color:#fff; font-family:sans-serif;
      font-size:14px;
      -webkit-user-select:none; user-select:none;
      z-index: 10;
    }

    /* Coords Toggle Label Style */
    label.coords-label {
        font-size: 13px;
        vertical-align: middle;
        user-select: none;
    }
    #searchBox > div { margin-top: 4px; }


    /* Info & Stats panels */
    #infoBtn, #statsBtn {
      margin-top:6px; -webkit-user-select:none; user-select:none;
    }
    #infoPanel, #statsPanel {
      max-height:0; overflow:hidden;
      transition:max-height 0.3s ease;
      margin-top:6px;
      background:rgba(58,55,55,0.85);
      padding:0 6px; border-radius:4px;
      font-size:13px; color:#ddd;
      text-align: left;
    }
    #infoPanel.open { max-height:160px; } /* Increased height for patch notes button */
    #statsPanel.open { max-height:120px; }
    #infoPanel h4 { margin:6px 0 4px; color:#fff; }
    #infoPanel ul { padding-left:16px; margin:0 }
    #infoPanel li { margin-bottom:4px; }
    #statsPanel div { margin:4px 0; color:#fff; }


    /* --- NEW STYLES for Vertical Zoom Controls (LEFT) --- */
    #zoomControlsContainer {
      position: absolute;
      left: 10px;
      top: auto;
      /*transform: translateY(10%);*/
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px; /* Reduced gap */
      padding: 15px 10px;
      border-radius: 4px;
      z-index: 10;
      color: #fff;
      font-family: sans-serif;
    }
    
    #zoomControlsContainer #presetButtons {
      display: flex;
      flex-direction: column;
      gap: 5px;
      order: 4;
    }

    #zoomControlsContainer button {
      -webkit-user-select:none; user-select:none;
      margin: 0;
      width: 60px;
    }

    #zoomControlsContainer #zoomInc { order: 1; }
    #zoomControlsContainer #sliderWrapper { order: 2; position: relative; }
    #zoomControlsContainer #zoomDec { order: 3; }
    #zoomControlsContainer #zoomLevel { order: 5; font-size: 14px; margin-top: 5px; }


    #zoomSlider {
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      /* Inverting for JS logic: In HTML, a higher value is at the top. */
      writing-mode: bt-lr; 
      height: 65vh; /* Use 50% of the viewport height */
      max-height: 65%;
      width: auto;
      margin: 0;
    }

    #floatingZoomLabel {
        position: absolute;
        display: none;
        left: 25px;
        background-color: #0b508f;
        color: white;
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 13px;
        pointer-events: none;
        transform: translateY(-50%);
    }

    /* --- NEW STYLES for Version Display & Patch Notes --- */
    #versionDisplay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: sans-serif;
        font-size: 12px;
        user-select: none;
        z-index: 10;
    }

    #modalOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 999;
    }

    #patchNotesModal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        background: #2c2c2c;
        color: #eee;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    .patch-notes-header {
        padding: 15px;
        border-bottom: 1px solid #444;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .patch-notes-header h3 { margin: 0; }
    .patch-notes-header .close-btn {
        background: none;
        border: none;
        color: #ccc;
        font-size: 24px;
        cursor: pointer;
    }
    .patch-notes-body {
        padding: 15px;
        max-height: 60vh;
        overflow-y: auto;
    }
    .patch-notes-body ul {
        padding-left: 20px;
        margin: 0;
    }
    .patch-notes-body li { margin-bottom: 8px; }
    .patch-notes-footer {
        padding: 10px 15px;
        border-top: 1px solid #444;
        background: #333;
        border-radius: 0 0 8px 8px;
    }
    .patch-notes-footer label { user-select: none; font-size: 14px; }

  </style>
</head>
<body>
  <!-- Search and info panel moved to top right -->
  <div id="searchBox">
    <div>
        X: <input id="inpX" type="number" min="0" max="1199" value="0">
        Y: <input id="inpY" type="number" min="0" max="1199" value="0">
        <button id="btnGo">Go</button>
    </div>
    <div>
      <input type="checkbox" id="coordsToggle">
      <label for="coordsToggle" class="coords-label">Show Coords >80%</label>
    </div>
    <div>
      <button id="infoBtn" title="Show controls">ℹ️</button>
      <button id="statsBtn" title="Toggle stats">⚙️</button>
    </div>
    <div id="infoPanel">
      <h4>Controls</h4>
      <ul>
        <li><strong>Pan</strong>: drag / one-finger touch</li>
        <li><strong>Zoom</strong>: wheel, slider, +/–, q/e, dblclick</li>
        <li><strong>Pinch</strong>: two-finger touch</li>
        <li><strong>Keyboard</strong>: arrows to pan</li>
      </ul>
      <button id="patchNotesBtn">Patch Notes</button>
    </div>
    <div id="statsPanel">
      <div id="statsFPS">FPS: –</div>
      <div id="statsTiles">Tiles: –</div>
    </div>
  </div>

  <!-- Vertically oriented zoom controls moved to left -->
  <div id="zoomControlsContainer">
    <button id="zoomInc">+</button>
    <div id="sliderWrapper">
        <input id="zoomSlider" type="range" min="1" max="100" step="1" value="100">
        <div id="floatingZoomLabel"></div>
    </div>
    <button id="zoomDec">−</button>
    <div id="presetButtons">
        <button data-zoom="Fit">Fit</button>
        <button data-zoom="50">50%</button>
        <button data-zoom="75">75%</button>
        <button data-zoom="100">100%</button>
    </div>
    <div id="zoomLevel">Zoom: 100%</div>
  </div>
  
  <div id="centerTile">Center: X0 Y0</div>
  <div id="versionDisplay"></div>
  
  <!-- Patch Notes Modal -->
  <div id="modalOverlay"></div>
  <div id="patchNotesModal">
      <div class="patch-notes-header">
          <h3>What's New</h3>
          <button id="closePatchNotesBtn" class="close-btn">×</button>
      </div>
      <div class="patch-notes-body" id="patchNotesBody">
          <!-- Content will be injected by JS -->
      </div>
      <div class="patch-notes-footer">
          <input type="checkbox" id="hidePatchNotesCheckbox">
          <label for="hidePatchNotesCheckbox">Do not show this again until the next update.</label>
      </div>
  </div>


  <canvas id="map"></canvas>

<script>
// —— CONFIG ——
  const CURRENT_VERSION = '0.2.5.1';
  const N           = 1200,
        tileW       = 10, tileH = 10,
        strokeW     = 0.3, 
        borderColor = '#000', 
        textColor   = '#fff',
        maxPct      = 1000,
        selectionColor = '#ff0';
  
  const baseScale = 5;

  const patchNotes = {
    '0.2.5.1': [
      "Redesigned UI layout for improved usability.",
      "Added a vertical zoom slider on the left.",
      "Implemented a configurable display for tile coordinates.",
      "Fixed building name text overflowing its container.",
      "Added this patch notes window and versioning system."
    ]
  };

  const biomeColors = {
    fertile:  'rgb(109, 159, 62)',
    plains:   'rgb(158, 180, 103)',
    badlands: 'rgb(191, 208, 152)'
  };
  
  const biomeRegions = {
      fertile:  { x1: 480, y1: 480, x2: 719, y2: 719 },
      plains:   { x1: 320, y1: 320, x2: 879, y2: 879 },
      badlands: { x1: 0,   y1: 0,   x2: 1199,y2: 1199}
  };
  // ——————————

  // DOM refs
  const canvas       = document.getElementById('map');
  const ctx          = canvas.getContext('2d');
  const inpX         = document.getElementById('inpX');
  const inpY         = document.getElementById('inpY');
  const btnGo        = document.getElementById('btnGo');
  const zoomLevelEl  = document.getElementById('zoomLevel');
  const zoomDecBtn   = document.getElementById('zoomDec');
  const zoomIncBtn   = document.getElementById('zoomInc');
  const zoomSlider   = document.getElementById('zoomSlider');
  const presetBtns   = document.querySelectorAll('#presetButtons button');
  const centerTileEl = document.getElementById('centerTile');
  const infoBtn      = document.getElementById('infoBtn');
  const infoPanel    = document.getElementById('infoPanel');
  const statsBtn     = document.getElementById('statsBtn');
  const statsPanel   = document.getElementById('statsPanel');
  const statsFPSEl   = document.getElementById('statsFPS');
  const statsTilesEl = document.getElementById('statsTiles');
  const coordsToggle      = document.getElementById('coordsToggle');
  const floatingZoomLabel = document.getElementById('floatingZoomLabel');
  
  // NEW DOM Refs for Patch Notes
  const versionDisplay        = document.getElementById('versionDisplay');
  const patchNotesBtn         = document.getElementById('patchNotesBtn');
  const modalOverlay          = document.getElementById('modalOverlay');
  const patchNotesModal       = document.getElementById('patchNotesModal');
  const patchNotesBody        = document.getElementById('patchNotesBody');
  const closePatchNotesBtn    = document.getElementById('closePatchNotesBtn');
  const hidePatchNotesCheckbox= document.getElementById('hidePatchNotesCheckbox');


  // toggle panels
  infoBtn.addEventListener('click', ()=>infoPanel.classList.toggle('open'));
  statsBtn.addEventListener('click', ()=>statsPanel.classList.toggle('open'));

  // data layers
  let baseMap = { unoccupiableTiles:[], defaultBuildings:[] };
  const buildingMap = new Map();
  const chunkLevels = []; 

  function preProcessBuildings() {
    buildingMap.clear();
    const allBuildings = [...baseMap.defaultBuildings, ...userBuildings];
    for (const b of allBuildings) {
      for (let dx = 0; dx < b.w; dx++) {
        for (let dy = 0; dy < b.h; dy++) {
          const key = `${b.x + dx},${b.y + dy}`;
          buildingMap.set(key, b);
        }
      }
    }
  }

  function preCalculateChunks() {
    const numLevels = 4;
    for (let level = 0; level < numLevels; level++) {
      const chunkSize = Math.pow(2, level + 1);
      const levelMap = new Map();
      
      for (let x = 0; x < N; x += chunkSize) {
        for (let y = 0; y < N; y += chunkSize) {
          const biome = getBiomeForTile(x, y);
          levelMap.set(`${x},${y}`, { x, y, size: chunkSize, biome: biome });
        }
      }
      chunkLevels.push(levelMap);
    }
  }


  fetch('baseMap.json')
    .then(r=>r.ok? r.json(): Promise.resolve({ unoccupiableTiles:[], defaultBuildings:[] }))
    .then(d=>{
      Object.assign(baseMap, d);
      preProcessBuildings();
      preCalculateChunks();
      
      // Initialize UI features before starting the main loop
      initializeUI();

      resize();
      
      requestAnimationFrame(mainLoop);
    })
    .catch(e=>{ console.error(e); alert('BaseMap load error'); });
  
  let userBuildings = [];

  // camera + stats state …
  const cam = { x:0, y:0, scale:1 };
  let lastFrame = performance.now(),
      tileCount = 0,
      lastFPS = 0,
      lastTiles = 0;
  let selection = null; 
  let minFitScale = 0.01;
  let isInitialLoad = true;
  let touchStartTime = 0; 

  // --- NEW Patch Notes & Versioning Logic ---
    function showPatchNotes() {
        const notesForVersion = patchNotes[CURRENT_VERSION];
        if (!notesForVersion) return;

        let content = `<h4>Version ${CURRENT_VERSION}</h4><ul>`;
        notesForVersion.forEach(note => {
            content += `<li>${note}</li>`;
        });
        content += '</ul>';
        patchNotesBody.innerHTML = content;

        modalOverlay.style.display = 'block';
        patchNotesModal.style.display = 'block';
    }

    function hidePatchNotes() {
        if (hidePatchNotesCheckbox.checked) {
            localStorage.setItem('lastSeenVersion', CURRENT_VERSION);
        }
        modalOverlay.style.display = 'none';
        patchNotesModal.style.display = 'none';
    }

    function initializeUI() {
        // Set version display
        versionDisplay.textContent = 'V' + CURRENT_VERSION;

        // Set up event listeners for patch notes
        patchNotesBtn.addEventListener('click', showPatchNotes);
        closePatchNotesBtn.addEventListener('click', hidePatchNotes);
        modalOverlay.addEventListener('click', hidePatchNotes); // Click outside to close

        // Check if patch notes should be shown on startup
        const lastSeenVersion = localStorage.getItem('lastSeenVersion');
        if (lastSeenVersion !== CURRENT_VERSION) {
            showPatchNotes();
        }
    }


  // coord transforms
  function worldToScreen(x,y) {
    return [(x - y)*(tileW/2), -(x + y)*(tileH/2)];
  }
  function screenToWorld(sx,sy) {
    const lx = (sx - cam.x)/cam.scale,
          ly = (sy - cam.y)/cam.scale,
          u  = lx/(tileW/2),
          v  = -ly/(tileH/2);
    const x = Math.round((u+v)/2),
          y = Math.round((v-u)/2);
    return [x,y];
  }

  function getBuildingAt(x, y) {
    return buildingMap.get(`${x},${y}`) || null;
  }

  function getBiomeForTile(x, y) {
    const { fertile, plains } = biomeRegions;
    if (x >= fertile.x1 && x <= fertile.x2 && y >= fertile.y1 && y <= fertile.y2) {
      return 'fertile';
    }
    if (x >= plains.x1 && x <= plains.x2 && y >= plains.y1 && y <= plains.y2) {
      return 'plains';
    }
    return 'badlands';
  }

  // --- GRID DRAWING ---
  function drawTile(x, y, drawBorder = true) {
    tileCount++;
    const [sx,sy] = worldToScreen(x,y);
    ctx.beginPath();
    ctx.moveTo(   sx,        sy - tileH/2);
    ctx.lineTo(sx + tileW/2, sy      );
    ctx.lineTo(   sx,        sy + tileH/2);
    ctx.lineTo(sx - tileW/2, sy      );
    ctx.closePath();

    const biome = getBiomeForTile(x, y);
    ctx.fillStyle = biomeColors[biome];
    ctx.fill();
    if (drawBorder) {
      ctx.stroke();
    }

    const building = getBuildingAt(x, y);
    if (building && building.hideCoordinates) {
        return;
    }

    const pct = Math.round((cam.scale / baseScale) * 100);
    const showThreshold = coordsToggle.checked ? 80 : 200;

    if (pct <= showThreshold) {
        return;
    }
    
    const availableWidth = tileW;
    const availableHeight = tileH;
    const text = `${x}, ${y}`;
    const padding = 0.8;
    let optimalFontSize = Math.min(
      availableHeight * padding * 0.5,
      (availableWidth * padding / text.length) * 1.8
    );
    
    optimalFontSize *= 0.7;

    if ((optimalFontSize * cam.scale) < 5) {
        return;
    }

    ctx.fillStyle = textColor;
    ctx.font = `${optimalFontSize}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, sx, sy);
  }

  function drawChunk(chunk, drawBorder = true) {
    tileCount += chunk.size * chunk.size;
    const { x, y, size, biome } = chunk;

    const inflation = drawBorder ? 0 : (1 / cam.scale);

    const x0 = x, y0 = y, w = size, h = size;
    const bottomTile = { x: x0, y: y0 };
    const rightTile  = { x: x0 + w - 1, y: y0 };
    const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
    const leftTile   = { x: x0, y: y0 + h - 1 };
    const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
    const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
    const [stx, sty] = worldToScreen(topTile.x, topTile.y);
    const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);

    const p_bottom = { x: sbx, y: sby + tileH/2 + inflation };
    const p_right  = { x: srx + tileW/2 + inflation, y: sry };
    const p_top    = { x: stx, y: sty - tileH/2 - inflation };
    const p_left   = { x: slx - tileW/2 - inflation, y: sly };

    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y);
    ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x,    p_top.y);
    ctx.lineTo(p_left.x,   p_left.y);
    ctx.closePath();

    ctx.fillStyle = biomeColors[biome];
    ctx.fill();
    if (drawBorder) {
      ctx.stroke();
    }
  }


  function drawBuildingFootprint(b, highlightStyle = null, drawBorder = true) {
    const fill = highlightStyle ? 'rgba(0,0,0,0)' : (b.fillColor || 'rgba(0,255,0,0.3)');
    const border = highlightStyle || b.borderColor || 'rgba(0,255,0,0.3)';
    const x0 = b.x, y0 = b.y, w = b.w, h = b.h;

    const bottomTile = { x: x0, y: y0 };
    const rightTile  = { x: x0 + w - 1, y: y0 };
    const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
    const leftTile   = { x: x0, y: y0 + h - 1 };
    const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
    const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
    const [stx, sty] = worldToScreen(topTile.x, topTile.y);
    const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);
    const p_bottom = { x: sbx, y: sby + tileH/2 };
    const p_right  = { x: srx + tileW/2, y: sry };
    const p_top    = { x: stx, y: sty - tileH/2 };
    const p_left   = { x: slx - tileW/2, y: sly };
    
    ctx.beginPath();
    ctx.moveTo(p_bottom.x, p_bottom.y);
    ctx.lineTo(p_right.x,  p_right.y);
    ctx.lineTo(p_top.x,    p_top.y);
    ctx.lineTo(p_left.x,   p_left.y);
    ctx.closePath();
    
    ctx.fillStyle = fill;
    ctx.fill();
    
    ctx.strokeStyle = border; 
    ctx.lineWidth = highlightStyle ? strokeW * 2 : strokeW;
    if (drawBorder) {
        ctx.stroke();
    }

    if (cam.scale > 0.4 && b.displayName) {
      const availableWidth = (p_right.x - p_left.x) * 0.8;
      const availableHeight = p_bottom.y - p_top.y;
      
      if (availableWidth < 10 || availableHeight < 10) return;
      
      const hasCoords = b.displayCoordinates;
      const coordText = `(X${b.x}, Y${b.y})`;
      const heightFactor = hasCoords ? 0.5 : 1.0; 
      
      const fontSizeBasedOnHeight = (availableHeight * heightFactor) * 0.9;

      ctx.font = `bold 100px sans-serif`;
      const widthAtRefSize = ctx.measureText(b.displayName).width;
      const fontSizeBasedOnWidth = (availableWidth / widthAtRefSize) * 100;

      const optimalFontSize = Math.min(fontSizeBasedOnHeight, fontSizeBasedOnWidth);

      if (optimalFontSize * cam.scale < 7) return;
      
      const centerX = (p_left.x + p_right.x) / 2;
      const yOffset = hasCoords ? optimalFontSize * -0.45 : 0;
      const centerY = (p_top.y + p_bottom.y) / 2 + yOffset;

      ctx.fillStyle = textColor;
      ctx.font = `bold ${optimalFontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.displayName, centerX, centerY);
      
      if (b.displayCoordinates) {
        const coordFontSize = optimalFontSize * 0.7;
        ctx.font = `${coordFontSize}px sans-serif`;
        ctx.fillText(coordText, centerX, centerY + optimalFontSize * 0.9);
      }
    }
  }

  function centerOn(x,y) {
    const [lx, ly] = worldToScreen(x,y);
    cam.x = canvas.width*0.5 - lx*cam.scale;
    cam.y = canvas.height*0.5 - ly*cam.scale;
  }
  
  function zoomToFit() {
    cam.scale = minFitScale;
    clampCamera();
  }

  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    const mapTotalWidth = (N - 1) * tileW;
    const mapTotalHeight = (N - 1) * tileH;
    
    const scaleX = canvas.width / mapTotalWidth;
    const scaleY = canvas.height / mapTotalHeight;

    const padding = 0.95;
    minFitScale = Math.min(scaleX, scaleY) * padding;
    
    if (isInitialLoad) {
        zoomToFit();
        isInitialLoad = false;
    } else {
        clampCamera();
    }
  }
  window.addEventListener('resize', resize);

function clampCamera() {
    const s = cam.scale;
    const mapTotalWidth = (N - 1) * tileW;
    const mapTotalHeight = (N - 1) * tileH;
    const mapScaledWidth = mapTotalWidth * s;
    const mapScaledHeight = mapTotalHeight * s;

    const worldHalfWidth = mapScaledWidth / 2;
    
    const overscrollX = canvas.width * 0.5;
    const overscrollY = canvas.height * 0.5;

    if (mapScaledWidth < canvas.width) {
      cam.x = canvas.width / 2;
    } else {
      const minCamX = canvas.width - worldHalfWidth;
      const maxCamX = worldHalfWidth;
      cam.x = Math.max(minCamX - overscrollX, Math.min(maxCamX + overscrollX, cam.x));
    }
    
    if (mapScaledHeight < canvas.height) {
      cam.y = canvas.height / 2 + mapScaledHeight / 2;
    } else {
      const minCamY = canvas.height;
      const maxCamY = mapScaledHeight;
      cam.y = Math.max(minCamY - overscrollY, Math.min(maxCamY + overscrollY, cam.y));
    }
  }

  let dragging=false, lastX, lastY;
  let clickStartX, clickStartY;
  canvas.addEventListener('mousedown', e=>{
    if (e.button===0) {
      dragging=true;
      lastX = e.clientX;
      lastY = e.clientY;
      clickStartX = e.clientX;
      clickStartY = e.clientY;
    }
  });
  window.addEventListener('mousemove', e=>{
    if (!dragging) return;
    cam.x += e.clientX - lastX;
    cam.y += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    clampCamera();
  });
  window.addEventListener('mouseup', ()=>dragging=false);

  canvas.addEventListener('click', e => {
    const dist = Math.hypot(e.clientX - clickStartX, e.clientY - clickStartY);
    if (dist > 5) {
      return;
    }
    const [worldX, worldY] = screenToWorld(e.offsetX, e.offsetY);

    if (worldX >= 0 && worldX < N && worldY >= 0 && worldY < N) {
      const building = getBuildingAt(worldX, worldY);
      
      if (building) {
        selection = building;
        inpX.value = building.x;
        inpY.value = building.y;
      } else {
        selection = { x: worldX, y: worldY };
        inpX.value = worldX;
        inpY.value = worldY;
      }
    }
  });

  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.1 : 0.9;
    const mx = e.offsetX, my = e.offsetY;
    const wx = (mx - cam.x)/cam.scale,
          wy = (my - cam.y)/cam.scale;
    cam.scale *= factor;
    cam.scale = Math.max(minFitScale,
      Math.min(maxPct/100 * baseScale, cam.scale));
    cam.x = mx - wx * cam.scale;
    cam.y = my - wy * cam.scale;
    clampCamera();
  },{ passive:false });

  function animateZoom(targetScale, anchorX, anchorY, duration=150) {
    const startScale = cam.scale;
    const startX = cam.x, startY = cam.y;
    const start = performance.now();
    const wx = (anchorX - startX)/startScale,
          wy = (anchorY - startY)/startScale;

    function step(now) {
      const t = Math.min(1, (now - start)/duration);
      const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
      cam.scale = startScale + (targetScale - startScale)*k;
      cam.x = anchorX - wx * cam.scale;
      cam.y = anchorY - wy * cam.scale;
      clampCamera();
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  canvas.addEventListener('dblclick', e=>{
    e.preventDefault();
    const curPct = Math.round((cam.scale / baseScale) * 100);
    let targetPct;
    if (e.button === 2) { 
      targetPct = curPct - 75;
    } else { 
      targetPct = curPct + 75;
    }
    const targetScale = (targetPct / 100) * baseScale;
    animateZoom(Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale)), e.offsetX, e.offsetY);
  });

  canvas.addEventListener('contextmenu', e=>e.preventDefault());

  let hideLabelTimeout;

    function updateFloatingZoomLabel() {
        const slider = zoomSlider;
        const label = floatingZoomLabel;
        
        const min = parseInt(slider.min, 10);
        const max = parseInt(slider.max, 10);
        const val = parseInt(slider.value, 10);

        const percent = (val - min) / (max - min);

        const thumbHeight = 15;
        const trackHeight = slider.offsetHeight;
        const topPos = (1 - percent) * (trackHeight - thumbHeight) + (thumbHeight / 2);
        
        label.style.top = `${topPos}px`;
        label.textContent = `Zoom: ${val}%`;
        label.style.display = 'block';

        clearTimeout(hideLabelTimeout);
        hideLabelTimeout = setTimeout(() => {
            label.style.display = 'none';
        }, 1500);
    }

    zoomSlider.addEventListener('input', () => {
        const cx = canvas.width/2, cy = canvas.height/2;
        const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
        let pct = Number(zoomSlider.value);
        const targetScale = (pct / 100) * baseScale;
        cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
        cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
        clampCamera();
        updateFloatingZoomLabel();
    });
    
    zoomSlider.addEventListener('mousedown', () => {
        clearTimeout(hideLabelTimeout);
        updateFloatingZoomLabel();
    });


  function changeZoomBy(delta) {
    const cx = canvas.width/2, cy = canvas.height/2;
    const wx = (cx - cam.x)/cam.scale, wy = (cy - cam.y)/cam.scale;
    let pct = Math.round((cam.scale / baseScale) * 100) + delta;
    const targetScale = (pct / 100) * baseScale;
    cam.scale = Math.max(minFitScale, Math.min(maxPct / 100 * baseScale, targetScale));
    cam.x = cx - wx*cam.scale; cam.y = cy - wy*cam.scale;
    clampCamera();
  }
  zoomDecBtn.addEventListener('click', ()=>changeZoomBy(-1));
  zoomIncBtn.addEventListener('click', ()=>changeZoomBy(+1));

  presetBtns.forEach(b => {
    const zoomVal = b.dataset.zoom;
    if (zoomVal === 'Fit') {
        b.textContent = 'Fit';
        b.addEventListener('click', zoomToFit);
        return;
    }

    b.addEventListener('click', () => {
        const cx = canvas.width/2, cy = canvas.height/2;
        let pct = Number(zoomVal);
        const targetScale = (pct / 100) * baseScale;
        animateZoom(targetScale, cx, cy, 200);
    });
  });

  window.addEventListener('keydown', e=>{
    if (e.target.tagName==='INPUT') return;
    switch(e.key) {
      case '+': case '=': changeZoomBy(+1); break;
      case '-': changeZoomBy(-1); break;
      case 'q': changeZoomBy(+1); break;
      case 'e': changeZoomBy(-1); break;
      case 'ArrowUp':    cam.y += tileW * 5; clampCamera(); break;
      case 'ArrowDown':  cam.y -= tileW * 5; clampCamera(); break;
      case 'ArrowLeft':  cam.x += tileW * 5; clampCamera(); break;
      case 'ArrowRight': cam.x -= tileW * 5; clampCamera(); break;
    }
  });

  function doSearch() {
    const x = +inpX.value, y = +inpY.value;
    if (x>=0 && y>=0 && x<N && y<N) {
      const building = getBuildingAt(x, y);
      selection = building || { x, y };

      const targetScale = (150 / 100) * baseScale;
      
      const [screenX, screenY] = worldToScreen(x, y);
      const targetCamX = canvas.width/2 - screenX * targetScale;
      const targetCamY = canvas.height/2 - screenY * targetScale;
      
      animatePanZoom(targetScale, targetCamX, targetCamY);
    }
  }

  function animatePanZoom(targetScale, targetX, targetY, duration=300) {
      const startScale = cam.scale, startX = cam.x, startY = cam.y;
      const start = performance.now();

      function step(now) {
          const t = Math.min(1, (now - start)/duration);
          const k = t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
          
          cam.scale = startScale + (targetScale - startScale)*k;
          cam.x = startX + (targetX - startX)*k;
          cam.y = startY + (targetY - startY)*k;
          
          clampCamera();
          if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
  }
  btnGo.addEventListener('click', doSearch);
  [inpX,inpY].forEach(i=>{
    i.addEventListener('keydown', e=>{ if (e.key==='Enter') doSearch(); });
  });

  let touchMode = null;
  let startDist, startScale, pinchCenter;

canvas.addEventListener('touchstart', e=>{
    e.preventDefault();
    if (e.touches.length===1) {
      touchMode = 'pan';
      const t = e.touches[0];
      lastX = t.clientX;
      lastY = t.clientY;
      clickStartX = t.clientX;
      clickStartY = t.clientY;
      touchStartTime = performance.now();
    } else if (e.touches.length===2) {
      touchMode = 'pinch';
      const [a,b] = e.touches;
      startDist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
      startScale= cam.scale;
      pinchCenter = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', e=>{
    e.preventDefault();
    if (touchMode==='pan' && e.touches.length===1) {
      const t = e.touches[0];
      const dx = t.clientX - lastX, dy = t.clientY - lastY;
      cam.x += dx; cam.y += dy;
      lastX = t.clientX; lastY = t.clientY;
      clampCamera();
    }
    else if (touchMode==='pinch' && e.touches.length===2) {
      const [a,b] = e.touches;
      const dist = Math.hypot(b.clientX-a.clientX, b.clientY-a.clientY);
      let scaleFactor = dist / startDist;
      let newScale = startScale * scaleFactor;
      newScale = Math.max(minFitScale, Math.min(maxPct/100 * baseScale, newScale));
      const wx = (pinchCenter.x - cam.x)/cam.scale, wy = (pinchCenter.y - cam.y)/cam.scale;
      cam.scale = newScale;
      cam.x = pinchCenter.x - wx*newScale;
      cam.y = pinchCenter.y - wy*newScale;
      clampCamera();
    }
  }, { passive:false });

  canvas.addEventListener('touchend', e=>{
    if (touchMode === 'pan' && e.changedTouches.length === 1) {
      const t = e.changedTouches[0];
      const dist = Math.hypot(t.clientX - clickStartX, t.clientY - clickStartY);
      const duration = performance.now() - touchStartTime;

      if (duration < 200 && dist < 10) {
        const [worldX, worldY] = screenToWorld(t.clientX, t.clientY);
        if (worldX >= 0 && worldX < N && worldY >= 0 && worldY < N) {
          const building = getBuildingAt(worldX, worldY);
          
          if (building) {
            selection = building;
            inpX.value = building.x;
            inpY.value = building.y;
          } else {
            selection = { x: worldX, y: worldY };
            inpX.value = worldX;
            inpY.value = worldY;
          }
        }
      }
    }
    
    if (e.touches.length<2) touchMode = null;
  });
  
  function getChunkLevelForZoom(pct) {
    if (pct <= 10) return 3;
    if (pct <= 20) return 2;
    if (pct <= 40) return 1;
    if (pct <= 80) return 0;
    return -1;
  }

  function mainLoop(now) {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const [centerX, centerY] = screenToWorld(canvas.width/2, canvas.height/2);
    centerTileEl.textContent = `Center: X${Math.round(centerX)} Y${Math.round(centerY)}`;
    
    const pct = Math.round((cam.scale / baseScale) * 100);
    zoomLevelEl.textContent = `Zoom: ${pct}%`;
    
    if (pct > zoomSlider.max) {
      zoomSlider.max = pct;
    }
    zoomSlider.value = pct;
    
    tileCount = 0;

    ctx.save();
    ctx.setTransform(cam.scale,0,0,cam.scale,cam.x,cam.y);
    
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = strokeW;
    
    const shouldDrawBorders = pct > 40;
    
    const [tl_x, tl_y] = screenToWorld(0, 0);
    const [tr_x, tr_y] = screenToWorld(canvas.width, 0);
    const [bl_x, bl_y] = screenToWorld(0, canvas.height);
    const [br_x, br_y] = screenToWorld(canvas.width, canvas.height);

    const buffer = 2;
    const viewBounds = {
      minX: Math.min(tl_x, tr_x, bl_x, br_x) - buffer,
      maxX: Math.max(tl_x, tr_x, bl_x, br_x) + buffer,
      minY: Math.min(tl_y, tr_y, bl_y, br_y) - buffer,
      maxY: Math.max(tl_y, tr_y, bl_y, br_y) + buffer,
    };

    const chunkLevel = getChunkLevelForZoom(pct);
    
    if (chunkLevel === -1) {
      const minSum = Math.floor(viewBounds.minX + viewBounds.minY);
      const maxSum = Math.ceil(viewBounds.maxX + viewBounds.maxY);

      for (let sum = minSum; sum <= maxSum; sum++) {
        const startX = Math.floor(Math.max(viewBounds.minX, (sum - viewBounds.maxY)));
        const endX = Math.ceil(Math.min(viewBounds.maxX, (sum - viewBounds.minY)));

        for (let x = startX; x <= endX; x++) {
            const y = sum - x;
            if (x < 0 || x >= N || y < 0 || y >= N) continue;
            if (!getBuildingAt(x, y)) drawTile(x, y, shouldDrawBorders);
        }
      }
    } else {
      const chunksToDraw = chunkLevels[chunkLevel];
      const chunkSize = Math.pow(2, chunkLevel + 1);

      const startChunkX = Math.floor(viewBounds.minX / chunkSize) * chunkSize;
      const endChunkX = Math.ceil(viewBounds.maxX / chunkSize) * chunkSize;
      const startChunkY = Math.floor(viewBounds.minY / chunkSize) * chunkSize;
      const endChunkY = Math.ceil(viewBounds.maxY / chunkSize) * chunkSize;
      
      for (let x = startChunkX; x <= endChunkX; x += chunkSize) {
        for (let y = startChunkY; y <= endChunkY; y += chunkSize) {
            const chunk = chunksToDraw.get(`${x},${y}`);
            if (chunk) {
                drawChunk(chunk, shouldDrawBorders);
            }
        }
      }
    }

    ctx.fillStyle = '#444';
    baseMap.unoccupiableTiles.forEach(([x,y])=>{
      if (getBuildingAt(x, y)) return;
      if (x < viewBounds.minX || x > viewBounds.maxX || y < viewBounds.minY || y > viewBounds.maxY) return;
      const [sx,sy] = worldToScreen(x,y);
      ctx.beginPath();
      ctx.moveTo(sx, sy - tileH/2);
      ctx.lineTo(sx + tileW/2, sy);
      ctx.lineTo(sx, sy + tileH/2);
      ctx.lineTo(sx - tileW/2, sy);
      ctx.closePath();
      ctx.fill();
    });

    const allBuildings = [...baseMap.defaultBuildings, ...userBuildings];
    const visibleBuildings = allBuildings.filter(b => 
        !(b.x > viewBounds.maxX || b.x + b.w < viewBounds.minX || b.y > viewBounds.maxY || b.y + b.h < viewBounds.minY)
    );

    if (chunkLevel !== -1) {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      
      visibleBuildings.forEach(b => {
        const x0 = b.x, y0 = b.y, w = b.w, h = b.h;
        const bottomTile = { x: x0, y: y0 };
        const rightTile  = { x: x0 + w - 1, y: y0 };
        const topTile    = { x: x0 + w - 1, y: y0 + h - 1 };
        const leftTile   = { x: x0, y: y0 + h - 1 };
        const [sbx, sby] = worldToScreen(bottomTile.x, bottomTile.y);
        const [srx, sry] = worldToScreen(rightTile.x, rightTile.y);
        const [stx, sty] = worldToScreen(topTile.x, topTile.y);
        const [slx, sly] = worldToScreen(leftTile.x, leftTile.y);
        const p_bottom = { x: sbx, y: sby + tileH/2 };
        const p_right  = { x: srx + tileW/2, y: sry };
        const p_top    = { x: stx, y: sty - tileH/2 };
        const p_left   = { x: slx - tileW/2, y: sly };
        
        ctx.beginPath();
        ctx.moveTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_right.x,  p_right.y);
        ctx.lineTo(p_top.x,    p_top.y);
        ctx.lineTo(p_left.x,   p_left.y);
        ctx.closePath();
        
        ctx.fillStyle = '#000';
        ctx.fill();
      });
      ctx.restore();
    }
    
    visibleBuildings.forEach(b => {
        drawBuildingFootprint(b, null, shouldDrawBorders);
    });

    if (selection) {
      if (selection.w) {
        drawBuildingFootprint(selection, selectionColor, true);
      } else {
        const [sx, sy] = worldToScreen(selection.x, selection.y);
        ctx.beginPath();
        ctx.moveTo(sx, sy - tileH/2);
        ctx.lineTo(sx + tileW/2, sy);
        ctx.lineTo(sx, sy + tileH/2);
        ctx.lineTo(sx - tileW/2, sy);
        ctx.closePath();
        ctx.strokeStyle = selectionColor;
        ctx.lineWidth = strokeW * 1.5;
        ctx.stroke();
      }
    }
    ctx.restore();

    const dt  = now - lastFrame;
    lastFrame = now;
    lastFPS   = Math.round(1000/dt);
    lastTiles = tileCount;
    
    if (!mainLoop.t0) mainLoop.t0 = now;
    if (now - mainLoop.t0 > 500) {
      statsFPSEl.textContent   = `FPS:   ${lastFPS}`;
      statsTilesEl.textContent = `Tiles: ${lastTiles}`;
      mainLoop.t0 = now;
    }
    
    requestAnimationFrame(mainLoop);
  }
  </script>
</body>
</html>